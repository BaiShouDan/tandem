{

const {
  flatten
} = require("lodash");

const {
  LiteralExpression,
  CSSRuleExpression,
  CSSStyleExpression,
  CSSMediaExpression,
  CSSLiteralExpression,
  CSSKeyFrameExpression,
  CSSListValueExpression,
  CSSKeyFramesExpression,
  CSSStyleSheetExpression,
  CSSFunctionCallExpression,
  CSSPsuedoSelectorExpression,
  CSSStyleDeclarationExpression,

  CSSIDSelectorExpression,
  CSSAnySelectorExpression,
  CSSSelectorListExpression,
  CSSChildSelectorExpression,
  CSSSiblingSelectorExpression,
  CSSAdjacentSiblingSelectorExpression,
  CSSTagNameSelectorExpression,
  CSSClassNameSelectorExpression,
  CSSDescendentSelectorExpression,
  CSSComment,

  CSSAndSelectorExpression,
  CSSAttributeStartsWithSelectorExpression,
  CSSAttributeContainsSelectorExpression,
  CSSAttributeEndsWithSelectorExpression,
  CSSAttributeEqualsSelectorExpression,
  CSSAttributeExistsSelectorExpression,
} = require("./expressions");

function position() {
  return {
    start:peg$savedPos,
    end:peg$currPos
  };
}
}

Start
  = Expression

Expression
  = CSSStyleSheetExpression

CSSStyleSheetExpression
  = _ rules:(CSSRule/CSSMedia/CSSKeyFrames/CSSFontFace/CSSRest)* _ {
    return new CSSStyleSheetExpression(rules.filter((rule) => !!rule));
  }

CSSRule
  = _ selector: CSSSelectors style: CSSStyle {
    return new CSSRuleExpression(selector, style);
  }

CSSStyle
  = _ "{" _ declarations: CSSStyleDeclaration* _  "}" _ {
    return new CSSStyleExpression(declarations, position());
  }

CSSSelectors
  = first:CSSSelector rest:CSSSelectorSibling* {
    return new CSSSelectorListExpression([first].concat(rest));
  }

CSSSelectorSibling
  = _ "," selector:CSSSelector { return selector; }

CSSSelector
  = _ last: CSSSelectorRule _ rest: CSSChildSelector*  {

    const classes = {
      ">": CSSChildSelectorExpression,
      "~": CSSSiblingSelectorExpression,
      "+": CSSAdjacentSiblingSelectorExpression,
    };

    function createExpression(items) {
      const child  = items.pop();
      const op     = items.pop();
      if (!items.length) return child;
      const clazz  = classes[op] || CSSDescendentSelectorExpression;
      return new clazz(createExpression(items), child);
    }

    return createExpression(flatten([last].concat(rest)));
  }
  / CSSSelectorRule

CSSChildSelector
  = _ operator: (">"/"+"/"~")? _ selector: CSSSelectorRule {
    return [operator, selector];
  }

CSSNestedSelectorRule
  = operator:(">"/" "+) nested:CSSSelectorRule {
    return nested;
  }


CSSSelectorRule
  = rule: CSSItemSelector? ":" pseudo: CSSPseudoSelectorRule {
    return new CSSPsuedoSelectorExpression(rule, pseudo, [], position())
  }
  / CSSItemSelector

CSSPseudoSelectorRule
  = name: [^ {]+ {
    return text();
  }

CSSItemSelector
  = CSSAttributeSelector/CSSTagSelector

CSSAttributeSelector
  = tag:CSSTagSelector? "[" rule: CSSAttributeSelectorRule "]" {
    return new CSSAndSelectorExpression(tag || new CSSAnySelectorExpression(null), rule);
  }

CSSAttributeSelectorRule
  = name: CSSTagSelectorText op: ("="/"~="/"|="/"^="/"$="/"*=") value: CSSAttributeSelectorValue {
    const clazz = {
      "=": CSSAttributeEqualsSelectorExpression,
      "~=": CSSAttributeContainsSelectorExpression,
      "$=": CSSAttributeEndsWithSelectorExpression,
      "*=": CSSAttributeContainsSelectorExpression,
      "|=": CSSAttributeStartsWithSelectorExpression,
      "^=": CSSAttributeStartsWithSelectorExpression,
    }[op];
    return new clazz(name, value, position());
  }
  / name: CSSTagSelectorText {
    return new CSSAttributeExistsSelectorExpression(name, position());
  }

CSSAttributeSelectorValue
  = String/CSSAttributeSelectorValueCharacter+ { return text(); }

String
  = '"' characters:DoubleStringCharacter* '"' { return characters.join(''); }
  / "'" characters:SingleStringCharacter* "'" { return characters.join(''); }

DoubleStringCharacter
  = !('"' / "\\") . { return text(); }
  / '\\"'

SingleStringCharacter
  = !("'" / "\\") . { return text(); }
  / "\\'"

CSSMedia
  = "@media" _ query:CSSMediaQuery _ "{" stylesheet: CSSStyleSheetExpression "}" _ {
    return new CSSMediaExpression(query, stylesheet, position());
  }

CSSMediaQuery
  = [^{]+ { return text().trim(); }

CSSFontFace
  = "@font-face" _ style: CSSStyle _ {
  }

CSSRest
  = "@"[^{]+ CSSRestInnerBlock _ {
  }

CSSRestInnerBlock
  = "{" CSSRestInnerBlock* "}"
  / !"}" .

CSSKeyFrames
  = "@keyframes" _ name: CSSKeyFrameName _ "{" keyframes:CSSKeyFrame* "}" {
    return new CSSKeyFramesExpression(name, keyframes, position());
  }


CSSKeyFrame
  = _ start:CSSKeyFrameStart _ style:CSSStyle _ {
    return new CSSKeyFrameExpression(start, style);
  }

CSSKeyFrameName
  = [^{]+ { return text().trim(); }

CSSKeyFrameStart
  = "from" { return 0; }
  / "to" { return 100; }
  / value:[\d]+ "%" { return Number(value) }

CSSAttributeSelectorValueCharacter
  = !"]" . { return text(); }

CSSTagSelector
  = "." value: CSSTagSelectorText { return new CSSClassNameSelectorExpression(value, position()) }
  / "#" value: CSSTagSelectorText { return new CSSIDSelectorExpression(value, position()); }
  / "*" { return new CSSAnySelectorExpression(position()); }
  / CSSTagSelectorText { return new CSSTagNameSelectorExpression(text(), position()); }

CSSTagSelectorText
  = CSSSelectorCharacter+ { return text().trim(); }

CSSSelectorCharacter
  = [a-zA-Z0-9_-] { return text(); }

CSSStyleDeclaration
  = !("}") _ key:CSSStyleDeclarationKey _ ':' _ value:CSSLiteralValue? _ ';'? _ {
    return new CSSStyleDeclarationExpression(key, value || new CSSLiteralExpression(""), position());
  }

CSSStyleDeclarationKey
  = value:([^:]+) {
    return text();
  }

CSSStyleDeclarationValue
  = CSSSingleValue

CSSSingleValue
  = CSSLiteralValue

CSSLiteralValue
  = value:CSSValue {
    return new CSSLiteralExpression(text(), position());
  }

CSSFunctionCall
  = name:CSSValue parameters:Parameters {
    return new CSSFunctionCallExpression(name, parameters, position());
  }

Parameters
  = '(' parameters:CSSCommaList ')' {
    return parameters;
  }
  /  '(' ')' {
    return [];
  }

CSSListValue
  = values:(CSSSpaceList/CSSCommaList) {
    return values.length === 1 ? values[0] : new CSSListValueExpression(values, position());
  }

CSSCommaList
  = first:CSSSingleValue rest:(',' _ CSSSingleValue)*  {
    return [first].concat(rest.map(function (v) {
      return v[1];
    }));
  }

CSSSpaceList
  = first:CSSSingleValue rest:(' ' CSSSingleValue)* {
    return [first].concat(rest.map(function (v) {
      return v[1];
    }));
  }

CSSValue
  = CSSValueCharacter+ { return text(); }

CSSValueCharacter
  = !(";"/"}"). { return text(); }
/**
 * Generic
 */

Number
  = (Digit '.' Digit+) / ('.' Digit+) / Digit {
    return new LiteralExpression(Number(text()), position());
  }

Digit
  = [0-9]

_
  = ws "/*" CommentCharacter* "*/" ws
  / ws

ws
  = [ \n\r\t]*

CommentCharacter
  = !"*/" .
