{

const {
  flatten
} = require("lodash");

const {
  LiteralExpression,
  CSSRuleExpression,
  CSSStyleExpression,
  CSSLiteralExpression,
  CSSListValueExpression,
  CSSStyleSheetExpression,
  CSSFunctionCallExpression,
  CSSStyleDeclarationExpression,

  CSSIDSelectorExpression,
  CSSAnySelectorExpression,
  CSSSelectorListExpression,
  CSSChildSelectorExpression,
  CSSSiblingSelectorExpression,
  CSSTagNameSelectorExpression,
  CSSClassNameSelectorExpression,
  CSSDescendentSelectorExpression,

  CSSAndSelectorExpression,
  CSSAttributeStartsWithSelectorExpression,
  CSSAttributeContainsSelectorExpression,
  CSSAttributeEndsWithSelectorExpression,
  CSSAttributeEqualsSelectorExpression,
  CSSAttributeExistsSelectorExpression,
} = require("./expressions");

function position() {
  return {
    start:peg$savedPos,
    end:peg$currPos
  };
}
}

Start
  = CSSStyleSheetExpression

CSSStyleSheetExpression
  = rules:CSSRule* {
    return new CSSStyleSheetExpression(rules);
  }

CSSRule
  = _ selector: CSSSelectors _ "{" style: CSSStyle "}" _ {
    return new CSSRuleExpression(selector, style);
  }

CSSStyle
  = _ declarations: CSSStyleDeclaration* _ {
    return new CSSStyleExpression(declarations, position());
  }

CSSSelectors
  = first:CSSSelector rest:CSSSelectorSibling* {
    return new CSSSelectorListExpression([first].concat(rest));
  }

CSSSelectorSibling
  = _ "," selector:CSSSelector { return selector; }

CSSSelector
  = _ last: CSSSelectorRule _ rest: CSSChildSelector*  {

    const classes = {
      ">": CSSChildSelectorExpression,
      "+": CSSSiblingSelectorExpression
    };

    function createExpression(items) {
      const child  = items.pop();
      const op     = items.pop();
      if (!items.length) return child;
      const clazz  = classes[op] || CSSDescendentSelectorExpression;
      return new clazz(createExpression(items), child);
    }

    return createExpression(flatten([last].concat(rest)));
  }
  / CSSSelectorRule

CSSChildSelector
  = _ operator: (">"/"+")? _ selector: CSSSelectorRule {
    return [operator, selector];
  }

CSSNestedSelectorRule
  = operator:(">"/" "+) nested:CSSSelectorRule {
    return nested;
  }

CSSSelectorRule
  = rule: CSSItemSelector ":" pseudo: CSSPseudoSelectorRule {
    return new CSSAndSelectorExpression(rule, pseudo)
  }
  / CSSItemSelector

CSSPseudoSelectorRule
  = name: [^(]+ {

  }

CSSItemSelector
  = CSSAttributeSelector/CSSTagSelector

CSSAttributeSelector
  = tag:CSSTagSelector "[" rule: CSSAttributeSelectorRule "]" {
    return new CSSAndSelectorExpression(tag, rule);
  }

CSSAttributeSelectorRule
  = name: CSSTagSelectorText op: ("="/"~="/"|="/"^="/"$="/"*=") value: CSSAttributeSelectorValue {
    const clazz = {
      "=": CSSAttributeEqualsSelectorExpression,
      "~=": CSSAttributeContainsSelectorExpression,
      "|=": CSSAttributeStartsWithSelectorExpression,
      "^=": CSSAttributeStartsWithSelectorExpression,
      "$=": CSSAttributeEndsWithSelectorExpression,
      "*=": CSSAttributeContainsSelectorExpression
    }[op];
    return new clazz(name, value, position());
  }
  / name: CSSTagSelectorText {
    return new CSSAttributeExistsSelectorExpression(name, position());
  }

CSSAttributeSelectorValue
  = String/CSSAttributeSelectorValueCharacter+ { return text(); }


String
  = '"' characters:DoubleStringCharacter* '"' { return characters.join(''); }
  / "'" characters:SingleStringCharacter* "'" { return characters.join(''); }

DoubleStringCharacter
  = !('"' / "\\") . { return text(); }
  / '\\"'

SingleStringCharacter
  = !("'" / "\\") . { return text(); }
  / "\\'"


CSSAttributeSelectorValueCharacter
  = !"]" . { return text(); }

CSSTagSelector
  = "." value: CSSTagSelectorText { return new CSSClassNameSelectorExpression(value, position()) }
  / "#" value: CSSTagSelectorText { return new CSSIDSelectorExpression(value, position()); }
  / "*" { return new CSSAnySelectorExpression(position()); }
  / CSSTagSelectorText { return new CSSTagNameSelectorExpression(text(), position()); }


CSSTagSelectorText
  = CSSSelectorCharacter+ { return text().trim(); }

CSSSelectorCharacter
  = [a-zA-Z0-9_-] { return text(); }

CSSStyleDeclaration
  = !("}") _ key:CSSStyleDeclarationKey _ ':' _ value:CSSStyleDeclarationValue? _ ';' _ {
    return new CSSStyleDeclarationExpression(key, value || new CSSLiteralExpression(""), position());
  }

CSSStyleDeclarationKey
  = value:([^:]+) {
    return text();
  }

CSSStyleDeclarationValue
  = CSSListValue/CSSSingleValue

CSSSingleValue
  = CSSFunctionCall/CSSLiteralValue

CSSLiteralValue
  = value:CSSValue {
    return new CSSLiteralExpression(text(), position());
  }

CSSFunctionCall
  = name:CSSValue parameters:Parameters {
    return new CSSFunctionCallExpression(name, parameters, position());
  }

Parameters
  = '(' parameters:CSSCommaList ')' {
    return parameters;
  }
  /  '(' ')' {
    return [];
  }

CSSListValue
  = values:(CSSSpaceList/CSSCommaList) {
    return values.length === 1 ? values[0] : new CSSListValueExpression(values, position());
  }

CSSCommaList
  = first:CSSSingleValue rest:(',' _ CSSSingleValue)*  {
    return [first].concat(rest.map(function (v) {
      return v[1];
    }));
  }

CSSSpaceList
  = first:CSSSingleValue rest:(' ' CSSSingleValue)* {
    return [first].concat(rest.map(function (v) {
      return v[1];
    }));
  }

CSSValue
  = CSSValueCharacter+ { return text(); }

CSSValueCharacter
  = !([ ;,)(]). { return text(); }
/**
 * Generic
 */

Number
  = (Digit '.' Digit+) / ('.' Digit+) / Digit {
    return new LiteralExpression(Number(text()), position());
  }

Digit
  = [0-9]

_
  = [ \n\r\t]*
