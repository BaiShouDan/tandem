{

const {
  MarkupTextExpression,
  HTMLScriptExpression,
  MarkupCommentExpression,
  MarkupElementExpression,
  MarkupAttributeExpression,
  MarkupFragmentExpression,
} = require("./ast");
}

Start
  = Fragment

Fragment
  = nodes:(Node/TextNode)* {
    return new MarkupFragmentExpression(nodes, location());
  }

Node
  = _ node:(Comment/VoidElement/Element/TextNode) _ { return node; }

Comment
  = '<!--' characters:CommentCharacter* '-->' { return new MarkupCommentExpression(characters.join(''), location()); }

CommentCharacter
  = !'-->' character:. { return character; }

VoidElement
  = "<" nodeName: VoidTagName attributes:ElementAttributes _ (">"/"/>")? endTag:EndVoidTag? {

    if (endTag && nodeName != endTag.name) {
      expected("</" + nodeName + ">");
    }

    return new MarkupElementExpression(nodeName, attributes, [], location());
  }

EndVoidTag
  = _ "</" name: VoidTagName ">" {
    return {
      name: name
    };
  }

VoidTagName
  = name:  ("area"/"base"/"br"/"col"/"command"/"embed"/"hr"/"img"/"input"/"keygen"/"link"/"meta"/"param"/"source"/"track"/"wbr")

Element
  = ElementWithoutChildNodes
  / ElementWithChildNodes

ElementWithoutChildNodes
  = startTag:ElementStart attributes:ElementAttributes _ '/>' {
    return new MarkupElementExpression(startTag, attributes, [], location());
  }

ElementWithChildNodes
  = startTag:ElementStart attributes:ElementAttributes '>' _ childNodes:Node* _ '</' endTag:Name '>' {
    if (startTag != endTag) {
      expected('</' + startTag + '>');
    }
    return new MarkupElementExpression(startTag, attributes, childNodes, location());
  }

ElementStart
  = '<' name:Name { return name; }

ElementAttributes
  = attributes:ElementAttribute* {
    return attributes;
  }

ElementAttribute
  = _ key:Name '=' value:AttributeValue {
    return new MarkupAttributeExpression(key, value, location());
  }
  / _ key:Name _ {
    return new MarkupAttributeExpression(key, "", location());
  }

AttributeValue
  = String

String
  = '"' characters:DoubleStringCharacter* '"' { return characters.join(''); }
  / "'" characters:SingleStringCharacter* "'" { return characters.join(''); }

DoubleStringCharacter
  = !('"' / "\\") . { return text(); }
  / '\\"'

SingleStringCharacter
  = !("'" / "\\") . { return text(); }
  / "\\'"

TextNode
  = [^<]+ {
    return new MarkupTextExpression(text(), location());
  }

Name
  = [a-z0-9$-.]+ { return text(); }
_
  = [ \n\r\t]*
