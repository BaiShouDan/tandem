{

const {
  MarkupTextExpression,
  HTMLScriptExpression,
  MarkupCommentExpression,
  MarkupElementExpression,
  MarkupAttributeExpression,
  MarkupFragmentExpression,
} = require("./ast");
}

Start
  = Fragment

Fragment
  = nodes:Node* {
    return new MarkupFragmentExpression(nodes.filter(function(node) {
      return !!node;
    }), location());
  }

Node
  = TagNode/TextNode

TagNode
  = _ node:(Comment/DOCTYPE/Script/VoidElement/Element) { return node; }

Comment
  = '<!--' characters:CommentCharacter* '-->' { return new MarkupCommentExpression(characters.join(''), location()); }

CommentCharacter
  = !'-->' character:. { return character; }


DOCTYPE
  = '<!' chars:DOCTYPECharacter* '>' { return null; }

DOCTYPECharacter
  = !'>' character:. { return character; }
  
VoidElement
  = "<" nodeName: VoidTagName attributes:ElementAttributes _ (">"/"/>")? endTag:EndVoidTag? {

    if (endTag && nodeName != endTag.name) {
      expected("</" + nodeName + ">");
    }

    return new MarkupElementExpression(nodeName, attributes, [], location());
  }

EndVoidTag
  = _ "</" name: VoidTagName ">" {
    return {
      name: name
    };
  }

VoidTagName
  = name:  ("area"/"base"/"br"/"col"/"command"/"embed"/"hr"/"img"/"input"/"keygen"/"link"/"meta"/"param"/"source"/"track"/"wbr")


Script
  = ScriptWithoutChildNodes
  / ScriptWithChildNodes

ScriptWithoutChildNodes 
  = open:ScriptTagOpen "/>" {
    return new MarkupElementExpression("script", open.attributes, [], location()); 
  } 

ScriptWithChildNodes 
  = open:ScriptTagOpen ">" _ child:ScriptChildNode? _ ScriptTagClose  {
    return new MarkupElementExpression("script", open.attributes, child ? [child] : [], location()); 
  } 

ScriptTagOpen
  = "<script" _ attributes:ElementAttributes _ {
    return {
      attributes: attributes
    }
  }

ScriptChildNode
  = childChars: (String/ScriptTagChildChar)* {
  
    return new MarkupTextExpression(text(), location());
  }

ScriptTagChildChar
  = !ScriptTagClose char:. {
    return text();
  }

ScriptTagClose
  = "</script>";

Element
  = ElementWithoutChildNodes
  / ElementWithChildNodes

ElementWithoutChildNodes
  = startTag:ElementStart attributes:ElementAttributes _ '/>' {
    return new MarkupElementExpression(startTag, attributes, [], location());
  }

ElementWithChildNodes
  = startTag:ElementStart attributes:ElementAttributes _ '>' childNodes:Node* '</' endTag:Name '>' {
    if (startTag != endTag) {
      expected('</' + startTag + '>');
    }
    return new MarkupElementExpression(startTag, attributes, childNodes, location());
  }

ElementStart
  = '<' name:Name { return name; }

ElementAttributes
  = attributes:ElementAttribute* {
    return attributes;
  }


ElementAttribute
  = _ attribute: ElementAttributeInner {
    return attribute;
  }

ElementAttributeInner
  = key:Name '=' value:AttributeValue {
    return new MarkupAttributeExpression(key, value, location());
  }
  / key:Name {
    return new MarkupAttributeExpression(key, "", location());
  }

AttributeValue
  = String

String
  = '"' characters:DoubleStringCharacter* '"' { return characters.join(''); }
  / "'" characters:SingleStringCharacter* "'" { return characters.join(''); }

DoubleStringCharacter
  = !('"' / "\\") . { return text(); }
  / '\\"'

SingleStringCharacter
  = !("'" / "\\") . { return text(); }
  / "\\'"

TextNode
  = [^<]+ {
    return new MarkupTextExpression(text(), location());
  }

Name
  = [a-zA-Z0-9$-.]+ { return text(); }
_
  = [ \n\r\t]*
