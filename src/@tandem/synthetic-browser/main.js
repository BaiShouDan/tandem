/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	__webpack_require__(1);
	const electron_1 = __webpack_require__(2);
	const cluster_1 = __webpack_require__(3);
	const master_1 = __webpack_require__(4);
	const worker_1 = __webpack_require__(339);
	process.on("unhandledRejection", function (error) {
	    console.error(`(${cluster_1.isMaster ? "master" : "worker"}) Unhandled Rejection ${error.stack}`);
	});
	process.on("uncaughtException", function (error) {
	    console.error(`(${cluster_1.isMaster ? "master" : "worker"}) Uncaught Exception ${error.stack}`);
	});
	if (cluster_1.isMaster && electron_1.app) {
	    electron_1.app.once("ready", master_1.initializeMaster);
	}
	else {
	    worker_1.initializeWorker();
	}


/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = require("reflect-metadata");

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = require("electron");

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = require("cluster");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const yargs_1 = __webpack_require__(5);
	const path = __webpack_require__(6);
	const getPort = __webpack_require__(7);
	const common_1 = __webpack_require__(8);
	const core_1 = __webpack_require__(165);
	const constants_1 = __webpack_require__(295);
	const common_2 = __webpack_require__(8);
	const commands_1 = __webpack_require__(296);
	const services_1 = __webpack_require__(325);
	const starters_1 = __webpack_require__(332);
	const providers_1 = __webpack_require__(299);
	const common_3 = __webpack_require__(303);
	const stores_1 = __webpack_require__(337);
	const common_4 = __webpack_require__(46);
	process.env.LOG_LEVEL = process.env.LOG_LEVEL || common_4.LogLevel[String(yargs_1.argv.logLevel).toUpperCase()] || (yargs_1.argv.verbose ? common_4.LogLevel.VERBOSE : common_4.LogLevel.DEFAULT);
	const BROWSER_BASE_PATH = `${__dirname}/../browser`;
	exports.initializeMaster = () => __awaiter(this, void 0, void 0, function* () {
	    const config = {
	        projectFileExtensions: constants_1.TD_FILE_EXTENSIONS,
	        family: common_1.EditorFamilyType.MASTER,
	        settingsDirectory: process.env.HOME + "/.tandem",
	        cacheDirectory: process.env.HOME + "/.tandem/cache",
	        tmpDirectory: process.env.HOME + "/.tandem/tmp",
	        help: {
	            directory: path.normalize(__dirname + "/../../help")
	        },
	        browser: {
	            assetUrl: `file://${BROWSER_BASE_PATH}/path`,
	            indexUrl: `file://${BROWSER_BASE_PATH}/index.html`
	        },
	        cwd: process.cwd(),
	        argv: yargs_1.argv,
	        log: {
	            level: Number(process.env.LOG_LEVEL)
	        },
	        experimental: yargs_1.argv.experimental ? (process.env.EXPERIMENTAL = true) : null,
	        port: process.env.PORT || (process.env.PORT = yield getPort()),
	        hostname: process.env.HOSTNAME || (process.env.HOSTNAME = "localhost")
	    };
	    const injector = new common_4.Injector(common_2.createCommonEditorProviders(config), 
	    // services
	    new core_1.ApplicationServiceProvider("browser", services_1.BrowserService), 
	    // commands
	    new common_4.CommandFactoryProvider(common_3.PingRequest.PING, commands_1.HandlePingCommand), new common_4.CommandFactoryProvider(common_4.LoadApplicationRequest.LOAD, commands_1.InitSettingsDirectoryCommand), new common_4.CommandFactoryProvider(common_4.LoadApplicationRequest.LOAD, commands_1.InitSettingsCommand), new common_4.CommandFactoryProvider(common_3.GetHelpOptionsRequest.GET_HELP_OPTIONS, commands_1.GetHelpOptionsCommand), new common_4.CommandFactoryProvider(common_3.OpenHelpOptionRequest.OPEN_HELP_OPTION, commands_1.OpenHelpOptionCommand), new common_4.CommandFactoryProvider(common_4.LoadApplicationRequest.LOAD, commands_1.SpawnWorkerCommand), new common_4.CommandFactoryProvider(common_3.OpenFileRequest.OPEN_FILE, commands_1.OpenTextFileCommand), new common_4.CommandFactoryProvider(common_3.OpenNewWorkspaceRequest.OPEN_NEW_WORKSPACE, commands_1.OpenNewWorkspaceCommand), new common_4.CommandFactoryProvider(common_3.SelectDirectoryRequest.SELECT_DIRECTORY_REQUEST, commands_1.SelectDirectoryCommand), new common_4.CommandFactoryProvider(common_4.ApplicationReadyMessage.READY, commands_1.CLIOpenWorkspaceCommand), new common_4.CommandFactoryProvider(common_3.GetProjectStartOptionsRequest.GET_PROJECT_STARTER_OPTIONS, commands_1.GetProjectStarterOptionsCommand), new common_4.CommandFactoryProvider(common_3.StartNewProjectRequest.START_NEW_PROJECT, commands_1.StartProjectCommand), new providers_1.TandemMasterStudioStoreProvider(stores_1.TandemStudioMasterStore), new providers_1.ProjectStarterFactoryProvider({
	        id: "blank",
	        label: "Blank",
	        image: "assets/html5-logo.png",
	        enabled: true
	    }, starters_1.BlankProjectStarter), 
	    // starters
	    new providers_1.ProjectStarterFactoryProvider({
	        id: "html",
	        label: "Responsive",
	        image: "assets/html5-logo.png",
	        enabled: true
	    }, starters_1.ResponsiveProjectStarter), new providers_1.ProjectStarterFactoryProvider({
	        id: "react+webpack",
	        label: "React + Webpack",
	        image: "assets/react-logo.png",
	        enabled: false
	    }, function () { }), new providers_1.ProjectStarterFactoryProvider({
	        id: "angular2",
	        label: "Angular2",
	        image: "assets/angular-logo.png",
	        enabled: false
	    }, function () { }), new providers_1.ProjectStarterFactoryProvider({
	        id: "ember",
	        label: "Ember",
	        image: "assets/ember-logo.png",
	        enabled: false
	    }, function () { }), new providers_1.ProjectStarterFactoryProvider({
	        id: "jekyll",
	        label: "Jekyll",
	        image: "assets/jekyll-logo.png",
	        enabled: false
	    }, function () { }));
	    const app = new core_1.ServiceApplication(injector);
	    yield app.initialize();
	});

	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = require("yargs");

/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = require("path");

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = require("get-port");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const services_1 = __webpack_require__(9);
	const core_1 = __webpack_require__(165);
	exports.createCommonEditorProviders = (config, fileSystemClass, fileResolverClass) => {
	    return [
	        core_1.createCoreApplicationProviders(config),
	        new core_1.ApplicationServiceProvider("console", services_1.ConsoleLogService),
	        new core_1.ApplicationServiceProvider("receiver", services_1.ReceiverService)
	    ];
	};
	__export(__webpack_require__(9));
	__export(__webpack_require__(212));
	__export(__webpack_require__(214));
	__export(__webpack_require__(215));
	// export external modules that contain requests & other
	// assets that will need to be wired up by some backend
	__export(__webpack_require__(216));
	__export(__webpack_require__(167));


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(10));
	__export(__webpack_require__(208));
	__export(__webpack_require__(211));
	// export * from "./sock";
	// export * from "./resolver"; 


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const serialize_1 = __webpack_require__(11);
	const mesh_1 = __webpack_require__(13);
	const common_1 = __webpack_require__(46);
	const core_1 = __webpack_require__(165);
	let IOService = class IOService extends core_1.CoreApplicationService {
	    constructor() {
	        super(...arguments);
	        /**
	         */
	        this.addConnection = (connection) => __awaiter(this, void 0, void 0, function* () {
	            this.logger.info("Client connected");
	            // setup the bus which wil facilitate in all
	            // transactions between the remote service
	            const remoteBus = new mesh_1.SocketIOBus({ family: this.config.family, connection, testMessage: mesh_1.filterFamilyMessage }, {
	                dispatch: (message) => {
	                    // attach a flag so that the action does not get dispatched again
	                    return this.bus.dispatch(Object.assign(message, { $$remote: true }));
	                }
	            }, { serialize: serialize_1.serialize, deserialize: serialize_1.deserialize });
	            this.bus.register(remoteBus);
	            connection.once("disconnect", () => {
	                this.logger.info("Client disconnected");
	                this.bus.unregister(remoteBus);
	                remoteBus.dispose();
	            });
	        });
	    }
	    /**
	     */
	    ping() {
	        return "pong";
	    }
	};
	IOService = __decorate([
	    common_1.loggable()
	], IOService);
	exports.IOService = IOService;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(12));


/***/ },
/* 12 */
/***/ function(module, exports) {

	"use strict";
	function createSerializer(ctor) {
	    if (ctor.prototype.serialize) {
	        return {
	            serialize(value) {
	                return value.serialize();
	            },
	            deserialize(value, injector, ctor) {
	                const instance = injector && injector.create(ctor, []) || new ctor();
	                instance.deserialize(value);
	                return instance;
	            }
	        };
	    }
	    return {
	        serialize(value) {
	            return JSON.parse(JSON.stringify(value));
	        },
	        deserialize(value, injector, ctor) {
	            const instance = new ctor();
	            return Object.assign(instance, value);
	        }
	    };
	}
	exports.createSerializer = createSerializer;
	const defaultSerializer = {
	    serialize(value) {
	        return value.serialize ? value.serialize() : JSON.parse(JSON.stringify(value));
	    },
	    deserialize(value, injector, ctor) {
	        const instance = injector && injector.create(ctor, []) || new ctor();
	        return instance.deserialize ? instance.deserialize(value) : Object.assign(instance, value);
	    }
	};
	const LITERAL_TYPE = "[[Literal]]";
	class LiteralSerializer {
	    serialize(value) {
	        return value;
	    }
	    deserialize(value, ctor, injector) {
	        return value;
	    }
	}
	const _serializers = {
	    [LITERAL_TYPE]: { ctor: undefined, serializer: new LiteralSerializer() },
	    Array: {
	        ctor: undefined,
	        serializer: {
	            serialize(value) {
	                // cast value as an array if it's not (might be a sub class)
	                return ([].concat(value)).map(serialize);
	            },
	            deserialize(value, injector) {
	                return value.map(item => deserialize(item, injector));
	            }
	        }
	    },
	    Date: {
	        ctor: undefined,
	        serializer: {
	            serialize(value) {
	                return Date.now();
	            },
	            deserialize(value) {
	                return new Date(value);
	            }
	        }
	    },
	    RegExp: {
	        ctor: undefined,
	        serializer: {
	            serialize(value) {
	                return { source: value.source, flags: value.flags };
	            },
	            deserialize({ source, flags }) {
	                return new RegExp(source, flags);
	            }
	        }
	    },
	    Error: {
	        ctor: undefined,
	        serializer: {
	            serialize(value) {
	                return { name: value.name, message: value.message, stack: value.stack };
	            },
	            deserialize({ name, message, stack }) {
	                return { name, message, stack };
	            }
	        }
	    },
	};
	function getSerializeType(value) {
	    return isSerializable(value) ? Reflect.getMetadata("serialize:type", value.constructor) || Reflect.getMetadata("serialize:type", value) : getNativeSerializeType(value);
	}
	exports.getSerializeType = getSerializeType;
	function getNativeSerializeType(value) {
	    // need to use instanceof since the value may be a sub class
	    if (value instanceof Array)
	        return "Array";
	    if (value instanceof Date)
	        return "Date";
	    if (value instanceof RegExp)
	        return "RegExp";
	    if (value instanceof Error)
	        return "Error";
	    return undefined;
	}
	function serializable(serializer, type) {
	    return function (ctor) {
	        if (!type)
	            type = ctor.name;
	        if (_serializers[type])
	            throw new Error(`Cannot override existing serializer "${type}".`);
	        // if serializer does not exist, then fetch from parent class serializer if it exists
	        const parentSerializerInfo = _serializers[Reflect.getMetadata(`serialize:type`, ctor)];
	        _serializers[type] = {
	            ctor: ctor,
	            serializer: serializer || (parentSerializerInfo ? parentSerializerInfo.serializer : createSerializer(ctor))
	        };
	        Reflect.defineMetadata("serialize:type", type, ctor);
	    };
	}
	exports.serializable = serializable;
	function isSerializable(value) {
	    return !!value && (typeof value === "function" ? !!Reflect.getMetadata("serialize:type", value) : !!Reflect.getMetadata("serialize:type", value.constructor));
	}
	exports.isSerializable = isSerializable;
	function serialize(value) {
	    const type = getSerializeType(value) || LITERAL_TYPE;
	    return [type, _serializers[type].serializer.serialize(value)];
	}
	exports.serialize = serialize;
	function deserialize(content, injector) {
	    const info = _serializers[content[0]];
	    if (!info) {
	        throw new Error(`Trying to deserialize non serialized object:` + content);
	    }
	    return info.serializer.deserialize(content[1], injector, info.ctor);
	}
	exports.deserialize = deserialize;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(14));
	__export(__webpack_require__(39));
	__export(__webpack_require__(41));


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(15));
	__export(__webpack_require__(17));
	__export(__webpack_require__(22));
	__export(__webpack_require__(36));


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(16));


/***/ },
/* 16 */
/***/ function(module, exports) {

	"use strict";
	exports.sequenceIterator = (items, each) => {
	    return new Promise((resolve, reject) => {
	        const next = (index) => {
	            if (index === items.length)
	                return resolve();
	            each(items[index]).then(next.bind(this, index + 1)).catch(reject);
	        };
	        next(0);
	    });
	};
	exports.parallelIterator = (items, each) => {
	    return Promise.all(items.map(each));
	};
	exports.createRoundRobinIterator = () => {
	    let current = 0;
	    return (items, each) => {
	        let prev = current;
	        current = (current + 1) & items.length;
	        return each(items[prev]);
	    };
	};
	// TODO when needed
	exports.createRandomIterator = (weights) => {
	    return (items, each) => {
	        return each(items[Math.floor(Math.random() * items.length)]);
	    };
	};


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(18));
	__export(__webpack_require__(19));
	__export(__webpack_require__(20));
	__export(__webpack_require__(21));
	__export(__webpack_require__(33));
	__export(__webpack_require__(35));
	__export(__webpack_require__(34));


/***/ },
/* 18 */
/***/ function(module, exports) {

	"use strict";
	exports.testDispatcherMessage = (target, message) => {
	    return !!(target && target.testMessage && target.testMessage(message));
	};


/***/ },
/* 19 */
/***/ function(module, exports) {

	"use strict";
	class NoopDispatcher {
	    dispatch(message) { }
	}
	exports.NoopDispatcher = NoopDispatcher;
	exports.noopDispatcherInstance = new NoopDispatcher();


/***/ },
/* 20 */
/***/ function(module, exports) {

	"use strict";
	class CallbackDispatcher {
	    constructor(callback) {
	        this.callback = callback;
	    }
	    dispatch(message) {
	        return this.callback(message);
	    }
	}
	exports.CallbackDispatcher = CallbackDispatcher;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const streams_1 = __webpack_require__(22);
	const utils_1 = __webpack_require__(15);
	class FanoutBus {
	    constructor(_dispatchers, _iterator) {
	        this._dispatchers = _dispatchers;
	        this._iterator = _iterator;
	        this.getDispatchers = typeof _dispatchers === "function" ? _dispatchers : () => _dispatchers;
	    }
	    dispatch(message) {
	        return new streams_1.DuplexStream((input, output) => {
	            const writer = output.getWriter();
	            let spare = input, child;
	            let pending = 0;
	            this._iterator(this.getDispatchers(message), (dispatcher) => {
	                let response = dispatcher.dispatch(message);
	                if (response == null) {
	                    return Promise.resolve();
	                }
	                [spare, child] = spare.tee();
	                response = streams_1.wrapDuplexStream(response);
	                pending++;
	                return child
	                    .pipeThrough(response)
	                    .pipeTo(new streams_1.WritableStream({
	                    write(chunk) {
	                        return writer.write(chunk);
	                    },
	                    close: () => pending--,
	                    abort: () => pending--
	                }));
	            })
	                .then(writer.close.bind(writer))
	                .catch(writer.abort.bind(writer))
	                .catch((e) => { });
	        });
	    }
	}
	exports.FanoutBus = FanoutBus;
	class SequenceBus extends FanoutBus {
	    constructor(dispatchers) {
	        super(dispatchers, utils_1.sequenceIterator);
	    }
	}
	exports.SequenceBus = SequenceBus;
	class ParallelBus extends FanoutBus {
	    constructor(dispatchers) {
	        super(dispatchers, utils_1.parallelIterator);
	    }
	}
	exports.ParallelBus = ParallelBus;
	class RoundRobinBus extends FanoutBus {
	    constructor(dispatchers) {
	        super(dispatchers, utils_1.createRoundRobinIterator());
	    }
	}
	exports.RoundRobinBus = RoundRobinBus;
	class RandomBus extends FanoutBus {
	    constructor(dispatchers, weights) {
	        super(dispatchers, utils_1.createRandomIterator(weights));
	    }
	}
	exports.RandomBus = RandomBus;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	// export * from "./readable-stream";
	// export * from "./reader";
	__export(__webpack_require__(23));
	__export(__webpack_require__(31));
	__export(__webpack_require__(32));


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	module.exports.ReadableStream = __webpack_require__(24).ReadableStream;
	module.exports.TransformStream = __webpack_require__(30).TransformStream;
	module.exports.WritableStream = __webpack_require__(29).WritableStream;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const assert = __webpack_require__(25);
	const { ArrayBufferCopy, CreateIterResultObject, IsFiniteNonNegativeNumber, InvokeOrNoop, PromiseInvokeOrNoop,
	        SameRealmTransfer, ValidateAndNormalizeQueuingStrategy, ValidateAndNormalizeHighWaterMark } =
	      __webpack_require__(26);
	const { createArrayFromList, createDataProperty, typeIsObject } = __webpack_require__(26);
	const { rethrowAssertionErrorRejection } = __webpack_require__(27);
	const { DequeueValue, EnqueueValueWithSize, GetTotalQueueSize } = __webpack_require__(28);
	const { AcquireWritableStreamDefaultWriter, IsWritableStream, IsWritableStreamLocked,
	        WritableStreamAbort, WritableStreamDefaultWriterCloseWithErrorPropagation,
	        WritableStreamDefaultWriterRelease, WritableStreamDefaultWriterWrite } = __webpack_require__(29);

	const InternalCancel = Symbol('[[Cancel]]');
	const InternalPull = Symbol('[[Pull]]');

	class ReadableStream {
	  constructor(underlyingSource = {}, { size, highWaterMark } = {}) {
	    // Exposed to controllers.
	    this._state = 'readable';

	    this._reader = undefined;
	    this._storedError = undefined;

	    this._disturbed = false;

	    // Initialize to undefined first because the constructor of the controller checks this
	    // variable to validate the caller.
	    this._readableStreamController = undefined;
	    const type = underlyingSource.type;
	    const typeString = String(type);
	    if (typeString === 'bytes') {
	      if (highWaterMark === undefined) {
	        highWaterMark = 0;
	      }
	      this._readableStreamController = new ReadableByteStreamController(this, underlyingSource, highWaterMark);
	    } else if (type === undefined) {
	      if (highWaterMark === undefined) {
	        highWaterMark = 1;
	      }
	      this._readableStreamController = new ReadableStreamDefaultController(this, underlyingSource, size, highWaterMark);
	    } else {
	      throw new RangeError('Invalid type is specified');
	    }
	  }

	  get locked() {
	    if (IsReadableStream(this) === false) {
	      throw streamBrandCheckException('locked');
	    }

	    return IsReadableStreamLocked(this);
	  }

	  cancel(reason) {
	    if (IsReadableStream(this) === false) {
	      return Promise.reject(streamBrandCheckException('cancel'));
	    }

	    if (IsReadableStreamLocked(this) === true) {
	      return Promise.reject(new TypeError('Cannot cancel a stream that already has a reader'));
	    }

	    return ReadableStreamCancel(this, reason);
	  }

	  getReader({ mode } = {}) {
	    if (IsReadableStream(this) === false) {
	      throw streamBrandCheckException('getReader');
	    }

	    if (mode === 'byob') {
	      if (IsReadableByteStreamController(this._readableStreamController) === false) {
	        throw new TypeError('Cannot get a ReadableStreamBYOBReader for a stream not constructed with a byte source');
	      }

	      return AcquireReadableStreamBYOBReader(this);
	    }

	    if (mode === undefined) {
	      return AcquireReadableStreamDefaultReader(this);
	    }

	    throw new RangeError('Invalid mode is specified');
	  }

	  pipeThrough({ writable, readable }, options) {
	    this.pipeTo(writable, options);
	    return readable;
	  }

	  pipeTo(dest, { preventClose, preventAbort, preventCancel } = {}) {
	    if (IsReadableStream(this) === false) {
	      return Promise.reject(streamBrandCheckException('pipeTo'));
	    }
	    if (IsWritableStream(dest) === false) {
	      return Promise.reject(
	        new TypeError('ReadableStream.prototype.pipeTo\'s first argument must be a WritableStream'));
	    }

	    preventClose = Boolean(preventClose);
	    preventAbort = Boolean(preventAbort);
	    preventCancel = Boolean(preventCancel);

	    if (IsReadableStreamLocked(this) === true) {
	      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
	    }
	    if (IsWritableStreamLocked(dest) === true) {
	      return Promise.reject(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
	    }

	    const reader = AcquireReadableStreamDefaultReader(this);
	    const writer = AcquireWritableStreamDefaultWriter(dest);

	    let shuttingDown = false;

	    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.
	    let currentWrite = Promise.resolve();

	    return new Promise((resolve, reject) => {
	      // Using reader and writer, read all chunks from this and write them to dest
	      // - Backpressure must be enforced
	      // - Shutdown must stop all activity
	      function pipeLoop() {
	        currentWrite = Promise.resolve();

	        if (shuttingDown === true) {
	          return Promise.resolve();
	        }

	        return writer._readyPromise.then(() => {
	          return ReadableStreamDefaultReaderRead(reader).then(({ value, done }) => {
	            if (done === true) {
	              return undefined;
	            }

	            currentWrite = WritableStreamDefaultWriterWrite(writer, value);
	            return currentWrite;
	          });
	        })
	        .then(pipeLoop);
	      }

	      // Errors must be propagated forward
	      isOrBecomesErrored(this, reader._closedPromise, storedError => {
	        if (preventAbort === false) {
	          shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
	        } else {
	          shutdown(true, storedError);
	        }
	      });

	      // Errors must be propagated backward
	      isOrBecomesErrored(dest, writer._closedPromise, storedError => {
	        if (preventCancel === false) {
	          shutdownWithAction(() => ReadableStreamCancel(this, storedError), true, storedError);
	        } else {
	          shutdown(true, storedError);
	        }
	      });

	      // Closing must be propagated forward
	      isOrBecomesClosed(this, reader._closedPromise, () => {
	        if (preventClose === false) {
	          shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
	        } else {
	          shutdown();
	        }
	      });

	      // Closing must be propagated backward
	      if (dest._state === 'closing' || dest._state === 'closed') {
	        const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');

	        if (preventCancel === false) {
	          shutdownWithAction(() => ReadableStreamCancel(this, destClosed), true, destClosed);
	        } else {
	          shutdown(true, destClosed);
	        }
	      }

	      pipeLoop().catch(err => {
	        currentWrite = Promise.resolve();
	        rethrowAssertionErrorRejection(err);
	      });

	      function isOrBecomesErrored(stream, promise, action) {
	        if (stream._state === 'errored') {
	          action(stream._storedError);
	        } else {
	          promise.catch(action).catch(rethrowAssertionErrorRejection);
	        }
	      }

	      function isOrBecomesClosed(stream, promise, action) {
	        if (stream._state === 'closed') {
	          action();
	        } else {
	          promise.then(action).catch(rethrowAssertionErrorRejection);
	        }
	      }

	      function waitForCurrentWrite() {
	        return currentWrite.catch(() => {});
	      }

	      function shutdownWithAction(action, originalIsError, originalError) {
	        if (shuttingDown === true) {
	          return;
	        }
	        shuttingDown = true;

	        waitForCurrentWrite().then(() => {
	          return action().then(
	            () => finalize(originalIsError, originalError),
	            newError => finalize(true, newError)
	          );
	        })
	        .catch(rethrowAssertionErrorRejection);
	      }

	      function shutdown(isError, error) {
	        if (shuttingDown === true) {
	          return;
	        }
	        shuttingDown = true;

	        waitForCurrentWrite().then(() => {
	          finalize(isError, error);
	        })
	        .catch(rethrowAssertionErrorRejection);
	      }

	      function finalize(isError, error) {
	        WritableStreamDefaultWriterRelease(writer);
	        ReadableStreamReaderGenericRelease(reader);

	        if (isError) {
	          reject(error);
	        } else {
	          resolve(undefined);
	        }
	      }
	    });
	  }

	  tee() {
	    if (IsReadableStream(this) === false) {
	      throw streamBrandCheckException('tee');
	    }

	    const branches = ReadableStreamTee(this, false);
	    return createArrayFromList(branches);
	  }
	}

	module.exports = {
	  ReadableStream,
	  IsReadableStreamDisturbed,
	  ReadableStreamDefaultControllerClose,
	  ReadableStreamDefaultControllerEnqueue,
	  ReadableStreamDefaultControllerError,
	  ReadableStreamDefaultControllerGetDesiredSize
	};

	// Abstract operations for the ReadableStream.

	function AcquireReadableStreamBYOBReader(stream) {
	  return new ReadableStreamBYOBReader(stream);
	}

	function AcquireReadableStreamDefaultReader(stream) {
	  return new ReadableStreamDefaultReader(stream);
	}

	function IsReadableStream(x) {
	  if (!typeIsObject(x)) {
	    return false;
	  }

	  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
	    return false;
	  }

	  return true;
	}

	function IsReadableStreamDisturbed(stream) {
	  assert(IsReadableStream(stream) === true, 'IsReadableStreamDisturbed should only be used on known readable streams');

	  return stream._disturbed;
	}

	function IsReadableStreamLocked(stream) {
	  assert(IsReadableStream(stream) === true, 'IsReadableStreamLocked should only be used on known readable streams');

	  if (stream._reader === undefined) {
	    return false;
	  }

	  return true;
	}

	function ReadableStreamTee(stream, cloneForBranch2) {
	  assert(IsReadableStream(stream) === true);
	  assert(typeof cloneForBranch2 === 'boolean');

	  const reader = AcquireReadableStreamDefaultReader(stream);

	  const teeState = {
	    closedOrErrored: false,
	    canceled1: false,
	    canceled2: false,
	    reason1: undefined,
	    reason2: undefined
	  };
	  teeState.promise = new Promise(resolve => {
	    teeState._resolve = resolve;
	  });

	  const pull = create_ReadableStreamTeePullFunction();
	  pull._reader = reader;
	  pull._teeState = teeState;
	  pull._cloneForBranch2 = cloneForBranch2;

	  const cancel1 = create_ReadableStreamTeeBranch1CancelFunction();
	  cancel1._stream = stream;
	  cancel1._teeState = teeState;

	  const cancel2 = create_ReadableStreamTeeBranch2CancelFunction();
	  cancel2._stream = stream;
	  cancel2._teeState = teeState;

	  const underlyingSource1 = Object.create(Object.prototype);
	  createDataProperty(underlyingSource1, 'pull', pull);
	  createDataProperty(underlyingSource1, 'cancel', cancel1);
	  const branch1Stream = new ReadableStream(underlyingSource1);

	  const underlyingSource2 = Object.create(Object.prototype);
	  createDataProperty(underlyingSource2, 'pull', pull);
	  createDataProperty(underlyingSource2, 'cancel', cancel2);
	  const branch2Stream = new ReadableStream(underlyingSource2);

	  pull._branch1 = branch1Stream._readableStreamController;
	  pull._branch2 = branch2Stream._readableStreamController;

	  reader._closedPromise.catch(r => {
	    if (teeState.closedOrErrored === true) {
	      return;
	    }

	    ReadableStreamDefaultControllerError(pull._branch1, r);
	    ReadableStreamDefaultControllerError(pull._branch2, r);
	    teeState.closedOrErrored = true;
	  });

	  return [branch1Stream, branch2Stream];
	}

	function create_ReadableStreamTeePullFunction() {
	  function f() {
	    const { _reader: reader, _branch1: branch1, _branch2: branch2, _teeState: teeState/* ,
	            _cloneForBranch2: cloneForBranch2*/ } = f;

	    return ReadableStreamDefaultReaderRead(reader).then(result => {
	      assert(typeIsObject(result));
	      const value = result.value;
	      const done = result.done;
	      assert(typeof done === 'boolean');

	      if (done === true && teeState.closedOrErrored === false) {
	        if (teeState.canceled1 === false) {
	          ReadableStreamDefaultControllerClose(branch1);
	        }
	        if (teeState.canceled2 === false) {
	          ReadableStreamDefaultControllerClose(branch2);
	        }
	        teeState.closedOrErrored = true;
	      }

	      if (teeState.closedOrErrored === true) {
	        return;
	      }

	      const value1 = value;
	      const value2 = value;

	      // There is no way to access the cloning code right now in the reference implementation.
	      // If we add one then we'll need an implementation for StructuredClone.
	      // if (teeState.canceled2 === false && cloneForBranch2 === true) {
	      //   value2 = StructuredClone(value2);
	      // }

	      if (teeState.canceled1 === false) {
	        ReadableStreamDefaultControllerEnqueue(branch1, value1);
	      }

	      if (teeState.canceled2 === false) {
	        ReadableStreamDefaultControllerEnqueue(branch2, value2);
	      }
	    });
	  }
	  return f;
	}

	function create_ReadableStreamTeeBranch1CancelFunction() {
	  function f(reason) {
	    const { _stream: stream, _teeState: teeState } = f;

	    teeState.canceled1 = true;
	    teeState.reason1 = reason;
	    if (teeState.canceled2 === true) {
	      const compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);
	      const cancelResult = ReadableStreamCancel(stream, compositeReason);
	      teeState._resolve(cancelResult);
	    }
	    return teeState.promise;
	  }
	  return f;
	}

	function create_ReadableStreamTeeBranch2CancelFunction() {
	  function f(reason) {
	    const { _stream: stream, _teeState: teeState } = f;

	    teeState.canceled2 = true;
	    teeState.reason2 = reason;
	    if (teeState.canceled1 === true) {
	      const compositeReason = createArrayFromList([teeState.reason1, teeState.reason2]);
	      const cancelResult = ReadableStreamCancel(stream, compositeReason);
	      teeState._resolve(cancelResult);
	    }
	    return teeState.promise;
	  }
	  return f;
	}

	// ReadableStream API exposed for controllers.

	function ReadableStreamAddReadIntoRequest(stream) {
	  assert(IsReadableStreamBYOBReader(stream._reader) === true);
	  assert(stream._state === 'readable' || stream._state === 'closed');

	  const promise = new Promise((resolve, reject) => {
	    const readIntoRequest = {
	      _resolve: resolve,
	      _reject: reject
	    };

	    stream._reader._readIntoRequests.push(readIntoRequest);
	  });

	  return promise;
	}

	function ReadableStreamAddReadRequest(stream) {
	  assert(IsReadableStreamDefaultReader(stream._reader) === true);
	  assert(stream._state === 'readable');

	  const promise = new Promise((resolve, reject) => {
	    const readRequest = {
	      _resolve: resolve,
	      _reject: reject
	    };

	    stream._reader._readRequests.push(readRequest);
	  });

	  return promise;
	}

	function ReadableStreamCancel(stream, reason) {
	  stream._disturbed = true;

	  if (stream._state === 'closed') {
	    return Promise.resolve(undefined);
	  }
	  if (stream._state === 'errored') {
	    return Promise.reject(stream._storedError);
	  }

	  ReadableStreamClose(stream);

	  const sourceCancelPromise = stream._readableStreamController[InternalCancel](reason);
	  return sourceCancelPromise.then(() => undefined);
	}

	function ReadableStreamClose(stream) {
	  assert(stream._state === 'readable');

	  stream._state = 'closed';

	  const reader = stream._reader;

	  if (reader === undefined) {
	    return undefined;
	  }

	  if (IsReadableStreamDefaultReader(reader) === true) {
	    for (const { _resolve } of reader._readRequests) {
	      _resolve(CreateIterResultObject(undefined, true));
	    }
	    reader._readRequests = [];
	  }

	  defaultReaderClosedPromiseResolve(reader);

	  return undefined;
	}

	function ReadableStreamError(stream, e) {
	  assert(IsReadableStream(stream) === true, 'stream must be ReadableStream');
	  assert(stream._state === 'readable', 'state must be readable');

	  stream._state = 'errored';
	  stream._storedError = e;

	  const reader = stream._reader;

	  if (reader === undefined) {
	    return undefined;
	  }

	  if (IsReadableStreamDefaultReader(reader) === true) {
	    for (const readRequest of reader._readRequests) {
	      readRequest._reject(e);
	    }

	    reader._readRequests = [];
	  } else {
	    assert(IsReadableStreamBYOBReader(reader), 'reader must be ReadableStreamBYOBReader');

	    for (const readIntoRequest of reader._readIntoRequests) {
	      readIntoRequest._reject(e);
	    }

	    reader._readIntoRequests = [];
	  }

	  defaultReaderClosedPromiseReject(reader, e);
	  reader._closedPromise.catch(() => {});
	}

	function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
	  const reader = stream._reader;

	  assert(reader._readIntoRequests.length > 0);

	  const readIntoRequest = reader._readIntoRequests.shift();
	  readIntoRequest._resolve(CreateIterResultObject(chunk, done));
	}

	function ReadableStreamFulfillReadRequest(stream, chunk, done) {
	  const reader = stream._reader;

	  assert(reader._readRequests.length > 0);

	  const readRequest = reader._readRequests.shift();
	  readRequest._resolve(CreateIterResultObject(chunk, done));
	}

	function ReadableStreamGetNumReadIntoRequests(stream) {
	  return stream._reader._readIntoRequests.length;
	}

	function ReadableStreamGetNumReadRequests(stream) {
	  return stream._reader._readRequests.length;
	}

	function ReadableStreamHasBYOBReader(stream) {
	  const reader = stream._reader;

	  if (reader === undefined) {
	    return false;
	  }

	  if (IsReadableStreamBYOBReader(reader) === false) {
	    return false;
	  }

	  return true;
	}

	function ReadableStreamHasDefaultReader(stream) {
	  const reader = stream._reader;

	  if (reader === undefined) {
	    return false;
	  }

	  if (IsReadableStreamDefaultReader(reader) === false) {
	    return false;
	  }

	  return true;
	}

	// Readers

	class ReadableStreamDefaultReader {
	  constructor(stream) {
	    if (IsReadableStream(stream) === false) {
	      throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');
	    }
	    if (IsReadableStreamLocked(stream) === true) {
	      throw new TypeError('This stream has already been locked for exclusive reading by another reader');
	    }

	    ReadableStreamReaderGenericInitialize(this, stream);

	    this._readRequests = [];
	  }

	  get closed() {
	    if (IsReadableStreamDefaultReader(this) === false) {
	      return Promise.reject(defaultReaderBrandCheckException('closed'));
	    }

	    return this._closedPromise;
	  }

	  cancel(reason) {
	    if (IsReadableStreamDefaultReader(this) === false) {
	      return Promise.reject(defaultReaderBrandCheckException('cancel'));
	    }

	    if (this._ownerReadableStream === undefined) {
	      return Promise.reject(readerLockException('cancel'));
	    }

	    return ReadableStreamReaderGenericCancel(this, reason);
	  }

	  read() {
	    if (IsReadableStreamDefaultReader(this) === false) {
	      return Promise.reject(defaultReaderBrandCheckException('read'));
	    }

	    if (this._ownerReadableStream === undefined) {
	      return Promise.reject(readerLockException('read from'));
	    }

	    return ReadableStreamDefaultReaderRead(this);
	  }

	  releaseLock() {
	    if (IsReadableStreamDefaultReader(this) === false) {
	      throw defaultReaderBrandCheckException('releaseLock');
	    }

	    if (this._ownerReadableStream === undefined) {
	      return;
	    }

	    if (this._readRequests.length > 0) {
	      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
	    }

	    ReadableStreamReaderGenericRelease(this);
	  }
	}

	class ReadableStreamBYOBReader {
	  constructor(stream) {
	    if (!IsReadableStream(stream)) {
	      throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' +
	          'byte source');
	    }
	    if (IsReadableStreamLocked(stream)) {
	      throw new TypeError('This stream has already been locked for exclusive reading by another reader');
	    }

	    ReadableStreamReaderGenericInitialize(this, stream);

	    this._readIntoRequests = [];
	  }

	  get closed() {
	    if (!IsReadableStreamBYOBReader(this)) {
	      return Promise.reject(byobReaderBrandCheckException('closed'));
	    }

	    return this._closedPromise;
	  }

	  cancel(reason) {
	    if (!IsReadableStreamBYOBReader(this)) {
	      return Promise.reject(byobReaderBrandCheckException('cancel'));
	    }

	    if (this._ownerReadableStream === undefined) {
	      return Promise.reject(readerLockException('cancel'));
	    }

	    return ReadableStreamReaderGenericCancel(this, reason);
	  }

	  read(view) {
	    if (!IsReadableStreamBYOBReader(this)) {
	      return Promise.reject(byobReaderBrandCheckException('read'));
	    }

	    if (this._ownerReadableStream === undefined) {
	      return Promise.reject(readerLockException('read from'));
	    }

	    if (!ArrayBuffer.isView(view)) {
	      return Promise.reject(new TypeError('view must be an array buffer view'));
	    }

	    if (view.byteLength === 0) {
	      return Promise.reject(new TypeError('view must have non-zero byteLength'));
	    }

	    return ReadableStreamBYOBReaderRead(this, view);
	  }

	  releaseLock() {
	    if (!IsReadableStreamBYOBReader(this)) {
	      throw byobReaderBrandCheckException('releaseLock');
	    }

	    if (this._ownerReadableStream === undefined) {
	      return;
	    }

	    if (this._readIntoRequests.length > 0) {
	      throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
	    }

	    ReadableStreamReaderGenericRelease(this);
	  }
	}

	// Abstract operations for the readers.

	function IsReadableStreamBYOBReader(x) {
	  if (!typeIsObject(x)) {
	    return false;
	  }

	  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
	    return false;
	  }

	  return true;
	}

	function IsReadableStreamDefaultReader(x) {
	  if (!typeIsObject(x)) {
	    return false;
	  }

	  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
	    return false;
	  }

	  return true;
	}

	function ReadableStreamReaderGenericInitialize(reader, stream) {
	  reader._ownerReadableStream = stream;
	  stream._reader = reader;

	  if (stream._state === 'readable') {
	    defaultReaderClosedPromiseInitialize(reader);
	  } else if (stream._state === 'closed') {
	    defaultReaderClosedPromiseInitializeAsResolved(reader);
	  } else {
	    assert(stream._state === 'errored', 'state must be errored');

	    defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
	    reader._closedPromise.catch(() => {});
	  }
	}

	// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state
	// check.

	function ReadableStreamReaderGenericCancel(reader, reason) {
	  const stream = reader._ownerReadableStream;
	  assert(stream !== undefined);
	  return ReadableStreamCancel(stream, reason);
	}

	function ReadableStreamReaderGenericRelease(reader) {
	  assert(reader._ownerReadableStream !== undefined);
	  assert(reader._ownerReadableStream._reader === reader);

	  if (reader._ownerReadableStream._state === 'readable') {
	    defaultReaderClosedPromiseReject(
	        reader,
	        new TypeError('Reader was released and can no longer be used to monitor the stream\'s closedness'));
	  } else {
	    defaultReaderClosedPromiseResetToRejected(
	        reader,
	        new TypeError('Reader was released and can no longer be used to monitor the stream\'s closedness'));
	  }
	  reader._closedPromise.catch(() => {});

	  reader._ownerReadableStream._reader = undefined;
	  reader._ownerReadableStream = undefined;
	}

	function ReadableStreamBYOBReaderRead(reader, view) {
	  const stream = reader._ownerReadableStream;

	  assert(stream !== undefined);

	  stream._disturbed = true;

	  if (stream._state === 'errored') {
	    return Promise.reject(stream._storedError);
	  }

	  // Controllers must implement this.
	  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);
	}

	function ReadableStreamDefaultReaderRead(reader) {
	  const stream = reader._ownerReadableStream;

	  assert(stream !== undefined);

	  stream._disturbed = true;

	  if (stream._state === 'closed') {
	    return Promise.resolve(CreateIterResultObject(undefined, true));
	  }

	  if (stream._state === 'errored') {
	    return Promise.reject(stream._storedError);
	  }

	  assert(stream._state === 'readable');

	  return stream._readableStreamController[InternalPull]();
	}

	// Controllers

	class ReadableStreamDefaultController {
	  constructor(stream, underlyingSource, size, highWaterMark) {
	    if (IsReadableStream(stream) === false) {
	      throw new TypeError('ReadableStreamDefaultController can only be constructed with a ReadableStream instance');
	    }

	    if (stream._readableStreamController !== undefined) {
	      throw new TypeError(
	        'ReadableStreamDefaultController instances can only be created by the ReadableStream constructor');
	    }

	    this._controlledReadableStream = stream;

	    this._underlyingSource = underlyingSource;

	    this._queue = [];
	    this._started = false;
	    this._closeRequested = false;
	    this._pullAgain = false;
	    this._pulling = false;

	    const normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
	    this._strategySize = normalizedStrategy.size;
	    this._strategyHWM = normalizedStrategy.highWaterMark;

	    const controller = this;

	    const startResult = InvokeOrNoop(underlyingSource, 'start', [this]);
	    Promise.resolve(startResult).then(
	      () => {
	        controller._started = true;

	        assert(controller._pulling === false);
	        assert(controller._pullAgain === false);

	        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
	      },
	      r => {
	        ReadableStreamDefaultControllerErrorIfNeeded(controller, r);
	      }
	    )
	    .catch(rethrowAssertionErrorRejection);
	  }

	  get desiredSize() {
	    if (IsReadableStreamDefaultController(this) === false) {
	      throw defaultControllerBrandCheckException('desiredSize');
	    }

	    return ReadableStreamDefaultControllerGetDesiredSize(this);
	  }

	  close() {
	    if (IsReadableStreamDefaultController(this) === false) {
	      throw defaultControllerBrandCheckException('close');
	    }

	    if (this._closeRequested === true) {
	      throw new TypeError('The stream has already been closed; do not close it again!');
	    }

	    const state = this._controlledReadableStream._state;
	    if (state !== 'readable') {
	      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
	    }

	    ReadableStreamDefaultControllerClose(this);
	  }

	  enqueue(chunk) {
	    if (IsReadableStreamDefaultController(this) === false) {
	      throw defaultControllerBrandCheckException('enqueue');
	    }

	    if (this._closeRequested === true) {
	      throw new TypeError('stream is closed or draining');
	    }

	    const state = this._controlledReadableStream._state;
	    if (state !== 'readable') {
	      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
	    }

	    return ReadableStreamDefaultControllerEnqueue(this, chunk);
	  }

	  error(e) {
	    if (IsReadableStreamDefaultController(this) === false) {
	      throw defaultControllerBrandCheckException('error');
	    }

	    const stream = this._controlledReadableStream;
	    if (stream._state !== 'readable') {
	      throw new TypeError(`The stream is ${stream._state} and so cannot be errored`);
	    }

	    ReadableStreamDefaultControllerError(this, e);
	  }

	  [InternalCancel](reason) {
	    this._queue = [];

	    return PromiseInvokeOrNoop(this._underlyingSource, 'cancel', [reason]);
	  }

	  [InternalPull]() {
	    const stream = this._controlledReadableStream;

	    if (this._queue.length > 0) {
	      const chunk = DequeueValue(this._queue);

	      if (this._closeRequested === true && this._queue.length === 0) {
	        ReadableStreamClose(stream);
	      } else {
	        ReadableStreamDefaultControllerCallPullIfNeeded(this);
	      }

	      return Promise.resolve(CreateIterResultObject(chunk, false));
	    }

	    const pendingPromise = ReadableStreamAddReadRequest(stream);
	    ReadableStreamDefaultControllerCallPullIfNeeded(this);
	    return pendingPromise;
	  }
	}

	// Abstract operations for the ReadableStreamDefaultController.

	function IsReadableStreamDefaultController(x) {
	  if (!typeIsObject(x)) {
	    return false;
	  }

	  if (!Object.prototype.hasOwnProperty.call(x, '_underlyingSource')) {
	    return false;
	  }

	  return true;
	}

	function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
	  const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
	  if (shouldPull === false) {
	    return undefined;
	  }

	  if (controller._pulling === true) {
	    controller._pullAgain = true;
	    return undefined;
	  }

	  assert(controller._pullAgain === false);

	  controller._pulling = true;

	  const pullPromise = PromiseInvokeOrNoop(controller._underlyingSource, 'pull', [controller]);
	  pullPromise.then(
	    () => {
	      controller._pulling = false;

	      if (controller._pullAgain === true) {
	        controller._pullAgain = false;
	        return ReadableStreamDefaultControllerCallPullIfNeeded(controller);
	      }
	      return undefined;
	    },
	    e => {
	      ReadableStreamDefaultControllerErrorIfNeeded(controller, e);
	    }
	  )
	  .catch(rethrowAssertionErrorRejection);

	  return undefined;
	}

	function ReadableStreamDefaultControllerShouldCallPull(controller) {
	  const stream = controller._controlledReadableStream;

	  if (stream._state === 'closed' || stream._state === 'errored') {
	    return false;
	  }

	  if (controller._closeRequested === true) {
	    return false;
	  }

	  if (controller._started === false) {
	    return false;
	  }

	  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
	    return true;
	  }

	  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
	  if (desiredSize > 0) {
	    return true;
	  }

	  return false;
	}

	// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.

	function ReadableStreamDefaultControllerClose(controller) {
	  const stream = controller._controlledReadableStream;

	  assert(controller._closeRequested === false);
	  assert(stream._state === 'readable');

	  controller._closeRequested = true;

	  if (controller._queue.length === 0) {
	    ReadableStreamClose(stream);
	  }
	}

	function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
	  const stream = controller._controlledReadableStream;

	  assert(controller._closeRequested === false);
	  assert(stream._state === 'readable');

	  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {
	    ReadableStreamFulfillReadRequest(stream, chunk, false);
	  } else {
	    let chunkSize = 1;

	    if (controller._strategySize !== undefined) {
	      try {
	        chunkSize = controller._strategySize(chunk);
	      } catch (chunkSizeE) {
	        ReadableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
	        throw chunkSizeE;
	      }
	    }

	    try {
	      EnqueueValueWithSize(controller._queue, chunk, chunkSize);
	    } catch (enqueueE) {
	      ReadableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
	      throw enqueueE;
	    }
	  }

	  ReadableStreamDefaultControllerCallPullIfNeeded(controller);

	  return undefined;
	}

	function ReadableStreamDefaultControllerError(controller, e) {
	  const stream = controller._controlledReadableStream;

	  assert(stream._state === 'readable');

	  controller._queue = [];

	  ReadableStreamError(stream, e);
	}

	function ReadableStreamDefaultControllerErrorIfNeeded(controller, e) {
	  if (controller._controlledReadableStream._state === 'readable') {
	    ReadableStreamDefaultControllerError(controller, e);
	  }
	}

	function ReadableStreamDefaultControllerGetDesiredSize(controller) {
	  const queueSize = GetTotalQueueSize(controller._queue);
	  return controller._strategyHWM - queueSize;
	}

	class ReadableStreamBYOBRequest {
	  constructor(controller, view) {
	    this._associatedReadableByteStreamController = controller;
	    this._view = view;
	  }

	  get view() {
	    return this._view;
	  }

	  respond(bytesWritten) {
	    if (IsReadableStreamBYOBRequest(this) === false) {
	      throw byobRequestBrandCheckException('respond');
	    }

	    if (this._associatedReadableByteStreamController === undefined) {
	      throw new TypeError('This BYOB request has been invalidated');
	    }

	    ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
	  }

	  respondWithNewView(view) {
	    if (IsReadableStreamBYOBRequest(this) === false) {
	      throw byobRequestBrandCheckException('respond');
	    }

	    if (this._associatedReadableByteStreamController === undefined) {
	      throw new TypeError('This BYOB request has been invalidated');
	    }

	    if (!ArrayBuffer.isView(view)) {
	      throw new TypeError('You can only respond with array buffer views');
	    }

	    ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
	  }
	}

	class ReadableByteStreamController {
	  constructor(stream, underlyingByteSource, highWaterMark) {
	    if (IsReadableStream(stream) === false) {
	      throw new TypeError('ReadableByteStreamController can only be constructed with a ReadableStream instance given ' +
	          'a byte source');
	    }

	    if (stream._readableStreamController !== undefined) {
	      throw new TypeError(
	          'ReadableByteStreamController instances can only be created by the ReadableStream constructor given a byte ' +
	              'source');
	    }

	    this._controlledReadableStream = stream;

	    this._underlyingByteSource = underlyingByteSource;

	    this._pullAgain = false;
	    this._pulling = false;

	    ReadableByteStreamControllerClearPendingPullIntos(this);

	    this._queue = [];
	    this._totalQueuedBytes = 0;

	    this._closeRequested = false;

	    this._started = false;

	    this._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);

	    const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
	    if (autoAllocateChunkSize !== undefined) {
	      if (Number.isInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {
	        throw new RangeError('autoAllocateChunkSize must be a positive integer');
	      }
	    }
	    this._autoAllocateChunkSize = autoAllocateChunkSize;

	    this._pendingPullIntos = [];

	    const controller = this;

	    const startResult = InvokeOrNoop(underlyingByteSource, 'start', [this]);
	    Promise.resolve(startResult).then(
	      () => {
	        controller._started = true;

	        assert(controller._pulling === false);
	        assert(controller._pullAgain === false);

	        ReadableByteStreamControllerCallPullIfNeeded(controller);
	      },
	      r => {
	        if (stream._state === 'readable') {
	          ReadableByteStreamControllerError(controller, r);
	        }
	      }
	    )
	    .catch(rethrowAssertionErrorRejection);
	  }

	  get byobRequest() {
	    if (IsReadableByteStreamController(this) === false) {
	      throw byteStreamControllerBrandCheckException('byobRequest');
	    }

	    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {
	      const firstDescriptor = this._pendingPullIntos[0];
	      const view = new Uint8Array(firstDescriptor.buffer,
	                                  firstDescriptor.byteOffset + firstDescriptor.bytesFilled,
	                                  firstDescriptor.byteLength - firstDescriptor.bytesFilled);

	      this._byobRequest = new ReadableStreamBYOBRequest(this, view);
	    }

	    return this._byobRequest;
	  }

	  get desiredSize() {
	    if (IsReadableByteStreamController(this) === false) {
	      throw byteStreamControllerBrandCheckException('desiredSize');
	    }

	    return ReadableByteStreamControllerGetDesiredSize(this);
	  }

	  close() {
	    if (IsReadableByteStreamController(this) === false) {
	      throw byteStreamControllerBrandCheckException('close');
	    }

	    if (this._closeRequested === true) {
	      throw new TypeError('The stream has already been closed; do not close it again!');
	    }

	    const state = this._controlledReadableStream._state;
	    if (state !== 'readable') {
	      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
	    }

	    ReadableByteStreamControllerClose(this);
	  }

	  enqueue(chunk) {
	    if (IsReadableByteStreamController(this) === false) {
	      throw byteStreamControllerBrandCheckException('enqueue');
	    }

	    if (this._closeRequested === true) {
	      throw new TypeError('stream is closed or draining');
	    }

	    const state = this._controlledReadableStream._state;
	    if (state !== 'readable') {
	      throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
	    }

	    if (!ArrayBuffer.isView(chunk)) {
	      throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');
	    }

	    ReadableByteStreamControllerEnqueue(this, chunk);
	  }

	  error(e) {
	    if (IsReadableByteStreamController(this) === false) {
	      throw byteStreamControllerBrandCheckException('error');
	    }

	    const stream = this._controlledReadableStream;
	    if (stream._state !== 'readable') {
	      throw new TypeError(`The stream is ${stream._state} and so cannot be errored`);
	    }

	    ReadableByteStreamControllerError(this, e);
	  }

	  [InternalCancel](reason) {
	    if (this._pendingPullIntos.length > 0) {
	      const firstDescriptor = this._pendingPullIntos[0];
	      firstDescriptor.bytesFilled = 0;
	    }

	    this._queue = [];
	    this._totalQueuedBytes = 0;

	    return PromiseInvokeOrNoop(this._underlyingByteSource, 'cancel', [reason]);
	  }

	  [InternalPull]() {
	    const stream = this._controlledReadableStream;

	    if (ReadableStreamGetNumReadRequests(stream) === 0) {
	      if (this._totalQueuedBytes > 0) {
	        const entry = this._queue.shift();
	        this._totalQueuedBytes -= entry.byteLength;

	        ReadableByteStreamControllerHandleQueueDrain(this);

	        let view;
	        try {
	          view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
	        } catch (viewE) {
	          return Promise.reject(viewE);
	        }

	        return Promise.resolve(CreateIterResultObject(view, false));
	      }

	      const autoAllocateChunkSize = this._autoAllocateChunkSize;
	      if (autoAllocateChunkSize !== undefined) {
	        let buffer;
	        try {
	          buffer = new ArrayBuffer(autoAllocateChunkSize);
	        } catch (bufferE) {
	          return Promise.reject(bufferE);
	        }

	        const pullIntoDescriptor = {
	          buffer,
	          byteOffset: 0,
	          byteLength: autoAllocateChunkSize,
	          bytesFilled: 0,
	          elementSize: 1,
	          ctor: Uint8Array,
	          readerType: 'default'
	        };

	        this._pendingPullIntos.push(pullIntoDescriptor);
	      }
	    } else {
	      assert(this._autoAllocateChunkSize === undefined);
	    }

	    const promise = ReadableStreamAddReadRequest(stream);

	    ReadableByteStreamControllerCallPullIfNeeded(this);

	    return promise;
	  }
	}

	// Abstract operations for the ReadableByteStreamController.

	function IsReadableByteStreamController(x) {
	  if (!typeIsObject(x)) {
	    return false;
	  }

	  if (!Object.prototype.hasOwnProperty.call(x, '_underlyingByteSource')) {
	    return false;
	  }

	  return true;
	}

	function IsReadableStreamBYOBRequest(x) {
	  if (!typeIsObject(x)) {
	    return false;
	  }

	  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
	    return false;
	  }

	  return true;
	}

	function ReadableByteStreamControllerCallPullIfNeeded(controller) {
	  const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
	  if (shouldPull === false) {
	    return undefined;
	  }

	  if (controller._pulling === true) {
	    controller._pullAgain = true;
	    return undefined;
	  }

	  assert(controller._pullAgain === false);

	  controller._pulling = true;

	  // TODO: Test controller argument
	  const pullPromise = PromiseInvokeOrNoop(controller._underlyingByteSource, 'pull', [controller]);
	  pullPromise.then(
	    () => {
	      controller._pulling = false;

	      if (controller._pullAgain === true) {
	        controller._pullAgain = false;
	        ReadableByteStreamControllerCallPullIfNeeded(controller);
	      }
	    },
	    e => {
	      if (controller._controlledReadableStream._state === 'readable') {
	        ReadableByteStreamControllerError(controller, e);
	      }
	    }
	  )
	  .catch(rethrowAssertionErrorRejection);

	  return undefined;
	}

	function ReadableByteStreamControllerClearPendingPullIntos(controller) {
	  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
	  controller._pendingPullIntos = [];
	}

	function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
	  assert(stream._state !== 'errored', 'state must not be errored');

	  let done = false;
	  if (stream._state === 'closed') {
	    assert(pullIntoDescriptor.bytesFilled === 0);
	    done = true;
	  }

	  const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
	  if (pullIntoDescriptor.readerType === 'default') {
	    ReadableStreamFulfillReadRequest(stream, filledView, done);
	  } else {
	    assert(pullIntoDescriptor.readerType === 'byob');
	    ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
	  }
	}

	function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
	  const bytesFilled = pullIntoDescriptor.bytesFilled;
	  const elementSize = pullIntoDescriptor.elementSize;

	  assert(bytesFilled <= pullIntoDescriptor.byteLength);
	  assert(bytesFilled % elementSize === 0);

	  return new pullIntoDescriptor.ctor(
	      pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
	}

	function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
	  controller._queue.push({ buffer, byteOffset, byteLength });
	  controller._totalQueuedBytes += byteLength;
	}

	function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
	  const elementSize = pullIntoDescriptor.elementSize;

	  const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;

	  const maxBytesToCopy = Math.min(controller._totalQueuedBytes,
	                                  pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
	  const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
	  const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;

	  let totalBytesToCopyRemaining = maxBytesToCopy;
	  let ready = false;
	  if (maxAlignedBytes > currentAlignedBytes) {
	    totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
	    ready = true;
	  }

	  const queue = controller._queue;

	  while (totalBytesToCopyRemaining > 0) {
	    const headOfQueue = queue[0];

	    const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);

	    const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
	    ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);

	    if (headOfQueue.byteLength === bytesToCopy) {
	      queue.shift();
	    } else {
	      headOfQueue.byteOffset += bytesToCopy;
	      headOfQueue.byteLength -= bytesToCopy;
	    }
	    controller._totalQueuedBytes -= bytesToCopy;

	    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);

	    totalBytesToCopyRemaining -= bytesToCopy;
	  }

	  if (ready === false) {
	    assert(controller._totalQueuedBytes === 0, 'queue must be empty');
	    assert(pullIntoDescriptor.bytesFilled > 0);
	    assert(pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize);
	  }

	  return ready;
	}

	function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
	  assert(controller._pendingPullIntos.length === 0 || controller._pendingPullIntos[0] === pullIntoDescriptor);

	  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
	  pullIntoDescriptor.bytesFilled += size;
	}

	function ReadableByteStreamControllerHandleQueueDrain(controller) {
	  assert(controller._controlledReadableStream._state === 'readable');

	  if (controller._totalQueuedBytes === 0 && controller._closeRequested === true) {
	    ReadableStreamClose(controller._controlledReadableStream);
	  } else {
	    ReadableByteStreamControllerCallPullIfNeeded(controller);
	  }
	}

	function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
	  if (controller._byobRequest === undefined) {
	    return;
	  }

	  controller._byobRequest._associatedReadableByteStreamController = undefined;
	  controller._byobRequest._view = undefined;
	  controller._byobRequest = undefined;
	}

	function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
	  assert(controller._closeRequested === false);

	  while (controller._pendingPullIntos.length > 0) {
	    if (controller._totalQueuedBytes === 0) {
	      return;
	    }

	    const pullIntoDescriptor = controller._pendingPullIntos[0];

	    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
	      ReadableByteStreamControllerShiftPendingPullInto(controller);

	      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);
	    }
	  }
	}

	function ReadableByteStreamControllerPullInto(controller, view) {
	  const stream = controller._controlledReadableStream;

	  let elementSize = 1;
	  if (view.constructor !== DataView) {
	    elementSize = view.constructor.BYTES_PER_ELEMENT;
	  }

	  const ctor = view.constructor;

	  const pullIntoDescriptor = {
	    buffer: view.buffer,
	    byteOffset: view.byteOffset,
	    byteLength: view.byteLength,
	    bytesFilled: 0,
	    elementSize,
	    ctor,
	    readerType: 'byob'
	  };

	  if (controller._pendingPullIntos.length > 0) {
	    pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer);
	    controller._pendingPullIntos.push(pullIntoDescriptor);

	    // No ReadableByteStreamControllerCallPullIfNeeded() call since:
	    // - No change happens on desiredSize
	    // - The source has already been notified of that there's at least 1 pending read(view)

	    return ReadableStreamAddReadIntoRequest(stream);
	  }

	  if (stream._state === 'closed') {
	    const emptyView = new view.constructor(view.buffer, view.byteOffset, 0);
	    return Promise.resolve(CreateIterResultObject(emptyView, true));
	  }

	  if (controller._totalQueuedBytes > 0) {
	    if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {
	      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);

	      ReadableByteStreamControllerHandleQueueDrain(controller);

	      return Promise.resolve(CreateIterResultObject(filledView, false));
	    }

	    if (controller._closeRequested === true) {
	      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
	      ReadableByteStreamControllerError(controller, e);

	      return Promise.reject(e);
	    }
	  }

	  pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer);
	  controller._pendingPullIntos.push(pullIntoDescriptor);

	  const promise = ReadableStreamAddReadIntoRequest(stream);

	  ReadableByteStreamControllerCallPullIfNeeded(controller);

	  return promise;
	}

	function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
	  firstDescriptor.buffer = SameRealmTransfer(firstDescriptor.buffer);

	  assert(firstDescriptor.bytesFilled === 0, 'bytesFilled must be 0');

	  const stream = controller._controlledReadableStream;

	  while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
	    const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);

	    ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
	  }
	}

	function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
	  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {
	    throw new RangeError('bytesWritten out of range');
	  }

	  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);

	  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
	    // TODO: Figure out whether we should detach the buffer or not here.
	    return;
	  }

	  ReadableByteStreamControllerShiftPendingPullInto(controller);

	  const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
	  if (remainderSize > 0) {
	    const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
	    const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);
	    ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
	  }

	  pullIntoDescriptor.buffer = SameRealmTransfer(pullIntoDescriptor.buffer);
	  pullIntoDescriptor.bytesFilled -= remainderSize;
	  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableStream, pullIntoDescriptor);

	  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
	}

	function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
	  const firstDescriptor = controller._pendingPullIntos[0];

	  const stream = controller._controlledReadableStream;

	  if (stream._state === 'closed') {
	    if (bytesWritten !== 0) {
	      throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
	    }

	    ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
	  } else {
	    assert(stream._state === 'readable');

	    ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
	  }
	}

	function ReadableByteStreamControllerShiftPendingPullInto(controller) {
	  const descriptor = controller._pendingPullIntos.shift();
	  ReadableByteStreamControllerInvalidateBYOBRequest(controller);
	  return descriptor;
	}

	function ReadableByteStreamControllerShouldCallPull(controller) {
	  const stream = controller._controlledReadableStream;

	  if (stream._state !== 'readable') {
	    return false;
	  }

	  if (controller._closeRequested === true) {
	    return false;
	  }

	  if (controller._started === false) {
	    return false;
	  }

	  if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
	    return true;
	  }

	  if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
	    return true;
	  }

	  if (ReadableByteStreamControllerGetDesiredSize(controller) > 0) {
	    return true;
	  }

	  return false;
	}

	// A client of ReadableByteStreamController may use these functions directly to bypass state check.

	function ReadableByteStreamControllerClose(controller) {
	  const stream = controller._controlledReadableStream;

	  assert(controller._closeRequested === false);
	  assert(stream._state === 'readable');

	  if (controller._totalQueuedBytes > 0) {
	    controller._closeRequested = true;

	    return;
	  }

	  if (controller._pendingPullIntos.length > 0) {
	    const firstPendingPullInto = controller._pendingPullIntos[0];
	    if (firstPendingPullInto.bytesFilled > 0) {
	      const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
	      ReadableByteStreamControllerError(controller, e);

	      throw e;
	    }
	  }

	  ReadableStreamClose(stream);
	}

	function ReadableByteStreamControllerEnqueue(controller, chunk) {
	  const stream = controller._controlledReadableStream;

	  assert(controller._closeRequested === false);
	  assert(stream._state === 'readable');

	  const buffer = chunk.buffer;
	  const byteOffset = chunk.byteOffset;
	  const byteLength = chunk.byteLength;
	  const transferredBuffer = SameRealmTransfer(buffer);

	  if (ReadableStreamHasDefaultReader(stream) === true) {
	    if (ReadableStreamGetNumReadRequests(stream) === 0) {
	      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
	    } else {
	      assert(controller._queue.length === 0);

	      const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
	      ReadableStreamFulfillReadRequest(stream, transferredView, false);
	    }
	  } else if (ReadableStreamHasBYOBReader(stream) === true) {
	    // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.
	    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
	    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
	  } else {
	    assert(IsReadableStreamLocked(stream) === false, 'stream must not be locked');
	    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
	  }
	}

	function ReadableByteStreamControllerError(controller, e) {
	  const stream = controller._controlledReadableStream;

	  assert(stream._state === 'readable');

	  ReadableByteStreamControllerClearPendingPullIntos(controller);

	  controller._queue = [];

	  ReadableStreamError(stream, e);
	}

	function ReadableByteStreamControllerGetDesiredSize(controller) {
	  return controller._strategyHWM - controller._totalQueuedBytes;
	}

	function ReadableByteStreamControllerRespond(controller, bytesWritten) {
	  bytesWritten = Number(bytesWritten);
	  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {
	    throw new RangeError('bytesWritten must be a finite');
	  }

	  assert(controller._pendingPullIntos.length > 0);

	  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
	}

	function ReadableByteStreamControllerRespondWithNewView(controller, view) {
	  assert(controller._pendingPullIntos.length > 0);

	  const firstDescriptor = controller._pendingPullIntos[0];

	  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
	    throw new RangeError('The region specified by view does not match byobRequest');
	  }
	  if (firstDescriptor.byteLength !== view.byteLength) {
	    throw new RangeError('The buffer of view has different capacity than byobRequest');
	  }

	  firstDescriptor.buffer = view.buffer;

	  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);
	}

	// Helper functions for the ReadableStream.

	function streamBrandCheckException(name) {
	  return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
	}

	// Helper functions for the readers.

	function readerLockException(name) {
	  return new TypeError('Cannot ' + name + ' a stream using a released reader');
	}

	// Helper functions for the ReadableStreamDefaultReader.

	function defaultReaderBrandCheckException(name) {
	  return new TypeError(
	    `ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
	}

	function defaultReaderClosedPromiseInitialize(reader) {
	  reader._closedPromise = new Promise((resolve, reject) => {
	    reader._closedPromise_resolve = resolve;
	    reader._closedPromise_reject = reject;
	  });
	}

	function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
	  reader._closedPromise = Promise.reject(reason);
	  reader._closedPromise_resolve = undefined;
	  reader._closedPromise_reject = undefined;
	}

	function defaultReaderClosedPromiseInitializeAsResolved(reader) {
	  reader._closedPromise = Promise.resolve(undefined);
	  reader._closedPromise_resolve = undefined;
	  reader._closedPromise_reject = undefined;
	}

	function defaultReaderClosedPromiseReject(reader, reason) {
	  assert(reader._closedPromise_resolve !== undefined);
	  assert(reader._closedPromise_reject !== undefined);

	  reader._closedPromise_reject(reason);
	  reader._closedPromise_resolve = undefined;
	  reader._closedPromise_reject = undefined;
	}

	function defaultReaderClosedPromiseResetToRejected(reader, reason) {
	  assert(reader._closedPromise_resolve === undefined);
	  assert(reader._closedPromise_reject === undefined);

	  reader._closedPromise = Promise.reject(reason);
	}

	function defaultReaderClosedPromiseResolve(reader) {
	  assert(reader._closedPromise_resolve !== undefined);
	  assert(reader._closedPromise_reject !== undefined);

	  reader._closedPromise_resolve(undefined);
	  reader._closedPromise_resolve = undefined;
	  reader._closedPromise_reject = undefined;
	}

	// Helper functions for the ReadableStreamDefaultReader.

	function byobReaderBrandCheckException(name) {
	  return new TypeError(
	    `ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
	}

	// Helper functions for the ReadableStreamDefaultController.

	function defaultControllerBrandCheckException(name) {
	  return new TypeError(
	    `ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
	}

	// Helper functions for the ReadableStreamBYOBRequest.

	function byobRequestBrandCheckException(name) {
	  return new TypeError(
	    `ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
	}

	// Helper functions for the ReadableByteStreamController.

	function byteStreamControllerBrandCheckException(name) {
	  return new TypeError(
	    `ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
	}

/***/ },
/* 25 */
/***/ function(module, exports) {

	module.exports = require("assert");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const assert = __webpack_require__(25);

	function IsPropertyKey(argument) {
	  return typeof argument === 'string' || typeof argument === 'symbol';
	}

	exports.typeIsObject = x => (typeof x === 'object' && x !== null) || typeof x === 'function';

	exports.createDataProperty = (o, p, v) => {
	  assert(exports.typeIsObject(o));
	  Object.defineProperty(o, p, { value: v, writable: true, enumerable: true, configurable: true });
	};

	exports.createArrayFromList = elements => {
	  // We use arrays to represent lists, so this is basically a no-op.
	  // Do a slice though just in case we happen to depend on the unique-ness.
	  return elements.slice();
	};

	exports.ArrayBufferCopy = (dest, destOffset, src, srcOffset, n) => {
	  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
	};

	exports.CreateIterResultObject = (value, done) => {
	  assert(typeof done === 'boolean');
	  const obj = {};
	  Object.defineProperty(obj, 'value', { value, enumerable: true, writable: true, configurable: true });
	  Object.defineProperty(obj, 'done', { value: done, enumerable: true, writable: true, configurable: true });
	  return obj;
	};

	exports.IsFiniteNonNegativeNumber = v => {
	  if (Number.isNaN(v)) {
	    return false;
	  }
	  if (v === Infinity) {
	    return false;
	  }
	  if (v < 0) {
	    return false;
	  }

	  return true;
	};

	exports.InvokeOrNoop = (O, P, args) => {
	  assert(O !== undefined);
	  assert(IsPropertyKey(P));
	  assert(Array.isArray(args));

	  const method = O[P];
	  if (method === undefined) {
	    return undefined;
	  }

	  if (typeof method !== 'function') {
	    throw new TypeError(`${P} is not a function`);
	  }

	  return method.apply(O, args);
	};

	exports.PromiseInvokeOrNoop = (O, P, args) => {
	  assert(O !== undefined);
	  assert(IsPropertyKey(P));
	  assert(Array.isArray(args));
	  try {
	    return Promise.resolve(exports.InvokeOrNoop(O, P, args));
	  } catch (returnValueE) {
	    return Promise.reject(returnValueE);
	  }
	};

	exports.PromiseInvokeOrPerformFallback = (O, P, args, F, argsF) => {
	  assert(O !== undefined);
	  assert(IsPropertyKey(P));
	  assert(Array.isArray(args));
	  assert(Array.isArray(argsF));

	  let method;
	  try {
	    method = O[P];
	  } catch (methodE) {
	    return Promise.reject(methodE);
	  }

	  if (method === undefined) {
	    return F(...argsF);
	  }

	  if (typeof method !== 'function') {
	    return Promise.reject(new TypeError(`${P} is not a function`));
	  }

	  try {
	    return Promise.resolve(method.apply(O, args));
	  } catch (e) {
	    return Promise.reject(e);
	  }
	};

	exports.PromiseInvokeOrFallbackOrNoop = (O, P1, args1, P2, args2) => {
	  assert(O !== undefined);
	  assert(IsPropertyKey(P1));
	  assert(Array.isArray(args1));
	  assert(IsPropertyKey(P2));
	  assert(Array.isArray(args2));

	  return exports.PromiseInvokeOrPerformFallback(O, P1, args1, exports.PromiseInvokeOrNoop, [O, P2, args2]);
	};

	// Not implemented correctly
	exports.SameRealmTransfer = O => O;

	exports.ValidateAndNormalizeHighWaterMark = highWaterMark => {
	  highWaterMark = Number(highWaterMark);
	  if (Number.isNaN(highWaterMark) || highWaterMark < 0) {
	    throw new RangeError('highWaterMark property of a queuing strategy must be nonnegative and non-NaN');
	  }

	  return highWaterMark;
	};

	exports.ValidateAndNormalizeQueuingStrategy = (size, highWaterMark) => {
	  if (size !== undefined && typeof size !== 'function') {
	    throw new TypeError('size property of a queuing strategy must be a function');
	  }

	  highWaterMark = exports.ValidateAndNormalizeHighWaterMark(highWaterMark);

	  return { size, highWaterMark };
	};

	/**
	 * Stores a promise  in a thenable so that it fires only
	 * when used. Calling Promise.reject(error) otherwise throws a global error.
	 */

	function StoredPromise(init) {
	  this._resolve = value => {
	    this._resolved = true;
	    this._value    = value
	  }
	  this._reject  = value => {
	    this._rejected = true;
	    this._value    = value;
	  }

	  init(
	    value => {
	      this._resolve(value)
	    },
	    value => {
	      this._reject(value)
	    }
	  );
	}

	StoredPromise.reject = function (error) {
	  return new StoredPromise((resolve, reject) => {
	    reject(error);
	  });
	}

	StoredPromise.prototype.then = function(resolve, reject) {
	  if (this._resolved) return Promise.resolve(this._value).then(resolve, reject);
	  if (this._rejected) return Promise.reject(this._value).then(resolve, reject);
	  return (this._p || (this._p = new Promise((resolve, reject) => {
	    this._resolve = resolve;
	    this._reject  = reject;
	  }))).then(resolve, reject);
	}

	StoredPromise.prototype.catch = function(reject) {
	  return this.then(() => {}, reject);
	}


	exports.StoredPromise = StoredPromise;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const assert = __webpack_require__(25);

	exports.rethrowAssertionErrorRejection = e => {
	  // Used throughout the reference implementation, as `.catch(rethrowAssertionErrorRejection)`, to ensure any errors
	  // get shown. There are places in the spec where we do promise transformations and purposefully ignore or don't
	  // expect any errors, but assertion errors are always problematic.
	  if (e && e.constructor === assert.AssertionError) {
	    setTimeout(() => {
	      throw e;
	    }, 0);
	  }
	};


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const assert = __webpack_require__(25);
	const { IsFiniteNonNegativeNumber } = __webpack_require__(26);

	exports.DequeueValue = queue => {
	  assert(queue.length > 0, 'Spec-level failure: should never dequeue from an empty queue.');
	  const pair = queue.shift();

	  queue._totalSize -= pair.size;

	  return pair.value;
	};

	exports.EnqueueValueWithSize = (queue, value, size) => {
	  size = Number(size);
	  if (!IsFiniteNonNegativeNumber(size)) {
	    throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
	  }

	  queue.push({ value, size });

	  if (queue._totalSize === undefined) {
	    queue._totalSize = 0;
	  }
	  queue._totalSize += size;
	};

	// This implementation is not per-spec. Total size is cached for speed.
	exports.GetTotalQueueSize = queue => {
	  if (queue._totalSize === undefined) {
	    queue._totalSize = 0;
	  }
	  return queue._totalSize;
	};

	exports.PeekQueueValue = queue => {
	  assert(queue.length > 0, 'Spec-level failure: should never peek at an empty queue.');
	  const pair = queue[0];
	  return pair.value;
	};


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	const assert = __webpack_require__(25);
	const { InvokeOrNoop, PromiseInvokeOrNoop, PromiseInvokeOrFallbackOrNoop, ValidateAndNormalizeQueuingStrategy,
	        typeIsObject } = __webpack_require__(26);
	const { rethrowAssertionErrorRejection } = __webpack_require__(27);
	const { DequeueValue, EnqueueValueWithSize, GetTotalQueueSize, PeekQueueValue } = __webpack_require__(28);

	class WritableStream {
	  constructor(underlyingSink = {}, { size, highWaterMark = 1 } = {}) {
	    this._state = 'writable';
	    this._storedError = undefined;

	    this._writer = undefined;

	    // Initialize to undefined first because the constructor of the controller checks this
	    // variable to validate the caller.
	    this._writableStreamController = undefined;

	    // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data
	    // producer without waiting for the queued writes to finish.
	    this._writeRequests = [];

	    const type = underlyingSink.type;

	    if (type !== undefined) {
	      throw new RangeError('Invalid type is specified');
	    }

	    this._writableStreamController = new WritableStreamDefaultController(this, underlyingSink, size, highWaterMark);
	  }

	  get locked() {
	    if (IsWritableStream(this) === false) {
	      throw streamBrandCheckException('locked');
	    }

	    return IsWritableStreamLocked(this);
	  }

	  abort(reason) {
	    if (IsWritableStream(this) === false) {
	      return Promise.reject(streamBrandCheckException('abort'));
	    }

	    if (IsWritableStreamLocked(this) === true) {
	      return Promise.reject(new TypeError('Cannot abort a stream that already has a writer'));
	    }

	    return WritableStreamAbort(this, reason);
	  }

	  getWriter() {
	    if (IsWritableStream(this) === false) {
	      throw streamBrandCheckException('getWriter');
	    }

	    return AcquireWritableStreamDefaultWriter(this);
	  }
	}

	module.exports = {
	  AcquireWritableStreamDefaultWriter,
	  IsWritableStream,
	  IsWritableStreamLocked,
	  WritableStream,
	  WritableStreamAbort,
	  WritableStreamDefaultControllerError,
	  WritableStreamDefaultWriterCloseWithErrorPropagation,
	  WritableStreamDefaultWriterRelease,
	  WritableStreamDefaultWriterWrite
	};

	// Abstract operations for the WritableStream.

	function AcquireWritableStreamDefaultWriter(stream) {
	  return new WritableStreamDefaultWriter(stream);
	}

	function IsWritableStream(x) {
	  if (!typeIsObject(x)) {
	    return false;
	  }

	  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
	    return false;
	  }

	  return true;
	}

	function IsWritableStreamLocked(stream) {
	  assert(IsWritableStream(stream) === true, 'IsWritableStreamLocked should only be used on known writable streams');

	  if (stream._writer === undefined) {
	    return false;
	  }

	  return true;
	}

	function WritableStreamAbort(stream, reason) {
	  const state = stream._state;
	  if (state === 'closed') {
	    return Promise.resolve(undefined);
	  }
	  if (state === 'errored') {
	    return Promise.reject(stream._storedError);
	  }

	  assert(state === 'writable' || state === 'closing');

	  const error = new TypeError('Aborted');

	  WritableStreamError(stream, error);

	  return WritableStreamDefaultControllerAbort(stream._writableStreamController, reason);
	}

	// WritableStream API exposed for controllers.

	function WritableStreamAddWriteRequest(stream) {
	  assert(IsWritableStreamLocked(stream) === true);
	  assert(stream._state === 'writable');

	  const promise = new Promise((resolve, reject) => {
	    const writeRequest = {
	      _resolve: resolve,
	      _reject: reject
	    };

	    stream._writeRequests.push(writeRequest);
	  });

	  return promise;
	}

	function WritableStreamError(stream, e) {
	  const state = stream._state;
	  assert(state === 'writable' || state === 'closing');

	  for (const writeRequest of stream._writeRequests) {
	    writeRequest._reject(e);
	  }
	  stream._writeRequests = [];

	  const writer = stream._writer;
	  if (writer !== undefined) {
	    defaultWriterClosedPromiseReject(writer, e);
	    writer._closedPromise.catch(() => {});

	    if (state === 'writable' &&
	        WritableStreamDefaultControllerGetBackpressure(stream._writableStreamController) === true) {
	      defaultWriterReadyPromiseReject(writer, e);
	    } else {
	      defaultWriterReadyPromiseResetToRejected(writer, e);
	    }
	    writer._readyPromise.catch(() => {});
	  }

	  stream._state = 'errored';
	  stream._storedError = e;
	}

	function WritableStreamFinishClose(stream) {
	  assert(stream._state === 'closing');

	  // writer cannot be released while close() is ongoing. So, we can assert that
	  // there's an active writer.
	  assert(stream._writer !== undefined);

	  stream._state = 'closed';

	  defaultWriterClosedPromiseResolve(stream._writer);
	}

	function WritableStreamFulfillWriteRequest(stream) {
	  assert(stream._writeRequests.length > 0);

	  const writeRequest = stream._writeRequests.shift();
	  writeRequest._resolve(undefined);
	}

	function WritableStreamUpdateBackpressure(stream, backpressure) {
	  assert(stream._state === 'writable');

	  const writer = stream._writer;
	  if (writer === undefined) {
	    return;
	  }

	  if (backpressure === true) {
	    defaultWriterReadyPromiseReset(writer);
	  } else {
	    assert(backpressure === false);
	    defaultWriterReadyPromiseResolve(writer);
	  }
	}

	class WritableStreamDefaultWriter {
	  constructor(stream) {
	    if (IsWritableStream(stream) === false) {
	      throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');
	    }
	    if (IsWritableStreamLocked(stream) === true) {
	      throw new TypeError('This stream has already been locked for exclusive writing by another writer');
	    }

	    this._ownerWritableStream = stream;
	    stream._writer = this;

	    const state = stream._state;

	    if (state === 'writable' || state === 'closing') {
	      defaultWriterClosedPromiseInitialize(this);
	    } else if (state === 'closed') {
	      defaultWriterClosedPromiseInitializeAsResolved(this);
	    } else {
	      assert(state === 'errored', 'state must be errored');

	      defaultWriterClosedPromiseInitializeAsRejected(this, stream._storedError);
	      this._closedPromise.catch(() => {});
	    }

	    if (state === 'writable' &&
	        WritableStreamDefaultControllerGetBackpressure(stream._writableStreamController) === true) {
	      defaultWriterReadyPromiseInitialize(this);
	    } else {
	      defaultWriterReadyPromiseInitializeAsResolved(this, undefined);
	    }
	  }

	  get closed() {
	    if (IsWritableStreamDefaultWriter(this) === false) {
	      return Promise.reject(defaultWriterBrandCheckException('closed'));
	    }

	    return this._closedPromise;
	  }

	  get desiredSize() {
	    if (IsWritableStreamDefaultWriter(this) === false) {
	      throw defaultWriterBrandCheckException('desiredSize');
	    }

	    if (this._ownerWritableStream === undefined) {
	      throw defaultWriterLockException('desiredSize');
	    }

	    return WritableStreamDefaultWriterGetDesiredSize(this);
	  }

	  get ready() {
	    if (IsWritableStreamDefaultWriter(this) === false) {
	      return Promise.reject(defaultWriterBrandCheckException('ready'));
	    }

	    return this._readyPromise;
	  }

	  abort(reason) {
	    if (IsWritableStreamDefaultWriter(this) === false) {
	      return Promise.reject(defaultWriterBrandCheckException('abort'));
	    }

	    if (this._ownerWritableStream === undefined) {
	      return Promise.reject(defaultWriterLockException('abort'));
	    }

	    return WritableStreamDefaultWriterAbort(this, reason);
	  }

	  close() {
	    if (IsWritableStreamDefaultWriter(this) === false) {
	      return Promise.reject(defaultWriterBrandCheckException('close'));
	    }

	    const stream = this._ownerWritableStream;

	    if (stream === undefined) {
	      return Promise.reject(defaultWriterLockException('close'));
	    }

	    if (stream._state === 'closing') {
	      return Promise.reject(new TypeError('cannot close an already-closing stream'));
	    }

	    return WritableStreamDefaultWriterClose(this);
	  }

	  releaseLock() {
	    if (IsWritableStreamDefaultWriter(this) === false) {
	      throw defaultWriterBrandCheckException('releaseLock');
	    }

	    const stream = this._ownerWritableStream;

	    if (stream === undefined) {
	      return;
	    }

	    assert(stream._writer !== undefined);

	    WritableStreamDefaultWriterRelease(this);
	  }

	  write(chunk) {
	    if (IsWritableStreamDefaultWriter(this) === false) {
	      return Promise.reject(defaultWriterBrandCheckException('write'));
	    }

	    const stream = this._ownerWritableStream;

	    if (stream === undefined) {
	      return Promise.reject(defaultWriterLockException('write to'));
	    }

	    if (stream._state === 'closing') {
	      return Promise.reject(new TypeError('Cannot write to an already-closed stream'));
	    }

	    return WritableStreamDefaultWriterWrite(this, chunk);
	  }
	}

	// Abstract operations for the WritableStreamDefaultWriter.

	function IsWritableStreamDefaultWriter(x) {
	  if (!typeIsObject(x)) {
	    return false;
	  }

	  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
	    return false;
	  }

	  return true;
	}

	// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.

	function WritableStreamDefaultWriterAbort(writer, reason) {
	  const stream = writer._ownerWritableStream;

	  assert(stream !== undefined);

	  return WritableStreamAbort(stream, reason);
	}

	function WritableStreamDefaultWriterClose(writer) {
	  const stream = writer._ownerWritableStream;

	  assert(stream !== undefined);

	  const state = stream._state;
	  if (state === 'closed' || state === 'errored') {
	    return Promise.reject(new TypeError(
	      `The stream (in ${state} state) is not in the writable state and cannot be closed`));
	  }

	  assert(state === 'writable');

	  const promise = WritableStreamAddWriteRequest(stream);

	  if (WritableStreamDefaultControllerGetBackpressure(stream._writableStreamController) === true) {
	    defaultWriterReadyPromiseResolve(writer);
	  }

	  stream._state = 'closing';

	  WritableStreamDefaultControllerClose(stream._writableStreamController);

	  return promise;
	}


	function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
	  const stream = writer._ownerWritableStream;

	  assert(stream !== undefined);

	  const state = stream._state;
	  if (state === 'closing' || state === 'closed') {
	    return Promise.resolve();
	  }

	  if (state === 'errored') {
	    return Promise.reject(stream._storedError);
	  }

	  assert(state === 'writable');

	  return WritableStreamDefaultWriterClose(writer);
	}

	function WritableStreamDefaultWriterGetDesiredSize(writer) {
	  const stream = writer._ownerWritableStream;
	  const state = stream._state;

	  if (state === 'errored') {
	    return null;
	  }

	  if (state === 'closed') {
	    return 0;
	  }

	  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
	}

	function WritableStreamDefaultWriterRelease(writer) {
	  const stream = writer._ownerWritableStream;
	  assert(stream !== undefined);
	  assert(stream._writer === writer);

	  const releasedError = new TypeError(
	    'Writer was released and can no longer be used to monitor the stream\'s closedness');
	  const state = stream._state;

	  if (state === 'writable' || state === 'closing') {
	    defaultWriterClosedPromiseReject(writer, releasedError);
	  } else {
	    defaultWriterClosedPromiseResetToRejected(writer, releasedError);
	  }
	  writer._closedPromise.catch(() => {});

	  if (state === 'writable' &&
	      WritableStreamDefaultControllerGetBackpressure(stream._writableStreamController) === true) {
	    defaultWriterReadyPromiseReject(writer, releasedError);
	  } else {
	    defaultWriterReadyPromiseResetToRejected(writer, releasedError);
	  }
	  writer._readyPromise.catch(() => {});

	  stream._writer = undefined;
	  writer._ownerWritableStream = undefined;
	}

	function WritableStreamDefaultWriterWrite(writer, chunk) {
	  const stream = writer._ownerWritableStream;

	  assert(stream !== undefined);

	  const state = stream._state;
	  if (state === 'closed' || state === 'errored') {
	    return Promise.reject(new TypeError(
	      `The stream (in ${state} state) is not in the writable state and cannot be written to`));
	  }

	  assert(state === 'writable');

	  const promise = WritableStreamAddWriteRequest(stream);

	  WritableStreamDefaultControllerWrite(stream._writableStreamController, chunk);

	  return promise;
	}

	class WritableStreamDefaultController {
	  constructor(stream, underlyingSink, size, highWaterMark) {
	    if (IsWritableStream(stream) === false) {
	      throw new TypeError('WritableStreamDefaultController can only be constructed with a WritableStream instance');
	    }

	    if (stream._writableStreamController !== undefined) {
	      throw new TypeError(
	        'WritableStreamDefaultController instances can only be created by the WritableStream constructor');
	    }

	    this._controlledWritableStream = stream;

	    this._underlyingSink = underlyingSink;

	    this._queue = [];
	    this._started = false;
	    this._writing = false;

	    const normalizedStrategy = ValidateAndNormalizeQueuingStrategy(size, highWaterMark);
	    this._strategySize = normalizedStrategy.size;
	    this._strategyHWM = normalizedStrategy.highWaterMark;

	    const backpressure = WritableStreamDefaultControllerGetBackpressure(this);
	    if (backpressure === true) {
	      WritableStreamUpdateBackpressure(stream, backpressure);
	    }

	    const controller = this;

	    const startResult = InvokeOrNoop(underlyingSink, 'start', [this]);
	    Promise.resolve(startResult).then(
	      () => {
	        controller._started = true;
	        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
	      },
	      r => {
	        WritableStreamDefaultControllerErrorIfNeeded(controller, r);
	      }
	    )
	    .catch(rethrowAssertionErrorRejection);
	  }

	  error(e) {
	    if (IsWritableStreamDefaultController(this) === false) {
	      throw new TypeError(
	        'WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');
	    }

	    const state = this._controlledWritableStream._state;
	    if (state === 'closed' || state === 'errored') {
	      throw new TypeError(`The stream is ${state} and so cannot be errored`);
	    }

	    WritableStreamDefaultControllerError(this, e);
	  }
	}

	// Abstract operations implementing interface required by the WritableStream.

	function WritableStreamDefaultControllerAbort(controller, reason) {
	  controller._queue = [];

	  const sinkAbortPromise = PromiseInvokeOrFallbackOrNoop(controller._underlyingSink, 'abort', [reason],
	                                                         'close', [controller]);
	  return sinkAbortPromise.then(() => undefined);
	}

	function WritableStreamDefaultControllerClose(controller) {
	  EnqueueValueWithSize(controller._queue, 'close', 0);
	  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
	}

	function WritableStreamDefaultControllerGetDesiredSize(controller) {
	  const queueSize = GetTotalQueueSize(controller._queue);
	  return controller._strategyHWM - queueSize;
	}

	function WritableStreamDefaultControllerWrite(controller, chunk) {
	  const stream = controller._controlledWritableStream;

	  assert(stream._state === 'writable');

	  let chunkSize = 1;

	  if (controller._strategySize !== undefined) {
	    try {
	      chunkSize = controller._strategySize(chunk);
	    } catch (chunkSizeE) {
	      // TODO: Should we notify the sink of this error?
	      WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
	      return;
	    }
	  }

	  const writeRecord = { chunk };

	  const lastBackpressure = WritableStreamDefaultControllerGetBackpressure(controller);

	  try {
	    EnqueueValueWithSize(controller._queue, writeRecord, chunkSize);
	  } catch (enqueueE) {
	    WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
	    return;
	  }

	  if (stream._state === 'writable') {
	    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
	    if (lastBackpressure !== backpressure) {
	      WritableStreamUpdateBackpressure(stream, backpressure);
	    }
	  }

	  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
	}

	// Abstract operations for the WritableStreamDefaultController.

	function IsWritableStreamDefaultController(x) {
	  if (!typeIsObject(x)) {
	    return false;
	  }

	  if (!Object.prototype.hasOwnProperty.call(x, '_underlyingSink')) {
	    return false;
	  }

	  return true;
	}

	function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
	  if (controller._controlledWritableStream._state === 'closed' ||
	      controller._controlledWritableStream._state === 'errored') {
	    return;
	  }

	  if (controller._started === false) {
	    return;
	  }

	  if (controller._writing === true) {
	    return;
	  }

	  if (controller._queue.length === 0) {
	    return;
	  }

	  const writeRecord = PeekQueueValue(controller._queue);
	  if (writeRecord === 'close') {
	    WritableStreamDefaultControllerProcessClose(controller);
	  } else {
	    WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);
	  }
	}

	function WritableStreamDefaultControllerErrorIfNeeded(controller, e) {
	  if (controller._controlledWritableStream._state === 'writable' ||
	      controller._controlledWritableStream._state === 'closing') {
	    WritableStreamDefaultControllerError(controller, e);
	  }
	}

	function WritableStreamDefaultControllerProcessClose(controller) {
	  const stream = controller._controlledWritableStream;

	  assert(stream._state === 'closing', 'can\'t process final write record unless already closed');

	  DequeueValue(controller._queue);
	  assert(controller._queue.length === 0, 'queue must be empty once the final write record is dequeued');

	  const sinkClosePromise = PromiseInvokeOrNoop(controller._underlyingSink, 'close', [controller]);
	  sinkClosePromise.then(
	    () => {
	      if (stream._state !== 'closing') {
	        return;
	      }

	      WritableStreamFulfillWriteRequest(stream);
	      WritableStreamFinishClose(stream);
	    },
	    r => {
	      WritableStreamDefaultControllerErrorIfNeeded(controller, r);
	    }
	  )
	  .catch(rethrowAssertionErrorRejection);
	}

	function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
	  controller._writing = true;

	  const sinkWritePromise = PromiseInvokeOrNoop(controller._underlyingSink, 'write', [chunk, controller]);
	  sinkWritePromise.then(
	    () => {
	      const stream = controller._controlledWritableStream;
	      const state = stream._state;
	      if (state === 'errored' || state === 'closed') {
	        return;
	      }

	      controller._writing = false;

	      WritableStreamFulfillWriteRequest(stream);

	      const lastBackpressure = WritableStreamDefaultControllerGetBackpressure(controller);
	      DequeueValue(controller._queue);
	      if (state !== 'closing') {
	        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
	        if (lastBackpressure !== backpressure) {
	          WritableStreamUpdateBackpressure(controller._controlledWritableStream, backpressure);
	        }
	      }

	      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
	    },
	    r => {
	      WritableStreamDefaultControllerErrorIfNeeded(controller, r);
	    }
	  )
	  .catch(rethrowAssertionErrorRejection);
	}

	function WritableStreamDefaultControllerGetBackpressure(controller) {
	  const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
	  return desiredSize <= 0;
	}

	// A client of WritableStreamDefaultController may use these functions directly to bypass state check.

	function WritableStreamDefaultControllerError(controller, e) {
	  const stream = controller._controlledWritableStream;

	  assert(stream._state === 'writable' || stream._state === 'closing');

	  WritableStreamError(stream, e);

	  controller._queue = [];
	}

	// Helper functions for the WritableStream.

	function streamBrandCheckException(name) {
	  return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
	}

	// Helper functions for the WritableStreamDefaultWriter.

	function defaultWriterBrandCheckException(name) {
	  return new TypeError(
	    `WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
	}

	function defaultWriterLockException(name) {
	  return new TypeError('Cannot ' + name + ' a stream using a released writer');
	}

	function defaultWriterClosedPromiseInitialize(writer) {
	  writer._closedPromise = new Promise((resolve, reject) => {
	    writer._closedPromise_resolve = resolve;
	    writer._closedPromise_reject = reject;
	  });
	}

	function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
	  writer._closedPromise = Promise.reject(reason);
	  writer._closedPromise_resolve = undefined;
	  writer._closedPromise_reject = undefined;
	}

	function defaultWriterClosedPromiseInitializeAsResolved(writer) {
	  writer._closedPromise = Promise.resolve(undefined);
	  writer._closedPromise_resolve = undefined;
	  writer._closedPromise_reject = undefined;
	}

	function defaultWriterClosedPromiseReject(writer, reason) {
	  assert(writer._closedPromise_resolve !== undefined);
	  assert(writer._closedPromise_reject !== undefined);

	  writer._closedPromise_reject(reason);
	  writer._closedPromise_resolve = undefined;
	  writer._closedPromise_reject = undefined;
	}

	function defaultWriterClosedPromiseResetToRejected(writer, reason) {
	  assert(writer._closedPromise_resolve === undefined);
	  assert(writer._closedPromise_reject === undefined);

	  writer._closedPromise = Promise.reject(reason);
	}

	function defaultWriterClosedPromiseResolve(writer) {
	  assert(writer._closedPromise_resolve !== undefined);
	  assert(writer._closedPromise_reject !== undefined);

	  writer._closedPromise_resolve(undefined);
	  writer._closedPromise_resolve = undefined;
	  writer._closedPromise_reject = undefined;
	}

	function defaultWriterReadyPromiseInitialize(writer) {
	  writer._readyPromise = new Promise((resolve, reject) => {
	    writer._readyPromise_resolve = resolve;
	    writer._readyPromise_reject = reject;
	  });
	}

	function defaultWriterReadyPromiseInitializeAsResolved(writer) {
	  writer._readyPromise = Promise.resolve(undefined);
	  writer._readyPromise_resolve = undefined;
	  writer._readyPromise_reject = undefined;
	}

	function defaultWriterReadyPromiseReject(writer, reason) {
	  assert(writer._readyPromise_resolve !== undefined);
	  assert(writer._readyPromise_reject !== undefined);

	  writer._readyPromise_reject(reason);
	  writer._readyPromise_resolve = undefined;
	  writer._readyPromise_reject = undefined;
	}

	function defaultWriterReadyPromiseReset(writer) {
	  assert(writer._readyPromise_resolve === undefined);
	  assert(writer._readyPromise_reject === undefined);

	  writer._readyPromise = new Promise((resolve, reject) => {
	    writer._readyPromise_resolve = resolve;
	    writer._readyPromise_reject = reject;
	  });
	}

	function defaultWriterReadyPromiseResetToRejected(writer, reason) {
	  assert(writer._readyPromise_resolve === undefined);
	  assert(writer._readyPromise_reject === undefined);

	  writer._readyPromise = Promise.reject(reason);
	}

	function defaultWriterReadyPromiseResolve(writer) {
	  assert(writer._readyPromise_resolve !== undefined);
	  assert(writer._readyPromise_reject !== undefined);

	  writer._readyPromise_resolve(undefined);
	  writer._readyPromise_resolve = undefined;
	  writer._readyPromise_reject = undefined;
	}

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	// from https://github.com/whatwg/streams

	'use strict';
	const assert = __webpack_require__(25);
	const { InvokeOrNoop, PromiseInvokeOrPerformFallback, PromiseInvokeOrNoop, typeIsObject } = __webpack_require__(26);
	const { ReadableStream, ReadableStreamDefaultControllerClose,
	        ReadableStreamDefaultControllerEnqueue, ReadableStreamDefaultControllerError,
	        ReadableStreamDefaultControllerGetDesiredSize } = __webpack_require__(24);
	const { WritableStream, WritableStreamDefaultControllerError } = __webpack_require__(29);

	// Methods on the transform stream controller object

	function TransformStreamCloseReadable(transformStream) {
	  // console.log('TransformStreamCloseReadable()');

	  if (transformStream._errored === true) {
	    throw new TypeError('TransformStream is already errored');
	  }

	  if (transformStream._readableClosed === true) {
	    throw new TypeError('Readable side is already closed');
	  }

	  TransformStreamCloseReadableInternal(transformStream);
	}

	function TransformStreamEnqueueToReadable(transformStream, chunk) {
	  // console.log('TransformStreamEnqueueToReadable()');

	  if (transformStream._errored === true) {
	    throw new TypeError('TransformStream is already errored');
	  }

	  if (transformStream._readableClosed === true) {
	    throw new TypeError('Readable side is already closed');
	  }

	  // We throttle transformer.transform invocation based on the backpressure of the ReadableStream, but we still
	  // accept TransformStreamEnqueueToReadable() calls.

	  const controller = transformStream._readableController;

	  try {
	    ReadableStreamDefaultControllerEnqueue(controller, chunk);
	  } catch (e) {
	    // This happens when readableStrategy.size() throws.
	    // The ReadableStream has already errored itself.
	    transformStream._readableClosed = true;
	    TransformStreamErrorIfNeeded(transformStream, e);

	    throw transformStream._storedError;
	  }

	  const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
	  const maybeBackpressure = desiredSize <= 0;

	  if (maybeBackpressure === true && transformStream._backpressure === false) {
	    // This allows pull() again. When desiredSize is 0, it's possible that a pull() will happen immediately (but
	    // asynchronously) after this because of pending read()s and set _backpressure back to false.
	    //
	    // If pull() could be called from inside enqueue(), then this logic would be wrong. This cannot happen
	    // because there is always a promise pending from start() or pull() when _backpressure is false.
	    TransformStreamSetBackpressure(transformStream, true);
	  }
	}

	function TransformStreamError(transformStream, e) {
	  if (transformStream._errored === true) {
	    throw new TypeError('TransformStream is already errored');
	  }

	  TransformStreamErrorInternal(transformStream, e);
	}

	// Abstract operations.

	function TransformStreamCloseReadableInternal(transformStream) {
	  assert(transformStream._errored === false);
	  assert(transformStream._readableClosed === false);

	  try {
	    ReadableStreamDefaultControllerClose(transformStream._readableController);
	  } catch (e) {
	    assert(false);
	  }

	  transformStream._readableClosed = true;
	}

	function TransformStreamErrorIfNeeded(transformStream, e) {
	  if (transformStream._errored === false) {
	    TransformStreamErrorInternal(transformStream, e);
	  }
	}

	function TransformStreamErrorInternal(transformStream, e) {
	  // console.log('TransformStreamErrorInternal()');

	  assert(transformStream._errored === false);

	  transformStream._errored = true;
	  transformStream._storedError = e;

	  if (transformStream._writableDone === false) {
	    WritableStreamDefaultControllerError(transformStream._writableController, e);
	  }
	  if (transformStream._readableClosed === false) {
	    ReadableStreamDefaultControllerError(transformStream._readableController, e);
	  }
	}

	// Used for preventing the next write() call on TransformStreamSink until there
	// is no longer backpressure.
	function TransformStreamReadableReadyPromise(transformStream) {
	  assert(transformStream._backpressureChangePromise !== undefined,
	         '_backpressureChangePromise should have been initialized');

	  if (transformStream._backpressure === false) {
	    return Promise.resolve();
	  }

	  assert(transformStream._backpressure === true, '_backpressure should have been initialized');

	  return transformStream._backpressureChangePromise;
	}

	function TransformStreamSetBackpressure(transformStream, backpressure) {
	  // console.log(`TransformStreamSetBackpressure(${backpressure})`);

	  // Passes also when called during construction.
	  assert(transformStream._backpressure !== backpressure,
	         'TransformStreamSetBackpressure() should be called only when backpressure is changed');

	  if (transformStream._backpressureChangePromise !== undefined) {
	    // The fulfillment value is just for a sanity check.
	    transformStream._backpressureChangePromise_resolve(backpressure);
	  }

	  transformStream._backpressureChangePromise = new Promise(resolve => {
	    transformStream._backpressureChangePromise_resolve = resolve;
	  });

	  transformStream._backpressureChangePromise.then(resolution => {
	    assert(resolution !== backpressure,
	           '_backpressureChangePromise should be fulfilled only when backpressure is changed');
	  });

	  transformStream._backpressure = backpressure;
	}

	function TransformStreamDefaultTransform(chunk, transformStreamController) {
	  const transformStream = transformStreamController._controlledTransformStream;
	  TransformStreamEnqueueToReadable(transformStream, chunk);
	  return Promise.resolve();
	}

	function TransformStreamTransform(transformStream, chunk) {
	  // console.log('TransformStreamTransform()');

	  assert(transformStream._errored === false);
	  assert(transformStream._transforming === false);
	  assert(transformStream._backpressure === false);

	  transformStream._transforming = true;

	  const transformer = transformStream._transformer;
	  const controller = transformStream._transformStreamController;

	  const transformPromise = PromiseInvokeOrPerformFallback(transformer, 'transform', [chunk, controller],
	                             TransformStreamDefaultTransform, [chunk, controller]);

	  return transformPromise.then(
	    () => {
	      transformStream._transforming = false;

	      return TransformStreamReadableReadyPromise(transformStream);
	    },
	    e => TransformStreamErrorIfNeeded(transformStream, e));
	}

	function IsTransformStreamDefaultController(x) {
	  if (!typeIsObject(x)) {
	    return false;
	  }

	  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
	    return false;
	  }

	  return true;
	}

	function IsTransformStream(x) {
	  if (!typeIsObject(x)) {
	    return false;
	  }

	  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
	    return false;
	  }

	  return true;
	}

	class TransformStreamSink {
	  constructor(transformStream, startPromise) {
	    this._transformStream = transformStream;
	    this._startPromise = startPromise;
	  }

	  start(c) {
	    const transformStream = this._transformStream;

	    transformStream._writableController = c;

	    return this._startPromise.then(() => TransformStreamReadableReadyPromise(transformStream));
	  }

	  write(chunk) {
	    // console.log('TransformStreamSink.write()');

	    const transformStream = this._transformStream;

	    return TransformStreamTransform(transformStream, chunk);
	  }

	  abort() {
	    const transformStream = this._transformStream;
	    transformStream._writableDone = true;
	    TransformStreamErrorInternal(transformStream, new TypeError('Writable side aborted'));
	  }

	  close() {
	    // console.log('TransformStreamSink.close()');

	    const transformStream = this._transformStream;

	    assert(transformStream._transforming === false);

	    transformStream._writableDone = true;

	    const flushPromise = PromiseInvokeOrNoop(transformStream._transformer,
	                         'flush', [transformStream._transformStreamController]);
	    // Return a promise that is fulfilled with undefined on success.
	    return flushPromise.then(() => {
	      if (transformStream._errored === true) {
	        return Promise.reject(transformStream._storedError);
	      }
	      if (transformStream._readableClosed === false) {
	        TransformStreamCloseReadableInternal(transformStream);
	      }
	      return Promise.resolve();
	    }).catch(r => {
	      TransformStreamErrorIfNeeded(transformStream, r);
	      return Promise.reject(transformStream._storedError);
	    });
	  }
	}

	class TransformStreamSource {
	  constructor(transformStream, startPromise) {
	    this._transformStream = transformStream;
	    this._startPromise = startPromise;
	  }

	  start(c) {
	    const transformStream = this._transformStream;

	    transformStream._readableController = c;

	    return this._startPromise.then(() => {
	      // Prevent the first pull() call until there is backpressure.

	      assert(transformStream._backpressureChangePromise !== undefined,
	             '_backpressureChangePromise should have been initialized');

	      if (transformStream._backpressure === true) {
	        return Promise.resolve();
	      }

	      assert(transformStream._backpressure === false, '_backpressure should have been initialized');

	      return transformStream._backpressureChangePromise;
	    });
	  }

	  pull() {
	    // console.log('TransformStreamSource.pull()');

	    const transformStream = this._transformStream;

	    // Invariant. Enforced by the promises returned by start() and pull().
	    assert(transformStream._backpressure === true, 'pull() should be never called while _backpressure is false');

	    assert(transformStream._backpressureChangePromise !== undefined,
	           '_backpressureChangePromise should have been initialized');

	    TransformStreamSetBackpressure(transformStream, false);

	    // Prevent the next pull() call until there is backpressure.
	    return transformStream._backpressureChangePromise;
	  }

	  close() {
	    const transformStream = this._transformStream;
	    transformStream._readableClosed = true;
	    TransformStreamErrorInternal(transformStream, new TypeError('Readable side canceled'));
	  }
	}

	class TransformStreamDefaultController {
	  constructor(transformStream) {
	    if (IsTransformStream(transformStream) === false) {
	      throw new TypeError('TransformStreamDefaultController can only be ' +
	                          'constructed with a TransformStream instance');
	    }

	    if (transformStream._transformStreamController !== undefined) {
	      throw new TypeError('TransformStreamDefaultController instances can ' +
	                          'only be created by the TransformStream constructor');
	    }

	    this._controlledTransformStream = transformStream;
	  }

	  get desiredSize() {
	    if (IsTransformStreamDefaultController(this) === false) {
	      throw defaultControllerBrandCheckException('desiredSize');
	    }

	    const transformStream = this._controlledTransformStream;
	    const readableController = transformStream._readableController;

	    return ReadableStreamDefaultControllerGetDesiredSize(readableController);
	  }

	  enqueue(chunk) {
	    if (IsTransformStreamDefaultController(this) === false) {
	      throw defaultControllerBrandCheckException('enqueue');
	    }

	    TransformStreamEnqueueToReadable(this._controlledTransformStream, chunk);
	  }

	  close() {
	    if (IsTransformStreamDefaultController(this) === false) {
	      throw defaultControllerBrandCheckException('close');
	    }

	    TransformStreamCloseReadable(this._controlledTransformStream);
	  }

	  error(reason) {
	    if (IsTransformStreamDefaultController(this) === false) {
	      throw defaultControllerBrandCheckException('error');
	    }

	    TransformStreamError(this._controlledTransformStream, reason);
	  }
	}

	class TransformStream {
	  constructor(transformer = {}) {
	    this._transformer = transformer;
	    const { readableStrategy, writableStrategy } = transformer;

	    this._transforming = false;
	    this._errored = false;
	    this._storedError = undefined;

	    this._writableController = undefined;
	    this._readableController = undefined;
	    this._transformStreamController = undefined;

	    this._writableDone = false;
	    this._readableClosed = false;

	    this._backpressure = undefined;
	    this._backpressureChangePromise = undefined;
	    this._backpressureChangePromise_resolve = undefined;

	    this._transformStreamController = new TransformStreamDefaultController(this);

	    let startPromise_resolve;
	    const startPromise = new Promise(resolve => {
	      startPromise_resolve = resolve;
	    });

	    const source = new TransformStreamSource(this, startPromise);

	    this._readable = new ReadableStream(source, readableStrategy);

	    const sink = new TransformStreamSink(this, startPromise);

	    this._writable = new WritableStream(sink, writableStrategy);

	    assert(this._writableController !== undefined);
	    assert(this._readableController !== undefined);

	    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(this._readableController);
	    // Set _backpressure based on desiredSize. As there is no read() at this point, we can just interpret
	    // desiredSize being non-positive as backpressure.
	    TransformStreamSetBackpressure(this, desiredSize <= 0);

	    const transformStream = this;
	    const startResult = InvokeOrNoop(transformer, 'start',
	                          [transformStream._transformStreamController]);
	    startPromise_resolve(startResult);
	    startPromise.catch(e => {
	      // The underlyingSink and underlyingSource will error the readable and writable ends on their own.
	      if (transformStream._errored === false) {
	        transformStream._errored = true;
	        transformStream._storedError = e;
	      }
	    });
	  }

	  get readable() {
	    if (IsTransformStream(this) === false) {
	      throw streamBrandCheckException('readable');
	    }

	    return this._readable;
	  }

	  get writable() {
	    if (IsTransformStream(this) === false) {
	      throw streamBrandCheckException('writable');
	    }

	    return this._writable;
	  }
	}

	module.exports = { TransformStream };

	// Helper functions for the TransformStreamDefaultController.

	function defaultControllerBrandCheckException(name) {
	  return new TypeError(
	    `TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
	}

	// Helper functions for the TransformStream.

	function streamBrandCheckException(name) {
	  return new TypeError(
	    `TransformStream.prototype.${name} can only be used on a TransformStream`);
	}


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const std_1 = __webpack_require__(23);
	const utils_1 = __webpack_require__(32);
	class ChunkQueue {
	    constructor() {
	        this._reads = [];
	        this._writes = [];
	    }
	    push(value) {
	        if (this._reads.length) {
	            this._reads.shift()(value);
	            return Promise.resolve();
	        }
	        return new Promise((resolve, reject) => {
	            this._writes.push([value, resolve, reject]);
	        });
	    }
	    get size() {
	        return this._writes.length;
	    }
	    shift() {
	        if (this._writes.length) {
	            const [value, resolve] = this._writes.shift();
	            resolve();
	            return Promise.resolve(value);
	        }
	        return new Promise((resolve) => {
	            this._reads.push(resolve);
	        });
	    }
	    cancel(reason) {
	        const writes = this._writes.concat();
	        this._writes = [];
	        for (const [value, resolve, reject] of writes) {
	            reject(reason);
	        }
	    }
	}
	exports.ChunkQueue = ChunkQueue;
	class ReadableWritableStream {
	    constructor(stream) {
	        let readerController;
	        let writerController;
	        let cancelReason;
	        let abortReason;
	        let _writePromise = Promise.resolve();
	        const queue = new ChunkQueue();
	        const close = (reason) => {
	            queue.cancel(reason);
	            if (stream.$response.close) {
	                stream.$response.close(reason);
	            }
	        };
	        const output = this.readable = new std_1.ReadableStream({
	            start(controller) {
	                readerController = controller;
	            },
	            pull(controller) {
	                return queue.shift().then((value) => {
	                    readerController.enqueue(value);
	                });
	            },
	            cancel(reason) {
	                cancelReason = reason;
	                close(reason);
	            }
	        });
	        let inputAborted;
	        const input = this.writable = new std_1.WritableStream({
	            start(controller) {
	                writerController = controller;
	            },
	            write: (chunk) => {
	                // need to eat the chunk here. Streams will re-throw
	                // any exception that are occur in in sink.write()
	                if (cancelReason)
	                    return;
	                return _writePromise = queue.push(chunk);
	            },
	            close() {
	                if (cancelReason)
	                    return;
	                const close = () => {
	                    readerController.close();
	                };
	                return _writePromise.then(close, close);
	            },
	            abort(reason) {
	                if (cancelReason)
	                    return;
	                abortReason = reason;
	                readerController.error(reason);
	                close(reason);
	            }
	        });
	    }
	}
	function wrapDuplexStream(value) {
	    if (value && value.readable && value.writable) {
	        if (value.writable) {
	            return value;
	        }
	    }
	    if (value instanceof std_1.ReadableStream) {
	        const readable = value;
	        return new std_1.TransformStream({
	            start(controller) {
	                readable.pipeTo(new std_1.WritableStream({
	                    write(chunk) {
	                        controller.enqueue(chunk);
	                    },
	                    abort(error) {
	                        controller.error(error);
	                    },
	                    close() {
	                        controller.close();
	                    }
	                }));
	            }
	        });
	    }
	    return new std_1.TransformStream({
	        start(controller) {
	            return __awaiter(this, void 0, void 0, function* () {
	                const v = yield value;
	                if (v != null) {
	                    if (Array.isArray(v)) {
	                        v.forEach((i) => controller.enqueue(i));
	                    }
	                    else {
	                        controller.enqueue(v);
	                    }
	                }
	                controller.close();
	            });
	        }
	    });
	}
	exports.wrapDuplexStream = wrapDuplexStream;
	class DuplexStream {
	    constructor(handler) {
	        const input = this._input = new ReadableWritableStream(this);
	        const output = this._output = new ReadableWritableStream(this);
	        this.$response = handler(input.readable, output.writable) || {};
	    }
	    static empty() {
	        return new DuplexStream((input, output) => {
	            output.getWriter().close();
	        });
	    }
	    static fromArray(items) {
	        return new DuplexStream((input, output) => {
	            const writer = output.getWriter();
	            items.forEach(item => writer.write(item));
	            writer.close();
	        });
	    }
	    then(resolve, reject) {
	        return utils_1.readAllChunks(this).then(resolve, reject);
	    }
	    get writable() {
	        return this._input.writable;
	    }
	    get readable() {
	        return this._output.readable;
	    }
	}
	exports.DuplexStream = DuplexStream;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const std_1 = __webpack_require__(23);
	function readAllChunks(value) {
	    let readable = value.readable || value;
	    return new Promise((resolve, reject) => {
	        const result = [];
	        readable.pipeTo(new std_1.WritableStream({
	            write(chunk) {
	                result.push(chunk);
	            }
	        })).then(resolve.bind(this, result)).catch(reject);
	    });
	}
	exports.readAllChunks = readAllChunks;
	function readOneChunk(value) {
	    return __awaiter(this, void 0, void 0, function* () {
	        let readable = value.readable || value;
	        return yield readable.getReader().read();
	    });
	}
	exports.readOneChunk = readOneChunk;
	/**
	 * await pump(stream, this.onChunk)
	 */
	exports.pump = (reader, each) => __awaiter(this, void 0, void 0, function* () {
	    let value, done;
	    while ({ value, done } = yield reader.read()) {
	        if (done)
	            break;
	        yield each(value);
	    }
	});


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const proxy_1 = __webpack_require__(34);
	const callback_1 = __webpack_require__(20);
	const noop_1 = __webpack_require__(19);
	const streams_1 = __webpack_require__(22);
	const PASSED_THROUGH_KEY = "$$passedThrough";
	let _messageCount = 0;
	class RemoteBusMessage {
	    constructor(type, source, dest, payload) {
	        this.type = type;
	        this.source = source;
	        this.dest = dest;
	        this.payload = payload;
	        this.messageId = String(_messageCount++);
	    }
	    serialize(serializer) {
	        return [this.type, this.messageId, this.source, this.dest, serializer.serialize(this.payload)];
	    }
	    static deserialize([type, messageId, source, dests, payload], serializer) {
	        const message = new RemoteBusMessage(type, source, dests, serializer.deserialize(payload));
	        message.messageId = messageId;
	        return message;
	    }
	}
	RemoteBusMessage.HELLO = 0;
	RemoteBusMessage.DISPATCH = RemoteBusMessage.HELLO + 1;
	RemoteBusMessage.RESPONSE = RemoteBusMessage.DISPATCH + 1;
	RemoteBusMessage.CHUNK = RemoteBusMessage.RESPONSE + 1;
	RemoteBusMessage.RESOLVE = RemoteBusMessage.CHUNK + 1;
	RemoteBusMessage.REJECT = RemoteBusMessage.RESOLVE + 1;
	RemoteBusMessage.CLOSE = RemoteBusMessage.REJECT + 1;
	RemoteBusMessage.ABORT = RemoteBusMessage.CLOSE + 1;
	exports.RemoteBusMessage = RemoteBusMessage;
	const seed = fill0(Math.round(Math.random() * 100), 3);
	let _i = 0;
	const createUID = () => {
	    const now = new Date();
	    return `${seed}${fill0(now.getSeconds())}${_i++}`;
	};
	function fill0(num, min = 2) {
	    let buffer = "" + num;
	    while (buffer.length < min) {
	        buffer = "0" + buffer;
	    }
	    return buffer;
	}
	class RemoteConnection {
	    constructor(uid, adapter, _serializer, _onClose) {
	        this.uid = uid;
	        this.adapter = adapter;
	        this._serializer = _serializer;
	        this._onClose = _onClose;
	        this._dests = [];
	        this._pendingPromises = new Map();
	    }
	    addDest(dest) {
	        if (this._dests.indexOf(dest) !== -1)
	            return;
	        this._dests.push(dest);
	        const [spare, child] = this._spare.tee();
	        this._spare = spare;
	        child.pipeTo(new streams_1.WritableStream({
	            write: (chunk) => {
	                return this.send(new RemoteBusMessage(RemoteBusMessage.CHUNK, this.uid, dest, chunk));
	            },
	            close: () => {
	                this._closed = true;
	                return this.send(new RemoteBusMessage(RemoteBusMessage.CLOSE, this.uid, dest));
	            },
	            abort: (reason) => {
	                return this.send(new RemoteBusMessage(RemoteBusMessage.ABORT, this.uid, dest, reason));
	            },
	        })).catch((e) => {
	            this.send(new RemoteBusMessage(RemoteBusMessage.ABORT, this.uid, dest, e));
	        }).then(() => {
	            this._onClose();
	        });
	    }
	    start(readable, writable) {
	        this._spare = readable;
	        this.writer = writable.getWriter();
	    }
	    close(dest) {
	        const i = this._dests.indexOf(dest);
	        if (~i) {
	            this._dests.splice(i, 1);
	        }
	        else {
	            return;
	        }
	        if (this._dests.length)
	            return Promise.resolve();
	        return this.writer.close();
	    }
	    write(chunk) {
	        return this.writer.write(chunk);
	    }
	    abort(error) {
	        return this.writer.abort(error);
	    }
	    send(message) {
	        return new Promise((resolve, reject) => {
	            this._pendingPromises.set(message.messageId + message.dest, [resolve, reject]);
	            this.adapter.send(message.serialize(this._serializer));
	        });
	    }
	    resolve([pendingPromiseId, value]) {
	        const pendingPromise = this._pendingPromises.get(pendingPromiseId);
	        if (pendingPromise) {
	            this._pendingPromises.delete(pendingPromiseId);
	            pendingPromise[0](value);
	        }
	    }
	    reject([pendingPromiseId, value]) {
	        const pendingPromise = this._pendingPromises.get(pendingPromiseId);
	        if (pendingPromise) {
	            this._pendingPromises.delete(pendingPromiseId);
	            pendingPromise[1](value);
	        }
	    }
	}
	class RemoteBus {
	    constructor({ adapter, family, testMessage }, _localDispatcher = noop_1.noopDispatcherInstance, _serializer) {
	        this._localDispatcher = _localDispatcher;
	        this._serializer = _serializer;
	        this._pendingConnections = new Map();
	        this.adapter = adapter;
	        this._family = family;
	        this._uid = createUID();
	        if (!_serializer) {
	            this._serializer = {
	                serialize: o => o,
	                deserialize: i => i
	            };
	        }
	        this._proxy = new proxy_1.ProxyBus(new callback_1.CallbackDispatcher(this._dispatchRemoteMessage.bind(this)));
	        this._proxy.pause();
	        this._testMessage = testMessage || (message => true);
	        this.adapter.addListener(this.onMessage.bind(this));
	        this.greet(true);
	    }
	    testMessage(message) {
	        // return TRUE if dest family doesn't exist. Means that the handshake isn't finished yet.
	        return !this._destFamily || this._testMessage(message, this._family, this._destFamily);
	    }
	    dispose() {
	        for (const pending of this._pendingConnections.values()) {
	            pending.abort(new Error("disposed"));
	        }
	    }
	    greet(shouldSayHiBack) {
	        this.adapter.send(new RemoteBusMessage(RemoteBusMessage.HELLO, null, null, [this._family, shouldSayHiBack]).serialize(this._serializer));
	    }
	    onMessage(data) {
	        const message = RemoteBusMessage.deserialize(data, this._serializer);
	        // TODO - check if origin is coming from self. Need to update tests for this
	        if (message.type === RemoteBusMessage.DISPATCH) {
	            this.onDispatch(message);
	        }
	        else if (message.type === RemoteBusMessage.RESPONSE) {
	            this.onResponse(message);
	        }
	        else if (message.type === RemoteBusMessage.CHUNK) {
	            this.onChunk(message);
	        }
	        else if (message.type === RemoteBusMessage.CLOSE) {
	            this.onClose(message);
	        }
	        else if (message.type === RemoteBusMessage.ABORT) {
	            this.onAbort(message);
	        }
	        else if (message.type === RemoteBusMessage.RESOLVE) {
	            this.onResolve(message);
	        }
	        else if (message.type === RemoteBusMessage.REJECT) {
	            this.onReject(message);
	        }
	        else if (message.type === RemoteBusMessage.HELLO) {
	            this.onHello(message);
	        }
	    }
	    onResolve({ source, dest, payload }) {
	        const result = payload;
	        this._getConnection(dest, (con, uid) => con.resolve(result));
	    }
	    onHello({ payload: [family, shouldSayHiBack] }) {
	        this._destFamily = family;
	        if (shouldSayHiBack)
	            this.greet();
	        this._proxy.resume();
	    }
	    onReject({ source, dest, payload }) {
	        const reason = payload;
	        this._getConnection(dest, (con, uid) => con.reject(reason));
	    }
	    resolve(messageId, source, dest, result) {
	        this.adapter.send(new RemoteBusMessage(RemoteBusMessage.RESOLVE, source, dest, [messageId + source, result]).serialize(this._serializer));
	    }
	    reject(messageId, source, dest, reason) {
	        this.adapter.send(new RemoteBusMessage(RemoteBusMessage.REJECT, source, dest, [messageId + source, reason]).serialize(this._serializer));
	    }
	    onChunk({ messageId, source, dest, payload }) {
	        this._getConnection(dest, (con, uid) => this.respond(con.write(payload), messageId, uid, source));
	    }
	    onClose({ messageId, source, dest, payload }) {
	        this._getConnection(dest, (con, uid) => this.respond(con.close(source), messageId, uid, source));
	    }
	    respond(promise, messageId, source, dest) {
	        promise.then(this.resolve.bind(this, messageId, source, dest)).catch(this.reject.bind(this, messageId, source, dest));
	    }
	    onAbort({ messageId, source, dest, payload }) {
	        this._getConnection(dest, (con, uid) => this.respond(con.abort(payload), messageId, uid, source));
	    }
	    onDispatch({ payload, source, dest }) {
	        const targetDispatcher = this._shouldHandleMessage(payload) ? this._localDispatcher : noop_1.noopDispatcherInstance;
	        const con = new RemoteConnection(createUID(), this.adapter, this._serializer, () => {
	            this._pendingConnections.delete(con.uid);
	        });
	        this._pendingConnections.set(con.uid, con);
	        const { readable, writable } = streams_1.wrapDuplexStream(targetDispatcher.dispatch(payload));
	        con.start(readable, writable);
	        this.adapter.send(new RemoteBusMessage(RemoteBusMessage.RESPONSE, con.uid, source).serialize(this._serializer));
	        con.addDest(source);
	    }
	    onResponse({ source, dest }) {
	        this._getConnection(dest, (con, uid) => con.addDest(source));
	    }
	    _getConnection(uid, each) {
	        const con = this._pendingConnections.get(uid);
	        if (con)
	            each(con, uid);
	    }
	    _shouldHandleMessage(message) {
	        if (!message[PASSED_THROUGH_KEY]) {
	            message[PASSED_THROUGH_KEY] = {};
	        }
	        if (message[PASSED_THROUGH_KEY][this._uid])
	            return false;
	        return message[PASSED_THROUGH_KEY][this._uid] = true;
	    }
	    dispatch(message) {
	        return this._proxy.dispatch(message);
	    }
	    _dispatchRemoteMessage(message) {
	        return new streams_1.DuplexStream((input, output) => {
	            if (!this._shouldHandleMessage(message) || !this.testMessage(message)) {
	                return output.getWriter().close();
	            }
	            const con = new RemoteConnection(createUID(), this.adapter, this._serializer, () => {
	                this._pendingConnections.delete(con.uid);
	            });
	            this._pendingConnections.set(con.uid, con);
	            con.start(input, output);
	            this.adapter.send(new RemoteBusMessage(RemoteBusMessage.DISPATCH, con.uid, null, message).serialize(this._serializer));
	        });
	    }
	}
	exports.RemoteBus = RemoteBus;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const streams_1 = __webpack_require__(22);
	const base_1 = __webpack_require__(18);
	/**
	 * proxies a target bus, and queues actions
	 * if there is none until there is
	 */
	class ProxyBus {
	    constructor(_target) {
	        this._target = _target;
	        this._queue = [];
	    }
	    testMessage(message) {
	        return base_1.testDispatcherMessage(this._target, message);
	    }
	    dispatch(message) {
	        // no target? put the action in a queue until there is
	        if (this.paused) {
	            return new streams_1.DuplexStream((input, output) => {
	                this._queue.push({ message, input, output });
	            });
	        }
	        return streams_1.wrapDuplexStream(this.target.dispatch(message));
	    }
	    get paused() {
	        return this._paused || !this._target;
	    }
	    pause() {
	        this._paused = true;
	    }
	    resume() {
	        this._paused = false;
	        this._drain();
	    }
	    get target() {
	        return this._target;
	    }
	    set target(value) {
	        this._target = value;
	        // try draining the proxy now.
	        this._drain();
	    }
	    _drain() {
	        if (this.paused)
	            return;
	        const queue = this._queue.concat();
	        this._queue = [];
	        while (queue.length) {
	            const { input, output, message } = queue.shift();
	            streams_1.wrapDuplexStream(this.target.dispatch(message)).readable.pipeTo(output);
	        }
	    }
	}
	exports.ProxyBus = ProxyBus;


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const noop_1 = __webpack_require__(19);
	const streams_1 = __webpack_require__(22);
	class FilterBus {
	    constructor(testMessage, _resolvedTarget = noop_1.noopDispatcherInstance, _rejectedTarget = noop_1.noopDispatcherInstance) {
	        this.testMessage = testMessage;
	        this._resolvedTarget = _resolvedTarget;
	        this._rejectedTarget = _rejectedTarget;
	    }
	    dispatch(message) {
	        return streams_1.wrapDuplexStream((this.testMessage(message) ? this._resolvedTarget : this._rejectedTarget).dispatch(message));
	    }
	}
	exports.FilterBus = FilterBus;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	class Message {
	    constructor(type) {
	        this.type = type;
	    }
	}
	exports.Message = Message;
	__export(__webpack_require__(37));
	__export(__webpack_require__(38));


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const serialize_1 = __webpack_require__(11);
	const getMetadataKey = (name) => `message:${name}`;
	exports.defineMessageMetadata = (name, value) => {
	    return function (messageClass) {
	        Reflect.defineMetadata(getMetadataKey(name), value, messageClass);
	        if (!serialize_1.getSerializeType(messageClass)) {
	            serialize_1.serializable()(messageClass);
	        }
	        return messageClass;
	    };
	};
	exports.getMessageMetadata = (name, message) => {
	    const key = getMetadataKey(name);
	    return Reflect.getMetadata(key, message) || Reflect.getMetadata(key, message.constructor);
	};
	exports.setMessageTarget = (family) => {
	    return exports.defineMessageMetadata("target", family);
	};
	exports.getMessageTarget = (message) => {
	    return exports.getMessageMetadata("target", message);
	};
	exports.getMessageVisitors = (message) => {
	    return exports.getMessageMetadata("visitors", message) || [];
	};
	exports.addMessageVisitor = (...families) => {
	    return function (message) {
	        Reflect.defineMetadata(getMetadataKey("visitors"), (exports.getMessageMetadata("visitors", message) || []).concat(families), message);
	    };
	};


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const decorators_1 = __webpack_require__(37);
	exports.filterFamilyMessage = (message, fromFamily, toFamily) => {
	    const targetFamily = decorators_1.getMessageTarget(message);
	    const visitorFamilies = decorators_1.getMessageVisitors(message);
	    // Rules:
	    // 1. Target family must be defined, otherwise the message is private.
	    // 2. If the dispatcher of this message is part of the same family as the target, then return false.
	    // 3. If the target family is equal to the destination family, then return true.
	    // 4. If the message is only visiting the target family (meaning that there's another remote bus through the visitor), then return true.
	    const passes = !!((targetFamily || visitorFamilies.length) && targetFamily !== fromFamily && (targetFamily === toFamily || visitorFamilies.indexOf(toFamily) !== -1));
	    // console.log(message.type, fromFamily, toFamily, targetFamily, visitorFamilies, passes);
	    return passes;
	};


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(40));


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const core_1 = __webpack_require__(14);
	class SocketIOBus {
	    constructor({ family, channel, connection, testMessage }, localBus, serializer) {
	        if (!channel)
	            channel = "o";
	        this._target = new core_1.RemoteBus({
	            family: family,
	            testMessage: testMessage,
	            adapter: {
	                send(message) {
	                    connection.emit(channel, message);
	                },
	                addListener(listener) {
	                    connection.on(channel, listener);
	                }
	            }
	        }, localBus, serializer);
	    }
	    testMessage(message) {
	        return this._target.testMessage(message);
	    }
	    dispatch(message) {
	        return this._target.dispatch(message);
	    }
	    dispose() {
	        this._target.dispose();
	    }
	}
	exports.SocketIOBus = SocketIOBus;


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(42));
	// export * from "./mongo";
	__export(__webpack_require__(45));


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const sift = __webpack_require__(43);
	const base_1 = __webpack_require__(44);
	const core_1 = __webpack_require__(14);
	class MemoryDataStore extends base_1.BaseDataStore {
	    constructor() {
	        super();
	        this._data = {};
	    }
	    dsFind({ type, collectionName, query }) {
	        const found = this.getCollection(collectionName).find(sift(query));
	        return core_1.DuplexStream.fromArray(found ? [found] : []);
	    }
	    dsInsert({ type, collectionName, data }) {
	        let ret = JSON.parse(JSON.stringify(data));
	        ret = Array.isArray(ret) ? ret : [ret];
	        this.getCollection(collectionName).push(...ret);
	        return core_1.DuplexStream.fromArray(ret);
	    }
	    dsRemove({ type, collectionName, query }) {
	        const collection = this.getCollection(collectionName);
	        const filter = sift(query);
	        const ret = [];
	        for (let i = collection.length; i--;) {
	            const item = collection[i];
	            if (filter(item)) {
	                ret.push(item);
	                collection.splice(i, 1);
	            }
	        }
	        return core_1.DuplexStream.fromArray(ret);
	    }
	    dsUpdate({ type, collectionName, query, data }) {
	        const collection = this.getCollection(collectionName);
	        const filter = sift(query);
	        const ret = [];
	        for (let i = collection.length; i--;) {
	            const item = collection[i];
	            if (filter(item)) {
	                Object.assign(item, JSON.parse(JSON.stringify(data)));
	                ret.push(item);
	            }
	        }
	        return core_1.DuplexStream.fromArray(ret);
	    }
	    getCollection(collectionName) {
	        return this._data[collectionName] || (this._data[collectionName] = []);
	    }
	}
	exports.MemoryDataStore = MemoryDataStore;


/***/ },
/* 43 */
/***/ function(module, exports) {

	module.exports = require("sift");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const core_1 = __webpack_require__(14);
	const core_2 = __webpack_require__(14);
	class BaseDataStore {
	    constructor() {
	        this._proxy = new core_1.ProxyBus({
	            dispatch: (message) => {
	                const method = this[message.type];
	                if (method) {
	                    return new core_2.DuplexStream((input, output) => {
	                        core_2.wrapDuplexStream(method.call(this, message)).readable.pipeTo(output);
	                    });
	                }
	                return core_2.DuplexStream.empty();
	            }
	        });
	        this._proxy.pause();
	        setImmediate(this.initialize.bind(this));
	    }
	    dispatch(message) {
	        return this._proxy.dispatch(message);
	    }
	    initialize() {
	        return __awaiter(this, void 0, void 0, function* () {
	            yield this.connect();
	            this._proxy.resume();
	        });
	    }
	    connect() {
	        return __awaiter(this, void 0, void 0, function* () { });
	    }
	}
	exports.BaseDataStore = BaseDataStore;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const core_1 = __webpack_require__(14);
	const sift = __webpack_require__(43);
	class DSMessage {
	    constructor(type, collectionName) {
	        this.type = type;
	        this.collectionName = collectionName;
	        this.timestamp = Date.now();
	    }
	}
	exports.DSMessage = DSMessage;
	class DSInsertRequest extends DSMessage {
	    constructor(collectionName, data) {
	        super(DSInsertRequest.DS_INSERT, collectionName);
	        this.data = data;
	    }
	    static dispatch(collectionName, data, dispatcher) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return yield core_1.readAllChunks(dispatcher.dispatch(new DSInsertRequest(collectionName, data)));
	        });
	    }
	}
	DSInsertRequest.DS_INSERT = "dsInsert";
	exports.DSInsertRequest = DSInsertRequest;
	class DSUpdateRequest extends DSMessage {
	    constructor(collectionName, data, query) {
	        super(DSUpdateRequest.DS_UPDATE, collectionName);
	        this.data = data;
	        this.query = query;
	    }
	    static dispatch(collectionName, data, query, dispatcher) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return yield core_1.readAllChunks(dispatcher.dispatch(new DSUpdateRequest(collectionName, data, query)));
	        });
	    }
	}
	DSUpdateRequest.DS_UPDATE = "dsUpdate";
	exports.DSUpdateRequest = DSUpdateRequest;
	class DSFindRequest extends DSMessage {
	    constructor(collectionName, query, multi = false) {
	        super(DSFindRequest.DS_FIND, collectionName);
	        this.query = query;
	        this.multi = multi;
	    }
	    static createFilter(collectionName) {
	        return sift({ collectionName: collectionName });
	    }
	    static findOne(collectionName, query, dispatcher) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return (yield core_1.readOneChunk(dispatcher.dispatch(new DSFindRequest(collectionName, query, true)))).value;
	        });
	    }
	    static findMulti(collectionName, query, dispatcher) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return yield core_1.readAllChunks(dispatcher.dispatch(new DSFindRequest(collectionName, query, true)));
	        });
	    }
	}
	DSFindRequest.DS_FIND = "dsFind";
	exports.DSFindRequest = DSFindRequest;
	class DSFindAllRequest extends DSFindRequest {
	    constructor(collectionName) {
	        super(collectionName, {}, true);
	    }
	}
	exports.DSFindAllRequest = DSFindAllRequest;
	class DSRemoveRequest extends DSMessage {
	    constructor(collectionName, query) {
	        super(DSRemoveRequest.DS_REMOVE, collectionName);
	        this.query = query;
	    }
	}
	DSRemoveRequest.DS_REMOVE = "dsRemove";
	exports.DSRemoveRequest = DSRemoveRequest;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(47));
	__export(__webpack_require__(51));
	__export(__webpack_require__(52));
	__export(__webpack_require__(57));
	__export(__webpack_require__(59));
	__export(__webpack_require__(67));
	__export(__webpack_require__(67));
	__export(__webpack_require__(69));
	__export(__webpack_require__(54));
	__export(__webpack_require__(79));
	__export(__webpack_require__(84));
	__export(__webpack_require__(90));
	__export(__webpack_require__(140));
	__export(__webpack_require__(142));
	__export(__webpack_require__(73));
	__export(__webpack_require__(91));
	__export(__webpack_require__(144));
	__export(__webpack_require__(144));
	__export(__webpack_require__(11));
	__export(__webpack_require__(146));
	__export(__webpack_require__(147));
	__export(__webpack_require__(152));
	__export(__webpack_require__(156));
	__export(__webpack_require__(96));
	__export(__webpack_require__(160));
	__export(__webpack_require__(162));
	__export(__webpack_require__(163));
	__export(__webpack_require__(164));


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const base_1 = __webpack_require__(48);
	__export(__webpack_require__(48));
	__export(__webpack_require__(49));
	__export(__webpack_require__(50));
	class ActiveRecordEvent extends base_1.CoreEvent {
	}
	ActiveRecordEvent.ACTIVE_RECORD_DESERIALIZED = "activeRecordDeserialized";
	exports.ActiveRecordEvent = ActiveRecordEvent;


/***/ },
/* 48 */
/***/ function(module, exports) {

	/*
	TODOS:
	- cancelable actions
	- bubbleable actions
	*/
	"use strict";
	class CoreEvent {
	    constructor(type, bubbles = true) {
	        this.type = type;
	        this.bubbles = bubbles;
	        this._canPropagate = true;
	        this._canPropagateImmediately = true;
	    }
	    set currentTarget(value) {
	        // always maintain the initial target so that actions
	        // can be tracked back to their origin
	        if (!this._target) {
	            this._target = value;
	        }
	        this._currentTarget = value;
	    }
	    // TODO - target is not an appropriate name in some cases since
	    // the term refers to the current dispatcher dispatching *this* action. And in some cases,
	    // the target may not exist
	    get target() {
	        return this._target;
	    }
	    get currentTarget() {
	        return this._currentTarget;
	    }
	    get canPropagate() {
	        return this._canPropagate;
	    }
	    get canPropagateImmediately() {
	        return this._canPropagateImmediately;
	    }
	    stopPropagation() {
	        this._canPropagate = false;
	    }
	    stopImmediatePropagation() {
	        this._canPropagateImmediately = false;
	    }
	}
	exports.CoreEvent = CoreEvent;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const base_1 = __webpack_require__(48);
	exports.CoreEvent = base_1.CoreEvent;
	const ds_1 = __webpack_require__(41);
	const mesh_1 = __webpack_require__(13);
	class DisposeEvent extends base_1.CoreEvent {
	    constructor() {
	        super(DisposeEvent.DISPOSE);
	    }
	}
	DisposeEvent.DISPOSE = "dispose";
	exports.DisposeEvent = DisposeEvent;
	class LoadApplicationRequest extends mesh_1.Message {
	    constructor() {
	        super(LoadApplicationRequest.LOAD);
	    }
	}
	LoadApplicationRequest.LOAD = "loadApplication";
	exports.LoadApplicationRequest = LoadApplicationRequest;
	class InitializeApplicationRequest extends mesh_1.Message {
	    constructor() {
	        super(InitializeApplicationRequest.INITIALIZE);
	    }
	}
	InitializeApplicationRequest.INITIALIZE = "initializeApplication";
	exports.InitializeApplicationRequest = InitializeApplicationRequest;
	class ApplicationReadyMessage extends mesh_1.Message {
	    constructor() {
	        super(ApplicationReadyMessage.READY);
	    }
	}
	ApplicationReadyMessage.READY = "applicationReady";
	exports.ApplicationReadyMessage = ApplicationReadyMessage;
	class DSUpsertRequest extends ds_1.DSMessage {
	    constructor(collectionName, data, query) {
	        super(DSUpsertRequest.DS_UPSERT, collectionName);
	        this.data = data;
	        this.query = query;
	    }
	}
	DSUpsertRequest.DS_UPSERT = "dsUpsert";
	exports.DSUpsertRequest = DSUpsertRequest;
	class PostDSMessage extends ds_1.DSMessage {
	    constructor(type, collectionName, data, timestamp) {
	        super(type, collectionName);
	        this.data = data;
	        this.timestamp = timestamp;
	    }
	    static createFromDSRequest(request, data) {
	        return new PostDSMessage({
	            [ds_1.DSInsertRequest.DS_INSERT]: PostDSMessage.DS_DID_INSERT,
	            [ds_1.DSUpdateRequest.DS_UPDATE]: PostDSMessage.DS_DID_UPDATE,
	            [ds_1.DSRemoveRequest.DS_REMOVE]: PostDSMessage.DS_DID_REMOVE
	        }[request.type], request.collectionName, data, request.timestamp);
	    }
	}
	PostDSMessage.DS_DID_INSERT = "dsDidInsert";
	PostDSMessage.DS_DID_REMOVE = "dsDidRemove";
	PostDSMessage.DS_DID_UPDATE = "dsDidUpdate";
	exports.PostDSMessage = PostDSMessage;
	class MetadataChangeEvent extends base_1.CoreEvent {
	    constructor(key, value) {
	        super(MetadataChangeEvent.METADATA_CHANGE);
	        this.key = key;
	        this.value = value;
	    }
	}
	MetadataChangeEvent.METADATA_CHANGE = "metadataChange";
	exports.MetadataChangeEvent = MetadataChangeEvent;


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const base_1 = __webpack_require__(48);
	const serialize_1 = __webpack_require__(11);
	let Mutation_1 = class Mutation {
	    constructor(type, target) {
	        this.type = type;
	        this.target = target;
	    }
	    toString() {
	        return `${this.constructor.name}(${this.paramsToString()})`;
	    }
	    paramsToString() {
	        // target is omitted here since you can inspect the *actual* target by providing an "each" function
	        // for the synthetic object editor, and logging the target object there.
	        return `${this.type}`;
	    }
	    toEvent(bubbles) {
	        return new MutationEvent(this, bubbles);
	    }
	};
	let Mutation = Mutation_1;
	Mutation = Mutation_1 = __decorate([
	    serialize_1.serializable({
	        serialize({ type, target }) {
	            return [type, serialize_1.serialize(target && (target.clone ? target.clone(false) : target))];
	        },
	        deserialize([type, target], injector) {
	            return new Mutation(type, serialize_1.deserialize(target, injector));
	        }
	    })
	], Mutation);
	exports.Mutation = Mutation;
	class MutationEvent extends base_1.CoreEvent {
	    constructor(mutation, bubbles) {
	        super(MutationEvent.MUTATION, bubbles);
	        this.mutation = mutation;
	    }
	}
	MutationEvent.MUTATION = "mutation";
	exports.MutationEvent = MutationEvent;
	let SetValueMutation_1 = class SetValueMutation extends Mutation {
	    constructor(type, target, newValue) {
	        super(type, target);
	        this.newValue = newValue;
	    }
	    paramsToString() {
	        return `${super.paramsToString()}, ${this.newValue}`;
	    }
	};
	let SetValueMutation = SetValueMutation_1;
	SetValueMutation = SetValueMutation_1 = __decorate([
	    serialize_1.serializable({
	        serialize({ type, target, newValue }) {
	            return [type, serialize_1.serialize(target.clone(false)), newValue];
	        },
	        deserialize([type, target, newValue], injector) {
	            return new SetValueMutation(type, serialize_1.deserialize(target, injector), newValue);
	        }
	    })
	], SetValueMutation);
	exports.SetValueMutation = SetValueMutation;
	class ChildMutation extends Mutation {
	    constructor(type, target, child, index) {
	        super(type, target);
	        this.child = child;
	        this.index = index;
	    }
	    paramsToString() {
	        return `${super.paramsToString()}, ${this.child.toString().replace(/[\n\r\s\t]+/g, " ")}`;
	    }
	}
	exports.ChildMutation = ChildMutation;
	// TODO - change index to newIndex 
	let InsertChildMutation_1 = class InsertChildMutation extends ChildMutation {
	    constructor(type, target, child, index = Number.MAX_SAFE_INTEGER) {
	        super(type, target, child, index);
	    }
	    paramsToString() {
	        return `${super.paramsToString()}, ${this.index}`;
	    }
	};
	let InsertChildMutation = InsertChildMutation_1;
	InsertChildMutation = InsertChildMutation_1 = __decorate([
	    serialize_1.serializable({
	        serialize({ type, target, child, index }) {
	            return [type, serialize_1.serialize(target.clone(false)), serialize_1.serialize(child), index];
	        },
	        deserialize([type, target, child, index], injector) {
	            return new InsertChildMutation(type, serialize_1.deserialize(target, injector), serialize_1.deserialize(child, injector), index);
	        }
	    })
	], InsertChildMutation);
	exports.InsertChildMutation = InsertChildMutation;
	let RemoveChildMutation_1 = class RemoveChildMutation extends ChildMutation {
	    constructor(type, target, child, index) {
	        super(type, target, child, index);
	    }
	};
	let RemoveChildMutation = RemoveChildMutation_1;
	RemoveChildMutation = RemoveChildMutation_1 = __decorate([
	    serialize_1.serializable({
	        serialize({ type, target, child, index }) {
	            return [type, serialize_1.serialize(target.clone(false)), serialize_1.serialize(child.clone(false)), index];
	        },
	        deserialize([type, target, child, index], injector) {
	            return new RemoveChildMutation(type, serialize_1.deserialize(target, injector), serialize_1.deserialize(child, injector), index);
	        }
	    })
	], RemoveChildMutation);
	exports.RemoveChildMutation = RemoveChildMutation;
	let PropertyMutation_1 = class PropertyMutation extends Mutation {
	    constructor(type, target, name, newValue, oldValue, oldName, index) {
	        super(type, target);
	        this.name = name;
	        this.newValue = newValue;
	        this.oldValue = oldValue;
	        this.oldName = oldName;
	        this.index = index;
	    }
	    toEvent(bubbles = false) {
	        return new MutationEvent(this, bubbles);
	    }
	    paramsToString() {
	        return `${super.paramsToString()}, ${this.name}, ${this.newValue}`;
	    }
	};
	let PropertyMutation = PropertyMutation_1;
	PropertyMutation.PROPERTY_CHANGE = "propertyChange";
	PropertyMutation = PropertyMutation_1 = __decorate([
	    serialize_1.serializable({
	        serialize({ type, target, name, newValue, oldValue, oldName, index }) {
	            return [
	                type,
	                serialize_1.serialize(target.clone ? target.clone(false) : target),
	                name,
	                serialize_1.serialize(newValue),
	                serialize_1.serialize(oldValue),
	                oldName,
	                index];
	        },
	        deserialize([type, target, name, newValue, oldValue, oldName, index], injector) {
	            return new PropertyMutation(type, serialize_1.deserialize(target, injector), name, serialize_1.deserialize(newValue, injector), serialize_1.deserialize(oldValue, injector), oldName, index);
	        }
	    })
	], PropertyMutation);
	exports.PropertyMutation = PropertyMutation;
	/**
	 * Removes the target synthetic object
	 */
	class RemoveMutation extends Mutation {
	    constructor(target) {
	        super(RemoveMutation.REMOVE_CHANGE, target);
	    }
	}
	RemoveMutation.REMOVE_CHANGE = "removeChange";
	exports.RemoveMutation = RemoveMutation;
	// TODO - change oldIndex to index, and index to newIndex
	let MoveChildMutation_1 = class MoveChildMutation extends ChildMutation {
	    constructor(type, target, child, oldIndex, index) {
	        super(type, target, child, index);
	        this.oldIndex = oldIndex;
	    }
	    paramsToString() {
	        return `${super.paramsToString()}, ${this.index}`;
	    }
	};
	let MoveChildMutation = MoveChildMutation_1;
	MoveChildMutation = MoveChildMutation_1 = __decorate([
	    serialize_1.serializable({
	        serialize({ type, target, child, index, oldIndex }) {
	            return [type, serialize_1.serialize(target), serialize_1.serialize(child.clone(false)), oldIndex, index];
	        },
	        deserialize([type, target, child, index, oldIndex], injector) {
	            return new MoveChildMutation(type, serialize_1.deserialize(target, injector), serialize_1.deserialize(child, injector), oldIndex, index);
	        }
	    })
	], MoveChildMutation);
	exports.MoveChildMutation = MoveChildMutation;


/***/ },
/* 51 */
/***/ function(module, exports) {

	"use strict";
	function tween(start, end, duration, iterate, ease = easeNone, complete = () => { }) {
	    const change = end - start;
	    const startTime = Date.now();
	    const fps = 1000 / 30;
	    let _break = false;
	    function tick() {
	        if (_break)
	            return;
	        const currentTime = Math.min(Date.now() - startTime, duration);
	        const currentValue = start + change * ease(currentTime / duration);
	        iterate(currentValue);
	        if (currentTime === duration) {
	            return complete();
	        }
	        setTimeout(tick, fps);
	    }
	    tick();
	    return {
	        dispose() {
	            _break = true;
	        }
	    };
	}
	exports.tween = tween;
	function easeInCubic(t) {
	    return t * t * t;
	}
	exports.easeInCubic = easeInCubic;
	function easeNone(t) {
	    return t;
	}
	exports.easeNone = easeNone;
	function easeOutCubic(t) {
	    return (--t) * t * t + 1;
	}
	exports.easeOutCubic = easeOutCubic;


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(53));


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const messages_1 = __webpack_require__(47);
	const ioc_1 = __webpack_require__(54);
	/**
	 */
	class Application {
	    constructor(injector) {
	        this.injector = injector;
	        this.bus = ioc_1.PrivateBusProvider.getInstance(injector);
	    }
	    /**
	     * Bootstraps the application
	     */
	    initialize() {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (this._initialized) {
	                throw new Error(`Attempting to initialize the application after it's already been initialized.`);
	            }
	            this._initialized = true;
	            this.willLoad();
	            // Prepare the application for initialization. Injector that
	            // need to be loaded before being used by other injector should listen on this action
	            // here.
	            yield this.bus.dispatch(new messages_1.LoadApplicationRequest());
	            this.didLoad();
	            this.willInitialize();
	            // Notify the application that everything is ready
	            yield this.bus.dispatch(new messages_1.InitializeApplicationRequest());
	            yield this.bus.dispatch(new messages_1.ApplicationReadyMessage());
	            this.didInitialize();
	        });
	    }
	    /**
	     */
	    willLoad() {
	        // OVRRIDE ME
	    }
	    /**
	     */
	    didLoad() {
	        // OVERRIDE ME
	    }
	    /**
	     */
	    willInitialize() {
	        // OVERRIDE ME
	    }
	    /**
	     */
	    didInitialize() {
	        // OVERRIDE ME
	    }
	}
	exports.Application = Application;


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const base_1 = __webpack_require__(55);
	// TODO - add more static find methods to each Provider here
	__export(__webpack_require__(55));
	/**
	 */
	class ApplicationServiceProvider extends base_1.ClassFactoryProvider {
	    constructor(id, clazz) {
	        super(`${ApplicationServiceProvider.NS}/${id}`, clazz);
	    }
	    create() {
	        return super.create();
	    }
	    static findAll(Injector) {
	        return Injector.queryAll(`${ApplicationServiceProvider.NS}/**`);
	    }
	}
	ApplicationServiceProvider.NS = "application/services";
	exports.ApplicationServiceProvider = ApplicationServiceProvider;
	/**
	 */
	function createSingletonBusProviderClass(name) {
	    const id = ["bus", name].join("/");
	    return (BusProvider_1 = class BusProvider extends base_1.Provider {
	            constructor(bus) {
	                super(id, bus);
	            }
	            static getInstance(providers) {
	                return providers.query(id).value;
	            }
	        },
	        BusProvider_1.ID = id,
	        BusProvider_1);
	    var BusProvider_1;
	}
	exports.createSingletonBusProviderClass = createSingletonBusProviderClass;
	/**
	 * Private bus that can only be used within the application. This typically contains messages
	 * that are junk for other outside resources.
	 *
	 * Bubbles messages to the protected bus.
	 */
	exports.PrivateBusProvider = createSingletonBusProviderClass("private");
	/**
	 */
	class InjectorProvider extends base_1.Provider {
	    constructor() {
	        super(InjectorProvider.ID, null);
	    }
	    clone() {
	        return new InjectorProvider();
	    }
	    get owner() {
	        return this.value;
	    }
	    set owner(value) {
	        this.value = value;
	    }
	}
	InjectorProvider.ID = "providers";
	exports.InjectorProvider = InjectorProvider;
	/**
	 */
	class CommandFactoryProvider extends base_1.ClassFactoryProvider {
	    constructor(actionFilter, clazz) {
	        super([CommandFactoryProvider.NS, clazz.name].join("/"), clazz);
	        this.clazz = clazz;
	        if (typeof actionFilter === "string") {
	            this.actionFilter = (action) => action.type === actionFilter;
	        }
	        else {
	            this.actionFilter = actionFilter;
	        }
	    }
	    create() {
	        return super.create();
	    }
	    static findAll(providers) {
	        return providers.queryAll([CommandFactoryProvider.NS, "**"].join("/"));
	    }
	    static findAllByAction(action, providers) {
	        return this.findAll(providers).filter((dep) => dep.actionFilter(action));
	    }
	    clone() {
	        return new CommandFactoryProvider(this.actionFilter, this.clazz);
	    }
	}
	CommandFactoryProvider.NS = "commands";
	exports.CommandFactoryProvider = CommandFactoryProvider;
	/**
	 */
	class MimeTypeProvider extends base_1.Provider {
	    constructor(fileExtension, mimeType) {
	        super([MimeTypeProvider.NS, fileExtension].join("/"), mimeType);
	        this.fileExtension = fileExtension;
	        this.mimeType = mimeType;
	    }
	    clone() {
	        return new MimeTypeProvider(this.fileExtension, this.mimeType);
	    }
	    static findAll(providers) {
	        return providers.queryAll([MimeTypeProvider.NS, "**"].join("/"));
	    }
	    static lookup(filePath, providers) {
	        const extension = filePath.split(".").pop();
	        const dep = providers.query([MimeTypeProvider.NS, extension].join("/"));
	        return dep ? dep.value : undefined;
	    }
	}
	MimeTypeProvider.NS = "mimeType";
	exports.MimeTypeProvider = MimeTypeProvider;
	class MimeTypeAliasProvider extends base_1.Provider {
	    constructor(mimeType, aliasMimeType) {
	        super(MimeTypeAliasProvider.getNamespace(mimeType), aliasMimeType);
	        this.mimeType = mimeType;
	        this.aliasMimeType = aliasMimeType;
	    }
	    clone() {
	        return new MimeTypeAliasProvider(this.mimeType, this.aliasMimeType);
	    }
	    static getNamespace(mimeType) {
	        return [MimeTypeAliasProvider.NS, mimeType].join("/");
	    }
	    static lookup(filePathOrMimeType, providers) {
	        const mimeType = MimeTypeProvider.lookup(filePathOrMimeType, providers);
	        const dep = (mimeType && providers.query(this.getNamespace(mimeType))) || providers.query(this.getNamespace(filePathOrMimeType));
	        return (dep && dep.value) || mimeType || filePathOrMimeType;
	    }
	}
	MimeTypeAliasProvider.NS = "mimeTypeAliases";
	exports.MimeTypeAliasProvider = MimeTypeAliasProvider;
	class StoreProvider {
	    constructor(name, _clazz) {
	        this.name = name;
	        this._clazz = _clazz;
	        this.overridable = false;
	        this.id = StoreProvider.getId(name);
	    }
	    get value() {
	        return this._value || (this._value = new this._clazz());
	    }
	    clone() {
	        return new StoreProvider(this.name, this._clazz);
	    }
	    static getId(name) {
	        return [this.NS, name].join("/");
	    }
	}
	StoreProvider.NS = "store";
	exports.StoreProvider = StoreProvider;
	function createSingletonProviderClass(id) {
	    return (SingletonProvider_1 = class SingletonProvider {
	            constructor(clazz) {
	                this.overridable = false;
	                this.id = id;
	                this._clazz = clazz;
	            }
	            get value() {
	                return this._value || (this._value = this.owner.create(this._clazz, []));
	            }
	            clone() {
	                return new SingletonProvider(this._clazz);
	            }
	            static getInstance(providers) {
	                const dep = providers.query(id);
	                return dep ? dep.value : undefined;
	            }
	        },
	        SingletonProvider_1.ID = id,
	        SingletonProvider_1);
	    var SingletonProvider_1;
	}
	exports.createSingletonProviderClass = createSingletonProviderClass;


/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const lodash_1 = __webpack_require__(56);
	const assert = __webpack_require__(25);
	class Provider {
	    constructor(id, value, overridable = true) {
	        this.id = id;
	        this.value = value;
	        this.overridable = overridable;
	    }
	    /**
	     * Clones the dependency - works with base classes.
	     */
	    clone() {
	        const constructor = this.constructor;
	        const clone = new constructor(this.id, this.value);
	        // ns might not match up -- since it's common for constructors
	        // to prefix the ns before calling super. This fixes that specific
	        // case
	        clone.id = this.id;
	        clone.value = this.value;
	        clone.overridable = this.overridable;
	        return clone;
	    }
	}
	exports.Provider = Provider;
	/**
	 * Factory Provider for creating new instances of things
	 */
	class FactoryProvider extends Provider {
	    create(...rest) {
	        return this.owner.inject(this.value.create(...rest));
	    }
	}
	exports.FactoryProvider = FactoryProvider;
	/**
	 * factory Provider for classes
	 */
	class ClassFactoryProvider extends Provider {
	    constructor(id, clazz) {
	        super(id, clazz);
	        this.clazz = clazz;
	        assert(clazz, `Class must be defined for ${id}.`);
	    }
	    create(...rest) {
	        return this.owner.create(this.clazz, rest);
	    }
	}
	exports.ClassFactoryProvider = ClassFactoryProvider;
	/**
	 * Contains a collection of Injector
	 */
	class Injector {
	    constructor(...items) {
	        this._providersByNs = {};
	        this.register(...items);
	    }
	    /**
	     */
	    get length() {
	        return this.queryAll("/**").length;
	    }
	    /**
	     * Queries for one Provider with the given namespace
	     * @param {string} ns namespace to query.
	     */
	    query(ns) {
	        return this.queryAll(ns)[0];
	    }
	    /**
	     * queries for all Injector with the given namespace
	     */
	    queryAll(ns) {
	        return (this._providersByNs[ns] || []);
	    }
	    /**
	     */
	    link(dependency) {
	        dependency.owner = this;
	        return dependency;
	    }
	    /**
	     */
	    clone() {
	        return new Injector(...this.queryAll("/**"));
	    }
	    /**
	     */
	    inject(instance) {
	        const values = this.getPropertyValues(instance);
	        for (const property in values) {
	            instance[property] = values[property];
	        }
	        if (instance.$didInject) {
	            instance.$didInject();
	        }
	        return instance;
	    }
	    /**
	     */
	    create(clazz, parameters) {
	        const values = this.getPropertyValues(clazz);
	        for (const property in values) {
	            if (parameters[property] == null) {
	                parameters[property] = values[property];
	            }
	        }
	        return this.inject(new clazz(...parameters));
	    }
	    /**
	     */
	    register(...providers) {
	        const flattenedProviders = lodash_1.flattenDeep(providers);
	        for (let dependency of flattenedProviders) {
	            // Injector collection? Merge it into this one.
	            if (dependency instanceof Injector) {
	                this.register(...dependency.queryAll("/**"));
	                continue;
	            }
	            // need to clone the dependency in casse it's part of any other
	            // dependency collection, or even a singleton -- this is particularly required for features
	            // such as dependency injection.
	            dependency = dependency.clone();
	            let existing;
	            // check if the Provider already exists to ensure that there are no collisions
	            if (existing = this._providersByNs[dependency.id]) {
	                if (!existing[0].overridable) {
	                    throw new Error(`Provider with namespace "${dependency.id}" already exists.`);
	                }
	            }
	            // ref back so that the dependency can fetch additional information
	            // for dependency injection. this line is
	            this.link(dependency);
	            // the last part of the namespace is the unique id. Example namespaces:
	            // entities/text, entitiesControllers/div, components/item
	            this._providersByNs[dependency.id] = [dependency];
	            // store the Provider in a spot where it can be queried with globs (**).
	            // This is much faster than parsing this stuff on the fly when calling query()
	            const nsParts = dependency.id.split("/");
	            for (let i = 0, n = nsParts.length; i < n; i++) {
	                const ns = nsParts.slice(0, i).join("/") + "/**";
	                if (!this._providersByNs[ns]) {
	                    this._providersByNs[ns] = [];
	                }
	                this._providersByNs[ns].push(dependency);
	            }
	        }
	        return this;
	    }
	    getPropertyValues(target) {
	        const __inject = Reflect.getMetadata("injectProperties", target);
	        if (target.$$injected) {
	            // console.error(`Ignoring additional dependency injection on ${target.constructor.name}.`);
	            return;
	        }
	        // may bust of the object is sealed
	        if (!Object.isSealed(target))
	            target.$$injected = true;
	        const properties = {};
	        if (__inject) {
	            for (let property in __inject) {
	                const [ns, map] = __inject[property];
	                let value;
	                if (/\*\*$/.test(ns)) {
	                    value = this.queryAll(ns).map(map);
	                }
	                else {
	                    value = this.query(ns);
	                    value = value ? map(value) : undefined;
	                }
	                if (value != null) {
	                    properties[property] = value;
	                }
	                if (!process.env.TESTING && (value == null || value.length === 0)) {
	                    console.warn(`Cannot inject ${ns} into ${target.name || target.constructor.name}.${property} property.`);
	                }
	            }
	        }
	        return properties;
	    }
	}
	exports.Injector = Injector;


/***/ },
/* 56 */
/***/ function(module, exports) {

	module.exports = require("lodash");

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(58));
	// export * from "./entities";
	// export * from "./runtime";
	// export * from "./loader";
	// export * from "./utils"; 


/***/ },
/* 58 */
/***/ function(module, exports) {

	"use strict";
	function sourcePositionEquals(a, b) {
	    return (a == null && b == null) || (a && b && (a.line === b.line && a.column === b.column));
	}
	exports.sourcePositionEquals = sourcePositionEquals;
	function cloneSourcePosition({ line, column }) {
	    return { line, column };
	}
	exports.cloneSourcePosition = cloneSourcePosition;
	function cloneSourceLocation({ start, end }) {
	    return {
	        start: cloneSourcePosition(start),
	        end: cloneSourcePosition(end)
	    };
	}
	exports.cloneSourceLocation = cloneSourceLocation;
	const noSource = {
	    content: ""
	};
	class BaseExpression {
	    constructor(location) {
	        this.offset = 0;
	        this.location = location;
	    }
	    inRange(selection) {
	        // const offset = this.offset;
	        // const start = this.position.start + offset;
	        // const end   = this.position.end + offset;
	        // return (selection.start >= start && selection.start <= end) ||
	        // (selection.end   >= start && selection.end <= end) ||
	        // (selection.start <= start && selection.end >= end);
	    }
	}
	exports.BaseExpression = BaseExpression;


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(60));
	__export(__webpack_require__(61));
	__export(__webpack_require__(62));
	__export(__webpack_require__(63));
	__export(__webpack_require__(64));
	__export(__webpack_require__(65));
	__export(__webpack_require__(66));


/***/ },
/* 60 */
/***/ function(module, exports) {

	"use strict";


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const assert = __webpack_require__(25);
	const mesh_1 = __webpack_require__(13);
	/**
	 * @deprecated apps should never directly register listeners to a main bus. Instead they should interface
	 * with a public collection
	 *
	 * @export
	 * @class BrokerBus
	 * @implements {IBrokerBus}
	 */
	class BrokerBus {
	    constructor(busClass = mesh_1.ParallelBus, ...actors) {
	        this.actors = [];
	        this._bus = new busClass((message) => {
	            // dispatches are expensive since they typically use streams. This chunk reduces
	            // unecessary operations to dispatch handlers that can't handle a given message.
	            const actors = this.actors.filter((actor) => {
	                return !actor.testMessage || actor.testMessage(message);
	            });
	            return actors;
	        });
	        this.register(...actors);
	    }
	    register(...actors) {
	        for (const actor of actors)
	            assert(actor && actor.dispatch);
	        this.actors.push(...actors);
	    }
	    unregister(...actors) {
	        for (const actor of actors) {
	            const i = this.actors.indexOf(actor);
	            if (i !== -1) {
	                this.actors.splice(i, 1);
	            }
	        }
	    }
	    dispatch(message) {
	        return this._bus.dispatch(message);
	    }
	}
	exports.BrokerBus = BrokerBus;


/***/ },
/* 62 */
/***/ function(module, exports) {

	"use strict";
	class BubbleDispatcher {
	    constructor(target) {
	        this.target = target;
	    }
	    dispatch(action) {
	        this.target.notify(action);
	    }
	}
	exports.BubbleDispatcher = BubbleDispatcher;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const mesh_1 = __webpack_require__(13);
	const messages_1 = __webpack_require__(47);
	class PostDsNotifierBus {
	    constructor(_dsBus, _dispatcher) {
	        this._dsBus = _dsBus;
	        this._dispatcher = _dispatcher;
	    }
	    dispatch(message) {
	        if ([mesh_1.DSInsertRequest.DS_INSERT, mesh_1.DSRemoveRequest.DS_REMOVE, mesh_1.DSUpdateRequest.DS_UPDATE].indexOf(message.type) > -1) {
	            return new mesh_1.DuplexStream((input, output) => {
	                const writer = output.getWriter();
	                this._dsBus.dispatch(message).readable.pipeTo(new mesh_1.WritableStream({
	                    write: (chunk) => {
	                        writer.write(chunk);
	                        this._dispatcher.dispatch(messages_1.PostDSMessage.createFromDSRequest(message, chunk));
	                    }
	                })).then(writer.close.bind(writer)).catch(writer.abort.bind(writer));
	            });
	        }
	        return this._dsBus.dispatch(message);
	    }
	}
	exports.PostDsNotifierBus = PostDsNotifierBus;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const mesh_1 = __webpack_require__(13);
	// TODO - remove me - use LimitBus from mesh instead
	class LimitBus {
	    constructor(max, actor) {
	        this.max = max;
	        this.actor = actor;
	        this._queue = [];
	        this._running = 0;
	    }
	    dispatch(action) {
	        return new mesh_1.DuplexStream((input, output) => {
	            if (this._running > this.max) {
	                this._queue.push({ action, input, output });
	                return;
	            }
	            this._running++;
	            const complete = () => {
	                this._running--;
	                if (this._queue.length) {
	                    const { action, input, output } = this._queue.shift();
	                    input.pipeThrough(this.dispatch(action)).pipeTo(output);
	                }
	            };
	            input.pipeThrough(this.actor.dispatch(action)).pipeTo(output).then(complete, complete);
	        });
	    }
	}
	exports.LimitBus = LimitBus;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const mesh_1 = __webpack_require__(13);
	class UpsertBus {
	    constructor(_child) {
	        this._child = _child;
	    }
	    dispatch(action) {
	        return new mesh_1.DuplexStream((input, output) => __awaiter(this, void 0, void 0, function* () {
	            const writer = output.getWriter();
	            const { value, done } = yield mesh_1.readOneChunk(this._child.dispatch({
	                type: "find",
	                query: action.query,
	                collectionName: action.collectionName,
	            }));
	            writer.write((yield mesh_1.readOneChunk(this._child.dispatch({
	                type: !done ? "update" : "insert",
	                data: action.data,
	                query: action.query,
	                collectionName: action.collectionName,
	            }))).value);
	            writer.close();
	        }));
	    }
	}
	exports.UpsertBus = UpsertBus;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const mesh_1 = __webpack_require__(13);
	// Important that the boundary is computed is to prevent the case where the boundary is part of the payload. This
	// has happened with Tandem since the app is used to build itself.
	const PAYLOAD_BOUNDARY = `___${"payload end"}___`;
	class SockBus {
	    constructor({ family, connection, testMessage }, localBus, serializer) {
	        this._remoteBus = new mesh_1.RemoteBus({
	            family: family,
	            testMessage: testMessage,
	            adapter: {
	                send: (data) => {
	                    connection.write(`${JSON.stringify(data)}${PAYLOAD_BOUNDARY}`);
	                },
	                addListener: (listener) => {
	                    let currentBuffer = '';
	                    connection.on("data", (chunk) => {
	                        let value = String(chunk);
	                        currentBuffer += value;
	                        if (currentBuffer.indexOf(PAYLOAD_BOUNDARY) !== -1) {
	                            const payloadParts = currentBuffer.split(PAYLOAD_BOUNDARY);
	                            const last = payloadParts.pop();
	                            payloadParts.map(text => JSON.parse(text)).forEach(listener);
	                            currentBuffer = last;
	                        }
	                    });
	                }
	            }
	        }, localBus, serializer);
	    }
	    testMessage(message) {
	        return this._remoteBus.testMessage(message);
	    }
	    dispose() {
	        this._remoteBus.dispose();
	    }
	    dispatch(message) {
	        return this._remoteBus.dispatch(message);
	    }
	}
	exports.SockBus = SockBus;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(68));


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const decorators_1 = __webpack_require__(69);
	const ioc_1 = __webpack_require__(54);
	let BaseCommand = class BaseCommand {
	};
	__decorate([
	    decorators_1.inject(ioc_1.PrivateBusProvider.ID)
	], BaseCommand.prototype, "bus", void 0);
	__decorate([
	    decorators_1.inject(ioc_1.InjectorProvider.ID)
	], BaseCommand.prototype, "injector", void 0);
	BaseCommand = __decorate([
	    decorators_1.loggable()
	], BaseCommand);
	exports.BaseCommand = BaseCommand;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(70));
	__export(__webpack_require__(71));
	__export(__webpack_require__(72));
	__export(__webpack_require__(75));
	__export(__webpack_require__(76));
	__export(__webpack_require__(77));
	__export(__webpack_require__(78));


/***/ },
/* 70 */
/***/ function(module, exports) {

	"use strict";
	// TODO - more injector helpers here.
	/**
	 * inject decorator for properties of classes that live in a Injector object
	 */
	// TODO - change this to injectProviderValue
	function inject(id, map = undefined) {
	    return function (target, property, index = undefined) {
	        const key = typeof target === "function" ? index : property;
	        const inject = Object.assign({}, Reflect.getMetadata("injectProperties", target) || {});
	        inject[key] = [id || property, map || (provider => provider.value)];
	        Reflect.defineMetadata("injectProperties", inject, target);
	    };
	}
	exports.inject = inject;
	function injectProvider(id) {
	    return function (target, property, index = undefined) {
	        const key = typeof target === "function" ? index : property;
	        const inject = Object.assign({}, Reflect.getMetadata("injectProperties", target) || {});
	        inject[key] = [id || property, provider => provider];
	        Reflect.defineMetadata("injectProperties", inject, target);
	    };
	}
	exports.injectProvider = injectProvider;


/***/ },
/* 71 */
/***/ function(module, exports) {

	/**
	 * Adds documentation for method - used particularly for stdin util for the
	 * backend
	 */
	"use strict";
	function document(documentation) {
	    return (proto, name) => {
	        if (!proto.__documentation) {
	            proto.__documentation = {};
	        }
	        proto.__documentation[name] = documentation;
	    };
	}
	exports.document = document;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const decorators_1 = __webpack_require__(69);
	const logger_1 = __webpack_require__(73);
	const mesh_1 = __webpack_require__(13);
	const ioc_1 = __webpack_require__(54);
	const noopDispatcher = new mesh_1.NoopDispatcher();
	// TODO - use a singleton here? It might be okay
	function loggable() {
	    return (clazz) => {
	        const loggerBusProperty = "$$loggerBus";
	        // this assumes the object is being injected -- it may not be.
	        decorators_1.inject(ioc_1.PrivateBusProvider.ID)(clazz.prototype, loggerBusProperty);
	        Object.defineProperty(clazz.prototype, "logger", {
	            get() {
	                if (this.$$logger)
	                    return this.$$logger;
	                const bus = this[loggerBusProperty];
	                // create a child logger so that the prefix here does
	                // not get overwritten
	                return this.$$logger = (new logger_1.Logger(bus || noopDispatcher, `${this.constructor.name}: `).createChild());
	            }
	        });
	    };
	}
	exports.loggable = loggable;
	// export function logCall() {
	// }


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const levels_1 = __webpack_require__(74);
	const messages_1 = __webpack_require__(47);
	class LogAction extends messages_1.CoreEvent {
	    constructor(level, text, filterable) {
	        super(LogAction.LOG);
	        this.level = level;
	        this.text = text;
	        this.filterable = filterable;
	    }
	}
	LogAction.LOG = "log";
	exports.LogAction = LogAction;
	class LogTimer {
	    constructor(logger, intervalMessage, timeout, level = levels_1.LogLevel.INFO) {
	        this.logger = logger;
	        this.intervalMessage = intervalMessage;
	        this.timeout = timeout;
	        this.level = level;
	        this._startTime = Date.now();
	        if (intervalMessage && timeout && !process.env.TESTING) {
	            this._interval = setInterval(() => {
	                this.logTime(intervalMessage);
	            }, timeout);
	        }
	    }
	    stop(message) {
	        clearInterval(this._interval);
	        this.logTime(message || "completed");
	    }
	    logTime(message) {
	        this.logger.log(this.level, `${message} %ss`, ((Date.now() - this._startTime) / 1000).toFixed(0));
	    }
	}
	exports.LogTimer = LogTimer;
	class Logger {
	    constructor(bus, prefix = "", _parent) {
	        this.bus = bus;
	        this.prefix = prefix;
	        this._parent = _parent;
	    }
	    createChild(prefix = "") {
	        return new Logger(this.bus, prefix, this);
	    }
	    /**
	     * Extra noisy logs which aren't very necessary
	     */
	    debug(text, ...rest) {
	        this._log(levels_1.LogLevel.DEBUG, text, ...rest);
	    }
	    /**
	     * @deprecated. Use verbose.
	     * General logging information to help with debugging
	     */
	    log(level, text, ...rest) {
	        this._log(level, text, ...rest);
	    }
	    /**
	     * log which should grab the attention of the reader
	     */
	    info(text, ...rest) {
	        this._log(levels_1.LogLevel.INFO, text, ...rest);
	    }
	    warn(text, ...rest) {
	        this._log(levels_1.LogLevel.WARNING, text, ...rest);
	    }
	    error(text, ...rest) {
	        this._log(levels_1.LogLevel.ERROR, text, text, ...rest);
	    }
	    startTimer(timeoutMessage, interval = 5000, logLevel) {
	        return new LogTimer(this, timeoutMessage, interval, logLevel);
	    }
	    getPrefix() {
	        let prefix = this.generatePrefix && this.generatePrefix() || this.prefix;
	        if (this._parent) {
	            prefix = this._parent.getPrefix() + prefix;
	        }
	        return prefix;
	    }
	    _log(level, text, ...params) {
	        function stringify(value) {
	            if (typeof value === "object") {
	                value = JSON.stringify(value, null, 2);
	            }
	            return value;
	        }
	        text = stringify(text);
	        const paramCount = (String(text).match(/%(d|s)/g) || []).length;
	        const sprintfParams = params.slice(0, paramCount);
	        const restParams = params.slice(paramCount);
	        let message = [sprintf(`${this.getPrefix()}${text}`, ...sprintfParams.map(stringify)), ...restParams].join(" ");
	        this.bus.dispatch(new LogAction(level, message, this.filterable));
	    }
	}
	exports.Logger = Logger;
	function sprintf(text, ...params) {
	    for (const param of params) {
	        text = text.replace(/%\w/, param);
	    }
	    return text;
	}
	__export(__webpack_require__(74));


/***/ },
/* 74 */
/***/ function(module, exports) {

	"use strict";
	(function (LogLevel) {
	    LogLevel[LogLevel["DEBUG"] = 2] = "DEBUG";
	    LogLevel[LogLevel["INFO"] = 4] = "INFO";
	    LogLevel[LogLevel["WARNING"] = 8] = "WARNING";
	    LogLevel[LogLevel["ERROR"] = 16] = "ERROR";
	    LogLevel[LogLevel["LOG"] = 32] = "LOG";
	    LogLevel[LogLevel["NONE"] = 0] = "NONE";
	    LogLevel[LogLevel["DEFAULT"] = 28] = "DEFAULT";
	    LogLevel[LogLevel["ALL"] = 62] = "ALL";
	    LogLevel[LogLevel["VERBOSE"] = 62] = "VERBOSE";
	})(exports.LogLevel || (exports.LogLevel = {}));
	var LogLevel = exports.LogLevel;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const mesh_1 = __webpack_require__(13);
	const messages_1 = __webpack_require__(47);
	function shouldBubbleEvents(proto, property) {
	    return proto[`$bubbleEvents$${property}`];
	}
	function bindable(bubbles = false) {
	    class BindableValue {
	        constructor(target, property) {
	            this.target = target;
	            this.property = property;
	            if (shouldBubbleEvents(target, property)) {
	                this._valueObserver = new mesh_1.CallbackDispatcher(this.onValueEvent.bind(this));
	            }
	        }
	        getValue() {
	            return this._value;
	        }
	        setValue(value) {
	            if (this._valueObserver && this._value && this._value.unobserve) {
	                this._value.unobserve(this._valueObserver);
	            }
	            this._value = value;
	            if (this._valueObserver && this._value && this._value.observe) {
	                this._value.observe(this._valueObserver);
	            }
	        }
	        onValueEvent(event) {
	            this.target.notify(event);
	        }
	    }
	    return (proto, property = undefined, descriptor = undefined) => {
	        function getBindableValue(proto) {
	            return proto[`$binding$${property}`] || (proto[`$binding$${property}`] = new BindableValue(proto, property));
	        }
	        Object.defineProperty(proto, property, {
	            get() {
	                return getBindableValue(this).getValue();
	            },
	            set(newValue) {
	                const bv = getBindableValue(this);
	                const oldValue = bv.getValue();
	                if (oldValue !== newValue) {
	                    bv.setValue(newValue);
	                    this.notify(new messages_1.PropertyMutation(messages_1.PropertyMutation.PROPERTY_CHANGE, this, property, newValue, oldValue).toEvent(bubbles));
	                }
	            }
	        });
	    };
	}
	exports.bindable = bindable;
	function bubble() {
	    return (proto, property = undefined, descriptor = undefined) => {
	        proto[`$bubbleEvents$${property}`] = true;
	    };
	}
	exports.bubble = bubble;


/***/ },
/* 76 */
/***/ function(module, exports) {

	/**
	 * Used for actors that need to filter for particular actions. Usage:
	 *
	 * @filterMessage(sift({ $type: DSEvent }))
	 * update(action:UpdateEvent) { }
	 */
	"use strict";
	function filterMessage(filter) {
	    return (proto, name, inf) => {
	        const oldValue = inf.value;
	        inf.value = function (message) {
	            if (filter(message)) {
	                return oldValue.call(this, message);
	            }
	        };
	    };
	}
	exports.filterMessage = filterMessage;
	;


/***/ },
/* 77 */
/***/ function(module, exports) {

	"use strict";
	exports.patchable = () => {
	    return (proto, property = undefined, descriptor = undefined) => {
	        const patchableProperties = proto.__patchableProperties = (proto.__patchableProperties || []).concat();
	        if (patchableProperties.indexOf(property) === -1) {
	            patchableProperties.push(property);
	        }
	    };
	};
	exports.getPatchableProperties = (instance) => {
	    return instance.__patchableProperties || [];
	};


/***/ },
/* 78 */
/***/ function(module, exports) {

	"use strict";
	function mixin(...baseCtors) {
	    return function (derivedCtor) {
	        baseCtors.forEach(baseCtor => {
	            Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
	                if (name !== "constructor" && (!derivedCtor.prototype.hasOwnProperty(name) || (derivedCtor.prototype[name] && derivedCtor.prototype[name].virtual))) {
	                    derivedCtor.prototype[name] = baseCtor.prototype[name];
	                }
	            });
	        });
	    };
	}
	exports.mixin = mixin;
	function virtual(proto, property) {
	    proto[property].virtual = true;
	}
	exports.virtual = virtual;
	;


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(80));
	__export(__webpack_require__(81));
	__export(__webpack_require__(82));
	__export(__webpack_require__(83));


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const bounding_rect_1 = __webpack_require__(81);
	function cloneRange(range) {
	    return { start: range.start, end: range.end };
	}
	exports.cloneRange = cloneRange;
	class Point {
	    constructor(left, top) {
	        this.left = left;
	        this.top = top;
	    }
	    clone() {
	        return new Point(this.left, this.top);
	    }
	    distanceTo(point) {
	        return Math.sqrt(Math.pow(this.left - point.left, 2) + Math.pow(this.top - point.top, 2));
	    }
	}
	exports.Point = Point;
	class Line {
	    constructor(from, to) {
	        this.from = from;
	        this.to = to;
	    }
	    get points() {
	        return [this.from, this.to];
	    }
	    flip() {
	        return new Line(new Point(this.to.left, this.from.top), new Point(this.from.left, this.to.top));
	    }
	    reverse() {
	        return new Line(this.to.clone(), this.from.clone());
	    }
	    get length() {
	        return this.from.distanceTo(this.to);
	    }
	    getBoundingRect() {
	        return new bounding_rect_1.BoundingRect(Math.min(this.from.left, this.to.left), Math.min(this.from.top, this.to.top), Math.max(this.from.left, this.to.left), Math.max(this.from.top, this.to.top));
	    }
	}
	exports.Line = Line;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const serialize_1 = __webpack_require__(11);
	let BoundingRect_1 = class BoundingRect {
	    constructor(left, top, right, bottom) {
	        this.left = left;
	        this.top = top;
	        this.right = right;
	        this.bottom = bottom;
	    }
	    get position() {
	        return {
	            left: this.left,
	            top: this.top
	        };
	    }
	    get width() {
	        return Math.max(this.right - this.left, 0);
	    }
	    set width(value) {
	        this.right = this.left + value;
	    }
	    get height() {
	        return Math.max(this.bottom - this.top, 0);
	    }
	    set height(value) {
	        this.bottom = this.top + value;
	    }
	    zoom(delta) {
	        return new BoundingRect_1(this.left * delta, this.top * delta, this.right * delta, this.bottom * delta);
	    }
	    equalTo(rect) {
	        return (this.left === rect.left &&
	            this.top === rect.top &&
	            this.right === rect.right &&
	            this.bottom === rect.bottom);
	    }
	    get visible() {
	        return this.width > 0 && this.height > 0;
	    }
	    toArray() {
	        return [this.left, this.top, this.right, this.bottom];
	    }
	    intersects(...rects) {
	        return !!rects.find((rect) => (this.intersectsHorizontal(rect) &&
	            this.intersectsVertical(rect)));
	    }
	    intersectsHorizontal(...rects) {
	        return !!rects.find((rect) => (Math.max(this.top, rect.top) <= Math.min(this.bottom, rect.bottom)));
	    }
	    intersectsVertical(...rects) {
	        return !!rects.find((rect) => (Math.max(this.left, rect.left) <= Math.min(this.right, rect.right)));
	    }
	    merge(...rects) {
	        return BoundingRect_1.merge(this, ...rects);
	    }
	    move({ left, top }) {
	        return new BoundingRect_1(this.left + left, this.top + top, this.right + left, this.bottom + top);
	    }
	    moveTo({ left, top }) {
	        return new BoundingRect_1(left, top, left + this.width, top + this.height);
	    }
	    clone() {
	        return new BoundingRect_1(this.left, this.top, this.right, this.bottom);
	    }
	    static fromClientRect(rect) {
	        return new BoundingRect_1(rect.left, rect.top, rect.right, rect.bottom);
	    }
	    static zeros() {
	        return new BoundingRect_1(0, 0, 0, 0);
	    }
	    static merge(...rects) {
	        let left = Infinity;
	        let bottom = -Infinity;
	        let top = Infinity;
	        let right = -Infinity;
	        for (const rect of rects) {
	            left = Math.min(left, rect.left);
	            right = Math.max(right, rect.right);
	            top = Math.min(top, rect.top);
	            bottom = Math.max(bottom, rect.bottom);
	        }
	        return new BoundingRect_1(left, top, right, bottom);
	    }
	};
	let BoundingRect = BoundingRect_1;
	BoundingRect = BoundingRect_1 = __decorate([
	    serialize_1.serializable({
	        serialize({ left, top, right, bottom }) {
	            return { left, top, right, bottom };
	        },
	        deserialize({ left, top, right, bottom }) {
	            return new BoundingRect(left, top, right, bottom);
	        }
	    })
	], BoundingRect);
	exports.BoundingRect = BoundingRect;


/***/ },
/* 82 */
/***/ function(module, exports) {

	"use strict";
	class Transform {
	    constructor(left = 0, top = 0, scale = 1) {
	        this.left = left;
	        this.top = top;
	        this.scale = scale;
	    }
	    localizePosition(position) {
	        return {
	            left: (position.left - this.left) / this.scale,
	            top: (position.top - this.top) / this.scale
	        };
	    }
	}
	exports.Transform = Transform;


/***/ },
/* 83 */
/***/ function(module, exports) {

	"use strict";
	class Range {
	    constructor(start, end) {
	        this.start = start;
	        this.end = end;
	    }
	    shift(delta) {
	        this.start += delta;
	        this.end += delta;
	    }
	}
	exports.Range = Range;


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(85));
	__export(__webpack_require__(86));
	__export(__webpack_require__(88));
	__export(__webpack_require__(89));


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const token_1 = __webpack_require__(86);
	const scanner_1 = __webpack_require__(87);
	const constants_1 = __webpack_require__(88);
	class StringTokenizer {
	    tokenize(source) {
	        const scanner = new scanner_1.StringScanner(source);
	        const tokens = [];
	        function addToken(scanRegexp, type) {
	            if (scanner.scan(scanRegexp)) {
	                tokens.push(new token_1.Token(scanner.getCapture(), type));
	                return true;
	            }
	            return false;
	        }
	        while (!scanner.hasTerminated()) {
	            if (addToken(/^[\n\r]/, constants_1.TokenTypes.NEW_LINE))
	                continue;
	            if (addToken(/^\t+/, constants_1.TokenTypes.TAB))
	                continue;
	            if (addToken(/^\u0020+/, constants_1.TokenTypes.SPACE))
	                continue;
	            if (addToken(/[^\s\t\n\r]+/, constants_1.TokenTypes.TEXT))
	                continue;
	            throw new Error("unexpected token: " + scanner.getCapture());
	        }
	        return tokens;
	    }
	}
	exports.StringTokenizer = StringTokenizer;
	exports.stringTokenizer = new StringTokenizer();


/***/ },
/* 86 */
/***/ function(module, exports) {

	"use strict";
	class Token {
	    constructor(value, type) {
	        this.value = value;
	        this.type = type;
	        this.length = value.length;
	    }
	}
	exports.Token = Token;


/***/ },
/* 87 */
/***/ function(module, exports) {

	"use strict";
	class StringScanner {
	    constructor(source) {
	        this._source = source == null ? "" : String(source);
	        this._position = 0;
	    }
	    scan(regexp) {
	        const rest = this._source.substr(this._position);
	        const match = rest.match(regexp);
	        if (!match)
	            return void 0;
	        this._capture = match[0];
	        this._position += rest.indexOf(this._capture) + this._capture.length;
	        return this._capture;
	    }
	    nextChar() {
	        return this._source.charAt(this._position++);
	    }
	    hasTerminated() {
	        return this._position >= this._source.length;
	    }
	    getCapture() {
	        return this._capture;
	    }
	}
	exports.StringScanner = StringScanner;


/***/ },
/* 88 */
/***/ function(module, exports) {

	"use strict";
	var TokenTypes;
	(function (TokenTypes) {
	    TokenTypes.SPACE = "space"; // \s
	    TokenTypes.TEXT = "text"; // a-Z
	    TokenTypes.TAB = "tab"; // \t
	    TokenTypes.NEW_LINE = "newLine"; // \n
	    TokenTypes.LEFT_PAREN = "leftParen"; // (
	    TokenTypes.RIGHT_PAREN = "rightParen"; // )
	    TokenTypes.DOT = "dot"; // .
	    TokenTypes.COLON = "colon"; // :
	    TokenTypes.OPERATOR = "operator"; //
	    TokenTypes.COMMA = "comma";
	})(TokenTypes = exports.TokenTypes || (exports.TokenTypes = {}));


/***/ },
/* 89 */
/***/ function(module, exports) {

	"use strict";
	class ITokenizer {
	}
	exports.ITokenizer = ITokenizer;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const observable_1 = __webpack_require__(91);
	const messages_1 = __webpack_require__(47);
	class Metadata extends observable_1.Observable {
	    constructor(_data = {}) {
	        super();
	        this._data = _data;
	    }
	    get data() {
	        return this._data;
	    }
	    set data(value) {
	        this._data = value;
	    }
	    get(key) {
	        return this._data[key];
	    }
	    setProperties(properties) {
	        for (const key in properties) {
	            this.set(key, properties[key]);
	        }
	    }
	    toggle(key) {
	        const v = this.get(key);
	        this.set(key, v == null ? true : !v);
	        return this.get(key);
	    }
	    set(key, value) {
	        const oldValue = this.get(key);
	        this._data[key] = value;
	        if (value !== oldValue) {
	            this.notify(new messages_1.MetadataChangeEvent(key, value));
	        }
	    }
	}
	exports.Metadata = Metadata;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const base_1 = __webpack_require__(92);
	exports.IObservable = base_1.IObservable;
	__export(__webpack_require__(93));
	__export(__webpack_require__(94));
	__export(__webpack_require__(95));


/***/ },
/* 92 */
/***/ function(module, exports) {

	"use strict";


/***/ },
/* 93 */
/***/ function(module, exports) {

	"use strict";
	// TODO - change "notify" to "dispatch"
	class Observable {
	    constructor(_target) {
	        this._target = _target;
	        if (!this._target) {
	            this._target = this;
	        }
	    }
	    observe(...dispatchers) {
	        for (let i = 0, n = dispatchers.length; i < n; i++) {
	            const actor = dispatchers[i];
	            if (!actor && !actor.dispatch) {
	                throw new Error(`Attempting to add a non-observable object.`);
	            }
	            if (!this._observers) {
	                this._observers = actor;
	            }
	            else if (!Array.isArray(this._observers)) {
	                this._observers = [actor, this._observers];
	            }
	            else {
	                this._observers.unshift(actor);
	            }
	        }
	    }
	    unobserve(...dispatchers) {
	        for (let i = 0, n = dispatchers.length; i < n; i++) {
	            const actor = dispatchers[i];
	            if (this._observers === actor) {
	                this._observers = null;
	            }
	            else if (Array.isArray(this._observers)) {
	                const i = this._observers.indexOf(actor);
	                if (i !== -1) {
	                    this._observers.splice(i, 1);
	                }
	                // only one left? Move to a more optimal method for notifying
	                // observers.
	                if (this._observers.length === 1) {
	                    this._observers = this._observers[0];
	                }
	            }
	        }
	    }
	    notify(event) {
	        if (event.canPropagate === false)
	            return;
	        if (event.target && event.bubbles === false)
	            return;
	        event.currentTarget = this._target;
	        if (!this._observers)
	            return;
	        if (!Array.isArray(this._observers))
	            return this._observers.dispatch(event);
	        // fix case where observable unlistens and re-listens to events during a notifiction
	        const observers = this._observers.concat();
	        for (let i = observers.length; i--;) {
	            if (event.canPropagateImmediately === false)
	                break;
	            observers[i].dispatch(event);
	        }
	    }
	}
	exports.Observable = Observable;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const core_1 = __webpack_require__(93);
	const messages_1 = __webpack_require__(47);
	class PropertyWatcher extends core_1.Observable {
	    constructor(target, propertyName) {
	        super();
	        this.target = target;
	        this.propertyName = propertyName;
	        this.onEvent = ({ mutation }) => {
	            if (mutation && mutation.type === messages_1.PropertyMutation.PROPERTY_CHANGE && mutation.name === this.propertyName && mutation.target === this.target) {
	                const oldValue = this._currentValue;
	                this._currentValue = mutation.newValue;
	                this.notify(new messages_1.PropertyMutation(messages_1.PropertyMutation.PROPERTY_CHANGE, this, "currentValue", this._currentValue, oldValue).toEvent());
	            }
	        };
	        this._currentValue = target[propertyName];
	    }
	    get currentValue() {
	        return this._currentValue;
	    }
	    connect(listener) {
	        if (!this._listening) {
	            this._listening = true;
	            this.target.observe(this._observer = { dispatch: this.onEvent });
	        }
	        let currentValue = this.currentValue;
	        const observer = {
	            dispatch: (event) => {
	                if (this.currentValue !== currentValue) {
	                    const oldValue = currentValue;
	                    currentValue = this.currentValue;
	                    listener(this.currentValue, oldValue);
	                }
	            }
	        };
	        this.observe(observer);
	        return {
	            trigger() {
	                listener(currentValue);
	                return this;
	            },
	            dispose: () => {
	                this.unobserve(observer);
	            }
	        };
	    }
	}
	exports.PropertyWatcher = PropertyWatcher;
	// DEPRECATED - use PropertyWatcher instead
	function watchProperty(target, property, callback) {
	    const observer = {
	        dispatch({ mutation }) {
	            if (mutation && mutation.type === messages_1.PropertyMutation.PROPERTY_CHANGE) {
	                const propertyMutation = mutation;
	                if (propertyMutation.name === property && propertyMutation.target === target) {
	                    callback(propertyMutation.newValue, propertyMutation.oldValue);
	                }
	            }
	        }
	    };
	    if (target.observe) {
	        target.observe(observer);
	    }
	    const ret = {
	        dispose: () => {
	            if (target.unobserve)
	                target.unobserve(observer);
	        },
	        trigger: () => {
	            if (target[property] != null) {
	                callback(target[property], undefined);
	            }
	            return ret;
	        }
	    };
	    return ret;
	}
	exports.watchProperty = watchProperty;
	function watchPropertyOnce(target, property, callback) {
	    const watcher = watchProperty(target, property, (newValue, oldValue) => {
	        watcher.dispose();
	        callback(newValue, oldValue);
	    });
	    return {
	        dispose: () => watcher.dispose(),
	        trigger: () => watcher.trigger()
	    };
	}
	exports.watchPropertyOnce = watchPropertyOnce;
	function bindProperty(source, sourceProperty, target, destProperty = sourceProperty) {
	    return watchProperty(source, sourceProperty, (newValue, oldValue) => {
	        target[destProperty] = newValue;
	    }).trigger();
	}
	exports.bindProperty = bindProperty;
	function waitForPropertyChange(target, property, filter = () => true) {
	    return new Promise((resolve, reject) => {
	        const watcher = watchProperty(target, property, (newValue) => {
	            if (filter(newValue)) {
	                resolve();
	                watcher.dispose();
	            }
	        });
	    });
	}
	exports.waitForPropertyChange = waitForPropertyChange;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const index_1 = __webpack_require__(91);
	const dispatchers_1 = __webpack_require__(59);
	const utils_1 = __webpack_require__(96);
	class ObservableCollection extends Array {
	    constructor(...items) {
	        super(...items);
	        this._observable = new index_1.Observable(this);
	        this._itemObserver = new dispatchers_1.BubbleDispatcher(this);
	        this._watchItems(this);
	    }
	    observe(actor) {
	        this._observable.observe(actor);
	    }
	    unobserve(actor) {
	        this._observable.unobserve(actor);
	    }
	    notify(action) {
	        return this._observable.notify(action);
	    }
	    push(...items) {
	        return this.splice(this.length, 0, ...items).length;
	    }
	    unshift(...items) {
	        return this.splice(0, 0, ...items).length;
	    }
	    shift() {
	        return this.splice(0, 1).pop();
	    }
	    pop() {
	        return this.splice(this.length - 1, 1).pop();
	    }
	    splice(start, deleteCount, ...newItems) {
	        const deletes = this.slice(start, start + deleteCount).map((item, index) => {
	            if (item && item["unobserve"]) {
	                item.unobserve(this._itemObserver);
	            }
	            return new utils_1.ArrayRemoveMutation(item, start + index);
	        });
	        const inserts = newItems.map((item, index) => {
	            return new utils_1.ArrayInsertMutation(start + index, item);
	        });
	        const ret = super.splice(start, deleteCount, ...newItems);
	        this._watchItems(newItems);
	        this.notify(new utils_1.ArrayMutation([...deletes, ...inserts]).toEvent());
	        return ret;
	    }
	    _watchItems(newItems) {
	        for (const item of newItems) {
	            if (item && item["observe"]) {
	                item.observe(this._itemObserver);
	            }
	        }
	    }
	}
	exports.ObservableCollection = ObservableCollection;


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(97));
	__export(__webpack_require__(99));
	__export(__webpack_require__(101));
	__export(__webpack_require__(104));
	__export(__webpack_require__(105));
	__export(__webpack_require__(139));


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(98));
	function toArray(value) {
	    return Array.isArray(value) ? value : value == null ? [] : [value];
	}
	exports.toArray = toArray;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const mutate_1 = __webpack_require__(50);
	var ArrayItemMutationTypes;
	(function (ArrayItemMutationTypes) {
	    ArrayItemMutationTypes.INSERT = "insert";
	    ArrayItemMutationTypes.UPDATE = "update";
	    ArrayItemMutationTypes.DELETE = "delete";
	})(ArrayItemMutationTypes = exports.ArrayItemMutationTypes || (exports.ArrayItemMutationTypes = {}));
	class ArraItemMutation extends mutate_1.Mutation {
	    constructor(type) {
	        super(type);
	    }
	}
	exports.ArraItemMutation = ArraItemMutation;
	class ArrayInsertMutation extends ArraItemMutation {
	    constructor(index, value) {
	        super(ArrayItemMutationTypes.INSERT);
	        this.index = index;
	        this.value = value;
	    }
	    accept(visitor) {
	        visitor.visitInsert(this);
	    }
	}
	exports.ArrayInsertMutation = ArrayInsertMutation;
	class ArrayRemoveMutation extends ArraItemMutation {
	    constructor(value, index) {
	        super(ArrayItemMutationTypes.DELETE);
	        this.value = value;
	        this.index = index;
	    }
	    accept(visitor) {
	        visitor.visitRemove(this);
	    }
	}
	exports.ArrayRemoveMutation = ArrayRemoveMutation;
	class ArrayUpdateMutation extends ArraItemMutation {
	    constructor(originalOldIndex, patchedOldIndex, newValue, index) {
	        super(ArrayItemMutationTypes.UPDATE);
	        this.originalOldIndex = originalOldIndex;
	        this.patchedOldIndex = patchedOldIndex;
	        this.newValue = newValue;
	        this.index = index;
	    }
	    accept(visitor) {
	        visitor.visitUpdate(this);
	    }
	}
	exports.ArrayUpdateMutation = ArrayUpdateMutation;
	class ArrayMutation extends mutate_1.Mutation {
	    constructor(mutations) {
	        super(ArrayMutation.ARRAY_DIFF);
	        this.mutations = mutations;
	        this.count = mutations.length;
	    }
	    accept(visitor) {
	        this.mutations.forEach(change => change.accept(visitor));
	    }
	}
	ArrayMutation.ARRAY_DIFF = "arrayDiff";
	exports.ArrayMutation = ArrayMutation;
	function diffArray(oldArray, newArray, countDiffs) {
	    // model used to figure out the proper mutation indices
	    const model = [].concat(oldArray);
	    // remaining old values to be matched with new values. Remainders get deleted.
	    const oldPool = [].concat(oldArray);
	    // remaining new values. Remainders get inserted.
	    const newPool = [].concat(newArray);
	    const mutations = [];
	    let matches = [];
	    for (let i = 0, n = oldPool.length; i < n; i++) {
	        const oldValue = oldPool[i];
	        let bestNewValue;
	        let fewestDiffCount = Infinity;
	        // there may be multiple matches, so look for the best one
	        for (let j = 0, n2 = newPool.length; j < n2; j++) {
	            const newValue = newPool[j];
	            // -1 = no match, 0 = no change, > 0 = num diffs
	            let diffCount = countDiffs(oldValue, newValue);
	            if (~diffCount && diffCount < fewestDiffCount) {
	                bestNewValue = newValue;
	                fewestDiffCount = diffCount;
	            }
	            // 0 = exact match, so break here.
	            if (fewestDiffCount === 0)
	                break;
	        }
	        // subtract matches from both old & new pools and store
	        // them for later use
	        if (bestNewValue != null) {
	            oldPool.splice(i--, 1);
	            n--;
	            newPool.splice(newPool.indexOf(bestNewValue), 1);
	            // need to manually set array indice here to ensure that the order
	            // of operations is correct when mutating the target array.
	            matches[newArray.indexOf(bestNewValue)] = [oldValue, bestNewValue];
	        }
	    }
	    for (let i = oldPool.length; i--;) {
	        const oldValue = oldPool[i];
	        const index = oldArray.indexOf(oldValue);
	        mutations.push(new ArrayRemoveMutation(oldValue, index));
	        model.splice(index, 1);
	    }
	    // sneak the inserts into the matches so that they're
	    // ordered propertly along with the updates - particularly moves.
	    for (let i = 0, n = newPool.length; i < n; i++) {
	        const newValue = newPool[i];
	        const index = newArray.indexOf(newValue);
	        matches[index] = [undefined, newValue];
	    }
	    // apply updates last using indicies from the old array model. This ensures
	    // that mutations are properly applied to whatever target array.
	    for (let i = 0, n = matches.length; i < n; i++) {
	        const match = matches[i];
	        // there will be empty values since we're manually setting indices on the array above
	        if (match == null)
	            continue;
	        const [oldValue, newValue] = matches[i];
	        const newIndex = i;
	        // insert
	        if (oldValue == null) {
	            mutations.push(new ArrayInsertMutation(newIndex, newValue));
	            model.splice(newIndex, 0, newValue);
	        }
	        else {
	            const oldIndex = model.indexOf(oldValue);
	            mutations.push(new ArrayUpdateMutation(oldArray.indexOf(oldValue), oldIndex, newValue, newIndex));
	            if (oldIndex !== newIndex) {
	                model.splice(oldIndex, 1);
	                model.splice(newIndex, 0, oldValue);
	            }
	        }
	    }
	    return new ArrayMutation(mutations);
	}
	exports.diffArray = diffArray;
	function patchArray(target, diff, mapUpdate, mapInsert) {
	    diff.accept({
	        visitInsert({ index, value }) {
	            target.splice(index, 0, mapInsert(value));
	        },
	        visitRemove({ index }) {
	            target.splice(index, 1);
	        },
	        visitUpdate({ patchedOldIndex, newValue, index }) {
	            const oldValue = target[patchedOldIndex];
	            const patchedValue = mapUpdate(oldValue, newValue);
	            if (patchedValue !== oldValue || patchedOldIndex !== index) {
	                if (patchedOldIndex !== index) {
	                    target.splice(patchedOldIndex, 1);
	                }
	                target.splice(index, 0, patchedValue);
	            }
	        }
	    });
	}
	exports.patchArray = patchArray;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var start_drag_1 = __webpack_require__(100);
	exports.startDrag = start_drag_1.default;
	function getStyle(props, styleName, defaults) {
	    if (!props.styles || !props.styles[styleName])
	        return defaults;
	    return props.styles[styleName];
	}
	exports.getStyle = getStyle;


/***/ },
/* 100 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = (startEvent, update, stop = undefined) => {
	    const sx = startEvent.clientX;
	    const sy = startEvent.clientY;
	    const doc = startEvent.target.ownerDocument;
	    function drag(event) {
	        // stops text from getting highlighted
	        event.preventDefault();
	        update(event, {
	            delta: {
	                x: event.clientX - sx,
	                y: event.clientY - sy,
	            },
	        });
	    }
	    function cleanup() {
	        doc.removeEventListener("mousemove", drag);
	        doc.removeEventListener("mouseup", cleanup);
	        if (stop)
	            stop();
	    }
	    doc.addEventListener("mousemove", drag);
	    doc.addEventListener("mouseup", cleanup);
	    return {
	        dispose: cleanup,
	    };
	};


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(102));
	__export(__webpack_require__(103));
	__export(__webpack_require__(102));


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const transform_1 = __webpack_require__(103);
	function bubbleHTMLIframeEvents(iframe, options = {}) {
	    const window = iframe.contentWindow;
	    const body = window.document.childNodes[0];
	    const translateMousePositions = options.translateMousePositions !== false;
	    // TODO - this should be in its own util function
	    function bubbleEvent(event) {
	        if (/key|input/.test(event.type) && options.ignoreInputEvents && (/textarea|input/i.test(event.target.nodeName) || event.target.contentEditable === "true")) {
	            return;
	        }
	        const clonedEvent = new Event(event.type, {
	            bubbles: true,
	            cancelable: true
	        });
	        const rect = iframe.getBoundingClientRect();
	        const actualRect = transform_1.calculateAbsoluteBounds(iframe);
	        const zoom = rect.width / actualRect.width;
	        for (let key in event) {
	            let value = event[key];
	            if (typeof value === "function") {
	                value = value.bind(event);
	            }
	            if (translateMousePositions) {
	                if (key === "pageX" || key === "clientX") {
	                    value = rect.left + value * zoom;
	                }
	                if (key === "pageY" || key === "clientY") {
	                    value = rect.top + value * zoom;
	                }
	            }
	            // bypass read-only issues here
	            try {
	                clonedEvent[key] = value;
	            }
	            catch (e) { }
	        }
	        iframe.dispatchEvent(clonedEvent);
	        if (clonedEvent.defaultPrevented) {
	            event.preventDefault();
	        }
	    }
	    const eventTypes = [
	        "keypress",
	        "copy",
	        "dragenter",
	        "dragexit",
	        "drop",
	        "paste",
	        "mousemove",
	        "mousedown",
	        "mouseup",
	        "keyup",
	        "keydown"
	    ];
	    for (let eventType of eventTypes) {
	        body.addEventListener(eventType, bubbleEvent);
	    }
	    if (options.ignoreScrollEvents !== true) {
	        window.addEventListener("wheel", bubbleEvent);
	        window.addEventListener("scroll", bubbleEvent);
	    }
	}
	exports.bubbleHTMLIframeEvents = bubbleHTMLIframeEvents;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const geom_1 = __webpack_require__(79);
	function translateAbsoluteToRelativePoint(event, relativeElement) {
	    const zoom = relativeElement;
	    const left = event.clientX || event.left;
	    const top = event.clientY || event.top;
	    const bounds = relativeElement.getBoundingClientRect();
	    const rx = left - bounds.left;
	    const ry = top - bounds.top;
	    return { left: rx, top: ry };
	}
	exports.translateAbsoluteToRelativePoint = translateAbsoluteToRelativePoint;
	function calculateCSSMeasurments(style) {
	    const calculated = {};
	    for (let key in style) {
	        if (hasMeasurement(key)) {
	            calculated[key] = Number(style[key].replace("px", ""));
	        }
	    }
	    return calculated;
	}
	exports.calculateCSSMeasurments = calculateCSSMeasurments;
	/**
	 * Robust method for fetching parent nodes outside
	 * of an iframe
	 */
	function getParentNode(node) {
	    const parentNode = node.parentNode;
	    if (parentNode) {
	        if (parentNode.nodeName === "#document") {
	            const localWindow = node.ownerDocument.defaultView;
	            if (localWindow && localWindow !== window) {
	                const parentWindow = localWindow.parent;
	                return Array.prototype.find.call(parentWindow.document.querySelectorAll("iframe"), (iframe) => {
	                    return iframe.contentWindow === localWindow;
	                });
	            }
	        }
	        else if (parentNode.nodeName === "#document-fragment" && parentNode["host"]) {
	            return parentNode["host"];
	        }
	    }
	    return parentNode;
	}
	function parseCSSMatrixValue(value) {
	    return value.replace(/matrix\((.*?)\)/, "$1").split(/,\s/).map((value) => Number(value));
	}
	function calculateTransform(node, includeIframes = true) {
	    let cnode = node;
	    let matrix = [0, 0, 0, 0, 0, 0];
	    while (cnode) {
	        if (cnode.nodeName === "IFRAME" && cnode !== node && !includeIframes) {
	            break;
	        }
	        if (cnode.nodeType === 1) {
	            // TODO - this needs to be memoized - getComputedStyle is expensive.
	            const style = window.getComputedStyle(cnode);
	            if (style.transform !== "none") {
	                const cnodeMatrix = parseCSSMatrixValue(style.transform);
	                for (let i = cnodeMatrix.length; i--;) {
	                    matrix[i] += cnodeMatrix[i];
	                }
	            }
	        }
	        cnode = getParentNode(cnode);
	    }
	    return [matrix[0] || 1, matrix[1], matrix[2], matrix[3] || 1, matrix[4], matrix[5]];
	}
	function calculateUntransformedBoundingRect(node) {
	    const rect = node.getBoundingClientRect();
	    const bounds = new geom_1.BoundingRect(rect.left, rect.top, rect.right, rect.bottom);
	    const matrix = calculateTransform(node, false);
	    return bounds.move({ left: -matrix[4], top: -matrix[5] }).zoom(1 / matrix[0]);
	}
	exports.calculateUntransformedBoundingRect = calculateUntransformedBoundingRect;
	function hasMeasurement(key) {
	    return /left|top|right|bottom|width|height|padding|margin|border/.test(key);
	}
	function roundMeasurements(style) {
	    const roundedStyle = {};
	    for (let key in style) {
	        const measurement = roundedStyle[key] = style[key];
	        if (hasMeasurement(key)) {
	            const value = measurement.match(/^(-?[\d\.]+)/)[1];
	            const unit = measurement.match(/([a-z]+)$/)[1];
	            // ceiling is necessary here for zoomed in elements
	            roundedStyle[key] = Math.round(Number(value)) + unit;
	        }
	    }
	    return roundedStyle;
	}
	function calculateAbsoluteBounds(node) {
	    let rect = calculateUntransformedBoundingRect(node);
	    return rect;
	}
	exports.calculateAbsoluteBounds = calculateAbsoluteBounds;
	function calculateTransforms(node) {
	    const computedStyle = calculateCSSMeasurments(window.getComputedStyle(node));
	    const oldWidth = node.style.width;
	    const oldTop = node.style.top;
	    const oldLeft = node.style.left;
	    const oldBoxSizing = node.style.boxSizing;
	    node.style.left = "0px";
	    node.style.top = "0px";
	    node.style.width = "100px";
	    node.style.boxSizing = "border-box";
	    const bounds = this.bounds;
	    const scale = bounds.width / 100;
	    const left = bounds.left;
	    const top = bounds.top;
	    node.style.left = oldLeft;
	    node.style.top = oldTop;
	    node.style.width = oldWidth;
	    node.style.boxSizing = oldBoxSizing;
	    return { scale, left, top };
	}


/***/ },
/* 104 */
/***/ function(module, exports) {

	"use strict";
	exports.ENV_IS_NODE = process && process.versions && process.versions.node;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const React = __webpack_require__(106);
	const ReactDOM = __webpack_require__(138);
	exports.reactPreview = (render) => {
	    return function (ComponentClass) {
	        const createBodyElement = () => __awaiter(this, void 0, void 0, function* () {
	            const element = document.createElement("div");
	            ReactDOM.render(render ? yield render() : React.createElement(ComponentClass, null), element);
	            return element;
	        });
	        if (ComponentClass) {
	            ComponentClass.$$createBodyElement = createBodyElement;
	        }
	        else {
	            return createBodyElement();
	        }
	    };
	};


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = __webpack_require__(107);


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */

	'use strict';

	var _assign = __webpack_require__(108);

	var ReactChildren = __webpack_require__(109);
	var ReactComponent = __webpack_require__(121);
	var ReactPureComponent = __webpack_require__(124);
	var ReactClass = __webpack_require__(125);
	var ReactDOMFactories = __webpack_require__(130);
	var ReactElement = __webpack_require__(113);
	var ReactPropTypes = __webpack_require__(135);
	var ReactVersion = __webpack_require__(136);

	var onlyChild = __webpack_require__(137);
	var warning = __webpack_require__(115);

	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;

	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(131);
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}

	var __spread = _assign;

	if (process.env.NODE_ENV !== 'production') {
	  var warned = false;
	  __spread = function () {
	    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
	    warned = true;
	    return _assign.apply(null, arguments);
	  };
	}

	var React = {

	  // Modern

	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },

	  Component: ReactComponent,
	  PureComponent: ReactPureComponent,

	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,

	  // Classic

	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function (mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },

	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,

	  version: ReactVersion,

	  // Deprecated hook for JSX spread, don't use this for anything.
	  __spread: __spread
	};

	module.exports = React;

/***/ },
/* 108 */
/***/ function(module, exports) {

	module.exports = require("object-assign");

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */

	'use strict';

	var PooledClass = __webpack_require__(110);
	var ReactElement = __webpack_require__(113);

	var emptyFunction = __webpack_require__(116);
	var traverseAllChildren = __webpack_require__(118);

	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;

	var userProvidedKeyEscapeRegex = /\/+/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
	}

	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;

	  func.call(context, child, bookKeeping.count++);
	}

	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}

	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;


	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}

	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}

	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}

	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}

	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}

	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}

	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};

	module.exports = ReactChildren;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(111);

	var invariant = __webpack_require__(112);

	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function (copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};

	var twoArgumentPooler = function (a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};

	var threeArgumentPooler = function (a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};

	var fourArgumentPooler = function (a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};

	var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};

	var standardReleaser = function (instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};

	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;

	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances.
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function (CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};

	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};

	module.exports = PooledClass;

/***/ },
/* 111 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule reactProdInvariant
	 * 
	 */
	'use strict';

	/**
	 * WARNING: DO NOT manually require this module.
	 * This is a replacement for `invariant(...)` used by the error code system
	 * and will _only_ be required by the corresponding babel pass.
	 * It always throws.
	 */

	function reactProdInvariant(code) {
	  var argCount = arguments.length - 1;

	  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

	  for (var argIdx = 0; argIdx < argCount; argIdx++) {
	    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
	  }

	  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

	  var error = new Error(message);
	  error.name = 'Invariant Violation';
	  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

	  throw error;
	}

	module.exports = reactProdInvariant;

/***/ },
/* 112 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */

	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }

	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }

	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}

	module.exports = invariant;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */

	'use strict';

	var _assign = __webpack_require__(108);

	var ReactCurrentOwner = __webpack_require__(114);

	var warning = __webpack_require__(115);
	var canDefineProperty = __webpack_require__(117);
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};

	var specialPropKeyWarningShown, specialPropRefWarningShown;

	function hasValidRef(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'ref')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.ref !== undefined;
	}

	function hasValidKey(config) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (hasOwnProperty.call(config, 'key')) {
	      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
	      if (getter && getter.isReactWarning) {
	        return false;
	      }
	    }
	  }
	  return config.key !== undefined;
	}

	function defineKeyPropWarningGetter(props, displayName) {
	  var warnAboutAccessingKey = function () {
	    if (!specialPropKeyWarningShown) {
	      specialPropKeyWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingKey.isReactWarning = true;
	  Object.defineProperty(props, 'key', {
	    get: warnAboutAccessingKey,
	    configurable: true
	  });
	}

	function defineRefPropWarningGetter(props, displayName) {
	  var warnAboutAccessingRef = function () {
	    if (!specialPropRefWarningShown) {
	      specialPropRefWarningShown = true;
	      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
	    }
	  };
	  warnAboutAccessingRef.isReactWarning = true;
	  Object.defineProperty(props, 'ref', {
	    get: warnAboutAccessingRef,
	    configurable: true
	  });
	}

	/**
	 * Factory method to create a new React element. This no longer adheres to
	 * the class pattern, so do not use new to call it. Also, no instanceof check
	 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
	 * if something is a React Element.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function (type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,

	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,

	    // Record the component responsible for creating this element.
	    _owner: owner
	  };

	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	    var shadowChildren = Array.isArray(props.children) ? props.children.slice(0) : props.children;

	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      Object.defineProperty(element, '_shadowChildren', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: shadowChildren
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._shadowChildren = shadowChildren;
	      element._source = source;
	    }
	    if (Object.freeze) {
	      Object.freeze(element.props);
	      Object.freeze(element);
	    }
	  }

	  return element;
	};

	/**
	 * Create and return a new ReactElement of the given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
	 */
	ReactElement.createElement = function (type, config, children) {
	  var propName;

	  // Reserved names are extracted
	  var props = {};

	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;

	  if (config != null) {
	    if (hasValidRef(config)) {
	      ref = config.ref;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }

	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }

	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (props[propName] === undefined) {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (key || ref) {
	      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
	        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
	        if (key) {
	          defineKeyPropWarningGetter(props, displayName);
	        }
	        if (ref) {
	          defineRefPropWarningGetter(props, displayName);
	        }
	      }
	    }
	  }
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};

	/**
	 * Return a function that produces ReactElements of a given type.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
	 */
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};

	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

	  return newElement;
	};

	/**
	 * Clone and return a new ReactElement using element as the starting point.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
	 */
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;

	  // Original props are copied
	  var props = _assign({}, element.props);

	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;

	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;

	  if (config != null) {
	    if (hasValidRef(config)) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (hasValidKey(config)) {
	      key = '' + config.key;
	    }

	    // Remaining properties override existing props
	    var defaultProps;
	    if (element.type && element.type.defaultProps) {
	      defaultProps = element.type.defaultProps;
	    }
	    for (propName in config) {
	      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        if (config[propName] === undefined && defaultProps !== undefined) {
	          // Resolve default props
	          props[propName] = defaultProps[propName];
	        } else {
	          props[propName] = config[propName];
	        }
	      }
	    }
	  }

	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }

	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};

	/**
	 * Verifies the object is a ReactElement.
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};

	ReactElement.REACT_ELEMENT_TYPE = REACT_ELEMENT_TYPE;

	module.exports = ReactElement;

/***/ },
/* 114 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */

	'use strict';

	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */

	var ReactCurrentOwner = {

	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null

	};

	module.exports = ReactCurrentOwner;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var emptyFunction = __webpack_require__(116);

	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */

	var warning = emptyFunction;

	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var printWarning = function printWarning(format) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    };

	    warning = function warning(condition, format) {
	      if (format === undefined) {
	        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	      }

	      if (format.indexOf('Failed Composite propType: ') === 0) {
	        return; // Ignore CompositeComponent proptype check.
	      }

	      if (!condition) {
	        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
	          args[_key2 - 2] = arguments[_key2];
	        }

	        printWarning.apply(undefined, [format].concat(args));
	      }
	    };
	  })();
	}

	module.exports = warning;

/***/ },
/* 116 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * 
	 */

	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}

	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	var emptyFunction = function emptyFunction() {};

	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};

	module.exports = emptyFunction;

/***/ },
/* 117 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */

	'use strict';

	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function () {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}

	module.exports = canDefineProperty;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(111);

	var ReactCurrentOwner = __webpack_require__(114);
	var ReactElement = __webpack_require__(113);

	var getIteratorFn = __webpack_require__(119);
	var invariant = __webpack_require__(112);
	var KeyEscapeUtils = __webpack_require__(120);
	var warning = __webpack_require__(115);

	var SEPARATOR = '.';
	var SUBSEPARATOR = ':';

	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */

	var didWarnAboutMaps = false;

	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  // Do some typechecking here since we call this blindly. We want to ensure
	  // that we don't block potential future ES APIs.
	  if (component && typeof component === 'object' && component.key != null) {
	    // Explicit key
	    return KeyEscapeUtils.escape(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}

	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children;

	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }

	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }

	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          var mapsAsChildrenAddendum = '';
	          if (ReactCurrentOwner.current) {
	            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
	            if (mapsAsChildrenOwnerName) {
	              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
	            }
	          }
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
	    }
	  }

	  return subtreeCount;
	}

	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }

	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}

	module.exports = traverseAllChildren;

/***/ },
/* 119 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * 
	 */

	'use strict';

	/* global Symbol */

	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}

	module.exports = getIteratorFn;

/***/ },
/* 120 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule KeyEscapeUtils
	 * 
	 */

	'use strict';

	/**
	 * Escape and wrap key so it is safe to use as a reactid
	 *
	 * @param {string} key to be escaped.
	 * @return {string} the escaped key.
	 */

	function escape(key) {
	  var escapeRegex = /[=:]/g;
	  var escaperLookup = {
	    '=': '=0',
	    ':': '=2'
	  };
	  var escapedString = ('' + key).replace(escapeRegex, function (match) {
	    return escaperLookup[match];
	  });

	  return '$' + escapedString;
	}

	/**
	 * Unescape and unwrap key for human-readable display
	 *
	 * @param {string} key to unescape.
	 * @return {string} the unescaped key.
	 */
	function unescape(key) {
	  var unescapeRegex = /(=0|=2)/g;
	  var unescaperLookup = {
	    '=0': '=',
	    '=2': ':'
	  };
	  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

	  return ('' + keySubstring).replace(unescapeRegex, function (match) {
	    return unescaperLookup[match];
	  });
	}

	var KeyEscapeUtils = {
	  escape: escape,
	  unescape: unescape
	};

	module.exports = KeyEscapeUtils;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(111);

	var ReactNoopUpdateQueue = __webpack_require__(122);

	var canDefineProperty = __webpack_require__(117);
	var emptyObject = __webpack_require__(123);
	var invariant = __webpack_require__(112);
	var warning = __webpack_require__(115);

	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}

	ReactComponent.prototype.isReactComponent = {};

	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'setState');
	  }
	};

	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback, 'forceUpdate');
	  }
	};

	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
	  };
	  var defineDeprecationWarning = function (methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function () {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}

	module.exports = ReactComponent;

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */

	'use strict';

	var warning = __webpack_require__(115);

	function warnNoop(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    var constructor = publicInstance.constructor;
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
	  }
	}

	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function (publicInstance) {
	    return false;
	  },

	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function (publicInstance, callback) {},

	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function (publicInstance) {
	    warnNoop(publicInstance, 'forceUpdate');
	  },

	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function (publicInstance, completeState) {
	    warnNoop(publicInstance, 'replaceState');
	  },

	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function (publicInstance, partialState) {
	    warnNoop(publicInstance, 'setState');
	  }
	};

	module.exports = ReactNoopUpdateQueue;

/***/ },
/* 123 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	'use strict';

	var emptyObject = {};

	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}

	module.exports = emptyObject;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPureComponent
	 */

	'use strict';

	var _assign = __webpack_require__(108);

	var ReactComponent = __webpack_require__(121);
	var ReactNoopUpdateQueue = __webpack_require__(122);

	var emptyObject = __webpack_require__(123);

	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactPureComponent(props, context, updater) {
	  // Duplicated from ReactComponent.
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}

	function ComponentDummy() {}
	ComponentDummy.prototype = ReactComponent.prototype;
	ReactPureComponent.prototype = new ComponentDummy();
	ReactPureComponent.prototype.constructor = ReactPureComponent;
	// Avoid an extra prototype jump for these methods.
	_assign(ReactPureComponent.prototype, ReactComponent.prototype);
	ReactPureComponent.prototype.isPureReactComponent = true;

	module.exports = ReactPureComponent;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(111),
	    _assign = __webpack_require__(108);

	var ReactComponent = __webpack_require__(121);
	var ReactElement = __webpack_require__(113);
	var ReactPropTypeLocations = __webpack_require__(126);
	var ReactPropTypeLocationNames = __webpack_require__(128);
	var ReactNoopUpdateQueue = __webpack_require__(122);

	var emptyObject = __webpack_require__(123);
	var invariant = __webpack_require__(112);
	var keyMirror = __webpack_require__(127);
	var keyOf = __webpack_require__(129);
	var warning = __webpack_require__(115);

	var MIXINS_KEY = keyOf({ mixins: null });

	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});

	var injectedMixins = [];

	/**
	 * Composite components are higher-level components that compose other composite
	 * or host components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {

	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,

	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,

	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,

	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,

	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,

	  // ==== Definition methods ====

	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,

	  // ==== Delegate methods ====

	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,

	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,

	  // ==== Advanced methods ====

	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE

	};

	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function (Constructor, displayName) {
	    Constructor.displayName = displayName;
	  },
	  mixins: function (Constructor, mixins) {
	    if (mixins) {
	      for (var i = 0; i < mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function (Constructor, childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
	  },
	  contextTypes: function (Constructor, contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function (Constructor, getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = getDefaultProps;
	    }
	  },
	  propTypes: function (Constructor, propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
	  },
	  statics: function (Constructor, statics) {
	    mixStaticSpecIntoComponent(Constructor, statics);
	  },
	  autobind: function () {} };

	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but only in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
	    }
	  }
	}

	function validateMethodOverride(isAlreadyDefined, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
	  }

	  // Disallow defining methods more than once unless explicitly allowed.
	  if (isAlreadyDefined) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
	  }
	}

	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classes.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    if (process.env.NODE_ENV !== 'production') {
	      var typeofSpec = typeof spec;
	      var isMixinValid = typeofSpec === 'object' && spec !== null;

	      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
	    }

	    return;
	  }

	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;

	  var proto = Constructor.prototype;
	  var autoBindPairs = proto.__reactAutoBindPairs;

	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }

	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }

	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }

	    var property = spec[name];
	    var isAlreadyDefined = proto.hasOwnProperty(name);
	    validateMethodOverride(isAlreadyDefined, name);

	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

	      if (shouldAutoBind) {
	        autoBindPairs.push(name, property);
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];

	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;

	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}

	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }

	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;

	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
	    Constructor[name] = property;
	  }
	}

	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;

	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}

	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}

	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}

	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }

	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	    };
	  }
	  return boundMethod;
	}

	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  var pairs = component.__reactAutoBindPairs;
	  for (var i = 0; i < pairs.length; i += 2) {
	    var autoBindKey = pairs[i];
	    var method = pairs[i + 1];
	    component[autoBindKey] = bindAutoBindMethod(component, method);
	  }
	}

	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {

	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function (newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback, 'replaceState');
	    }
	  },

	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function () {
	    return this.updater.isMounted(this);
	  }
	};

	var ReactClassComponent = function () {};
	_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {

	  /**
	   * Creates a composite component class given a class specification.
	   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function (spec) {
	    var Constructor = function (props, context, updater) {
	      // This constructor gets overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.

	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
	      }

	      // Wire up auto-binding
	      if (this.__reactAutoBindPairs.length) {
	        bindAutoBindMethods(this);
	      }

	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;

	      this.state = null;

	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.

	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (initialState === undefined && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;

	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	    Constructor.prototype.__reactAutoBindPairs = [];

	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

	    mixSpecIntoComponent(Constructor, spec);

	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }

	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }

	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;

	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
	    }

	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }

	    return Constructor;
	  },

	  injection: {
	    injectMixin: function (mixin) {
	      injectedMixins.push(mixin);
	    }
	  }

	};

	module.exports = ReactClass;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */

	'use strict';

	var keyMirror = __webpack_require__(127);

	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});

	module.exports = ReactPropTypeLocations;

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 */

	'use strict';

	var invariant = __webpack_require__(112);

	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function keyMirror(obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : void 0;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};

	module.exports = keyMirror;

/***/ },
/* 128 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */

	'use strict';

	var ReactPropTypeLocationNames = {};

	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}

	module.exports = ReactPropTypeLocationNames;

/***/ },
/* 129 */
/***/ function(module, exports) {

	"use strict";

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 */

	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	var keyOf = function keyOf(oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};

	module.exports = keyOf;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 */

	'use strict';

	var ReactElement = __webpack_require__(113);

	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @private
	 */
	var createDOMFactory = ReactElement.createFactory;
	if (process.env.NODE_ENV !== 'production') {
	  var ReactElementValidator = __webpack_require__(131);
	  createDOMFactory = ReactElementValidator.createFactory;
	}

	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = {
	  a: createDOMFactory('a'),
	  abbr: createDOMFactory('abbr'),
	  address: createDOMFactory('address'),
	  area: createDOMFactory('area'),
	  article: createDOMFactory('article'),
	  aside: createDOMFactory('aside'),
	  audio: createDOMFactory('audio'),
	  b: createDOMFactory('b'),
	  base: createDOMFactory('base'),
	  bdi: createDOMFactory('bdi'),
	  bdo: createDOMFactory('bdo'),
	  big: createDOMFactory('big'),
	  blockquote: createDOMFactory('blockquote'),
	  body: createDOMFactory('body'),
	  br: createDOMFactory('br'),
	  button: createDOMFactory('button'),
	  canvas: createDOMFactory('canvas'),
	  caption: createDOMFactory('caption'),
	  cite: createDOMFactory('cite'),
	  code: createDOMFactory('code'),
	  col: createDOMFactory('col'),
	  colgroup: createDOMFactory('colgroup'),
	  data: createDOMFactory('data'),
	  datalist: createDOMFactory('datalist'),
	  dd: createDOMFactory('dd'),
	  del: createDOMFactory('del'),
	  details: createDOMFactory('details'),
	  dfn: createDOMFactory('dfn'),
	  dialog: createDOMFactory('dialog'),
	  div: createDOMFactory('div'),
	  dl: createDOMFactory('dl'),
	  dt: createDOMFactory('dt'),
	  em: createDOMFactory('em'),
	  embed: createDOMFactory('embed'),
	  fieldset: createDOMFactory('fieldset'),
	  figcaption: createDOMFactory('figcaption'),
	  figure: createDOMFactory('figure'),
	  footer: createDOMFactory('footer'),
	  form: createDOMFactory('form'),
	  h1: createDOMFactory('h1'),
	  h2: createDOMFactory('h2'),
	  h3: createDOMFactory('h3'),
	  h4: createDOMFactory('h4'),
	  h5: createDOMFactory('h5'),
	  h6: createDOMFactory('h6'),
	  head: createDOMFactory('head'),
	  header: createDOMFactory('header'),
	  hgroup: createDOMFactory('hgroup'),
	  hr: createDOMFactory('hr'),
	  html: createDOMFactory('html'),
	  i: createDOMFactory('i'),
	  iframe: createDOMFactory('iframe'),
	  img: createDOMFactory('img'),
	  input: createDOMFactory('input'),
	  ins: createDOMFactory('ins'),
	  kbd: createDOMFactory('kbd'),
	  keygen: createDOMFactory('keygen'),
	  label: createDOMFactory('label'),
	  legend: createDOMFactory('legend'),
	  li: createDOMFactory('li'),
	  link: createDOMFactory('link'),
	  main: createDOMFactory('main'),
	  map: createDOMFactory('map'),
	  mark: createDOMFactory('mark'),
	  menu: createDOMFactory('menu'),
	  menuitem: createDOMFactory('menuitem'),
	  meta: createDOMFactory('meta'),
	  meter: createDOMFactory('meter'),
	  nav: createDOMFactory('nav'),
	  noscript: createDOMFactory('noscript'),
	  object: createDOMFactory('object'),
	  ol: createDOMFactory('ol'),
	  optgroup: createDOMFactory('optgroup'),
	  option: createDOMFactory('option'),
	  output: createDOMFactory('output'),
	  p: createDOMFactory('p'),
	  param: createDOMFactory('param'),
	  picture: createDOMFactory('picture'),
	  pre: createDOMFactory('pre'),
	  progress: createDOMFactory('progress'),
	  q: createDOMFactory('q'),
	  rp: createDOMFactory('rp'),
	  rt: createDOMFactory('rt'),
	  ruby: createDOMFactory('ruby'),
	  s: createDOMFactory('s'),
	  samp: createDOMFactory('samp'),
	  script: createDOMFactory('script'),
	  section: createDOMFactory('section'),
	  select: createDOMFactory('select'),
	  small: createDOMFactory('small'),
	  source: createDOMFactory('source'),
	  span: createDOMFactory('span'),
	  strong: createDOMFactory('strong'),
	  style: createDOMFactory('style'),
	  sub: createDOMFactory('sub'),
	  summary: createDOMFactory('summary'),
	  sup: createDOMFactory('sup'),
	  table: createDOMFactory('table'),
	  tbody: createDOMFactory('tbody'),
	  td: createDOMFactory('td'),
	  textarea: createDOMFactory('textarea'),
	  tfoot: createDOMFactory('tfoot'),
	  th: createDOMFactory('th'),
	  thead: createDOMFactory('thead'),
	  time: createDOMFactory('time'),
	  title: createDOMFactory('title'),
	  tr: createDOMFactory('tr'),
	  track: createDOMFactory('track'),
	  u: createDOMFactory('u'),
	  ul: createDOMFactory('ul'),
	  'var': createDOMFactory('var'),
	  video: createDOMFactory('video'),
	  wbr: createDOMFactory('wbr'),

	  // SVG
	  circle: createDOMFactory('circle'),
	  clipPath: createDOMFactory('clipPath'),
	  defs: createDOMFactory('defs'),
	  ellipse: createDOMFactory('ellipse'),
	  g: createDOMFactory('g'),
	  image: createDOMFactory('image'),
	  line: createDOMFactory('line'),
	  linearGradient: createDOMFactory('linearGradient'),
	  mask: createDOMFactory('mask'),
	  path: createDOMFactory('path'),
	  pattern: createDOMFactory('pattern'),
	  polygon: createDOMFactory('polygon'),
	  polyline: createDOMFactory('polyline'),
	  radialGradient: createDOMFactory('radialGradient'),
	  rect: createDOMFactory('rect'),
	  stop: createDOMFactory('stop'),
	  svg: createDOMFactory('svg'),
	  text: createDOMFactory('text'),
	  tspan: createDOMFactory('tspan')
	};

	module.exports = ReactDOMFactories;

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */

	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */

	'use strict';

	var ReactCurrentOwner = __webpack_require__(114);
	var ReactComponentTreeHook = __webpack_require__(132);
	var ReactElement = __webpack_require__(113);
	var ReactPropTypeLocations = __webpack_require__(126);

	var checkReactTypeSpec = __webpack_require__(133);

	var canDefineProperty = __webpack_require__(117);
	var getIteratorFn = __webpack_require__(119);
	var warning = __webpack_require__(115);

	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}

	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};

	function getCurrentComponentErrorInfo(parentType) {
	  var info = getDeclarationErrorAddendum();

	  if (!info) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      info = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	  return info;
	}

	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it. Error statuses are cached so a warning
	 * will only be shown once.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;

	  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

	  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
	  if (memoizer[currentComponentErrorInfo]) {
	    return;
	  }
	  memoizer[currentComponentErrorInfo] = true;

	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  var childOwner = '';
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }

	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
	}

	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if (typeof node !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}

	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkReactTypeSpec(componentClass.propTypes, element.props, ReactPropTypeLocations.prop, name, element, null);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
	  }
	}

	var ReactElementValidator = {

	  createElement: function (type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    if (!validType) {
	      process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
	    }

	    var element = ReactElement.createElement.apply(this, arguments);

	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }

	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }

	    validatePropTypes(element);

	    return element;
	  },

	  createFactory: function (type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;

	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function () {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }

	    return validatedFactory;
	  },

	  cloneElement: function (element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }

	};

	module.exports = ReactElementValidator;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2016-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentTreeHook
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(111);

	var ReactCurrentOwner = __webpack_require__(114);

	var invariant = __webpack_require__(112);
	var warning = __webpack_require__(115);

	function isNative(fn) {
	  // Based on isNative() from Lodash
	  var funcToString = Function.prototype.toString;
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	  var reIsNative = RegExp('^' + funcToString
	  // Take an example native function source for comparison
	  .call(hasOwnProperty)
	  // Strip regex characters so we can use it for regex
	  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  // Remove hasOwnProperty from the template to make it generic
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
	  try {
	    var source = funcToString.call(fn);
	    return reIsNative.test(source);
	  } catch (err) {
	    return false;
	  }
	}

	var canUseCollections =
	// Array.from
	typeof Array.from === 'function' &&
	// Map
	typeof Map === 'function' && isNative(Map) &&
	// Map.prototype.keys
	Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
	// Set
	typeof Set === 'function' && isNative(Set) &&
	// Set.prototype.keys
	Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

	var itemMap;
	var rootIDSet;

	var itemByKey;
	var rootByKey;

	if (canUseCollections) {
	  itemMap = new Map();
	  rootIDSet = new Set();
	} else {
	  itemByKey = {};
	  rootByKey = {};
	}

	var unmountedIDs = [];

	// Use non-numeric keys to prevent V8 performance issues:
	// https://github.com/facebook/react/pull/7232
	function getKeyFromID(id) {
	  return '.' + id;
	}
	function getIDFromKey(key) {
	  return parseInt(key.substr(1), 10);
	}

	function get(id) {
	  if (canUseCollections) {
	    return itemMap.get(id);
	  } else {
	    var key = getKeyFromID(id);
	    return itemByKey[key];
	  }
	}

	function remove(id) {
	  if (canUseCollections) {
	    itemMap['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete itemByKey[key];
	  }
	}

	function create(id, element, parentID) {
	  var item = {
	    element: element,
	    parentID: parentID,
	    text: null,
	    childIDs: [],
	    isMounted: false,
	    updateCount: 0
	  };

	  if (canUseCollections) {
	    itemMap.set(id, item);
	  } else {
	    var key = getKeyFromID(id);
	    itemByKey[key] = item;
	  }
	}

	function addRoot(id) {
	  if (canUseCollections) {
	    rootIDSet.add(id);
	  } else {
	    var key = getKeyFromID(id);
	    rootByKey[key] = true;
	  }
	}

	function removeRoot(id) {
	  if (canUseCollections) {
	    rootIDSet['delete'](id);
	  } else {
	    var key = getKeyFromID(id);
	    delete rootByKey[key];
	  }
	}

	function getRegisteredIDs() {
	  if (canUseCollections) {
	    return Array.from(itemMap.keys());
	  } else {
	    return Object.keys(itemByKey).map(getIDFromKey);
	  }
	}

	function getRootIDs() {
	  if (canUseCollections) {
	    return Array.from(rootIDSet.keys());
	  } else {
	    return Object.keys(rootByKey).map(getIDFromKey);
	  }
	}

	function purgeDeep(id) {
	  var item = get(id);
	  if (item) {
	    var childIDs = item.childIDs;

	    remove(id);
	    childIDs.forEach(purgeDeep);
	  }
	}

	function describeComponentFrame(name, source, ownerName) {
	  return '\n    in ' + name + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
	}

	function getDisplayName(element) {
	  if (element == null) {
	    return '#empty';
	  } else if (typeof element === 'string' || typeof element === 'number') {
	    return '#text';
	  } else if (typeof element.type === 'string') {
	    return element.type;
	  } else {
	    return element.type.displayName || element.type.name || 'Unknown';
	  }
	}

	function describeID(id) {
	  var name = ReactComponentTreeHook.getDisplayName(id);
	  var element = ReactComponentTreeHook.getElement(id);
	  var ownerID = ReactComponentTreeHook.getOwnerID(id);
	  var ownerName;
	  if (ownerID) {
	    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
	  }
	  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
	  return describeComponentFrame(name, element && element._source, ownerName);
	}

	var ReactComponentTreeHook = {
	  onSetChildren: function (id, nextChildIDs) {
	    var item = get(id);
	    item.childIDs = nextChildIDs;

	    for (var i = 0; i < nextChildIDs.length; i++) {
	      var nextChildID = nextChildIDs[i];
	      var nextChild = get(nextChildID);
	      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
	      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
	      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
	      if (nextChild.parentID == null) {
	        nextChild.parentID = id;
	        // TODO: This shouldn't be necessary but mounting a new root during in
	        // componentWillMount currently causes not-yet-mounted components to
	        // be purged from our tree data so their parent ID is missing.
	      }
	      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
	    }
	  },
	  onBeforeMountComponent: function (id, element, parentID) {
	    create(id, element, parentID);
	  },
	  onBeforeUpdateComponent: function (id, element) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.element = element;
	  },
	  onMountComponent: function (id) {
	    var item = get(id);
	    item.isMounted = true;
	    var isRoot = item.parentID === 0;
	    if (isRoot) {
	      addRoot(id);
	    }
	  },
	  onUpdateComponent: function (id) {
	    var item = get(id);
	    if (!item || !item.isMounted) {
	      // We may end up here as a result of setState() in componentWillUnmount().
	      // In this case, ignore the element.
	      return;
	    }
	    item.updateCount++;
	  },
	  onUnmountComponent: function (id) {
	    var item = get(id);
	    if (item) {
	      // We need to check if it exists.
	      // `item` might not exist if it is inside an error boundary, and a sibling
	      // error boundary child threw while mounting. Then this instance never
	      // got a chance to mount, but it still gets an unmounting event during
	      // the error boundary cleanup.
	      item.isMounted = false;
	      var isRoot = item.parentID === 0;
	      if (isRoot) {
	        removeRoot(id);
	      }
	    }
	    unmountedIDs.push(id);
	  },
	  purgeUnmountedComponents: function () {
	    if (ReactComponentTreeHook._preventPurging) {
	      // Should only be used for testing.
	      return;
	    }

	    for (var i = 0; i < unmountedIDs.length; i++) {
	      var id = unmountedIDs[i];
	      purgeDeep(id);
	    }
	    unmountedIDs.length = 0;
	  },
	  isMounted: function (id) {
	    var item = get(id);
	    return item ? item.isMounted : false;
	  },
	  getCurrentStackAddendum: function (topElement) {
	    var info = '';
	    if (topElement) {
	      var type = topElement.type;
	      var name = typeof type === 'function' ? type.displayName || type.name : type;
	      var owner = topElement._owner;
	      info += describeComponentFrame(name || 'Unknown', topElement._source, owner && owner.getName());
	    }

	    var currentOwner = ReactCurrentOwner.current;
	    var id = currentOwner && currentOwner._debugID;

	    info += ReactComponentTreeHook.getStackAddendumByID(id);
	    return info;
	  },
	  getStackAddendumByID: function (id) {
	    var info = '';
	    while (id) {
	      info += describeID(id);
	      id = ReactComponentTreeHook.getParentID(id);
	    }
	    return info;
	  },
	  getChildIDs: function (id) {
	    var item = get(id);
	    return item ? item.childIDs : [];
	  },
	  getDisplayName: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element) {
	      return null;
	    }
	    return getDisplayName(element);
	  },
	  getElement: function (id) {
	    var item = get(id);
	    return item ? item.element : null;
	  },
	  getOwnerID: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (!element || !element._owner) {
	      return null;
	    }
	    return element._owner._debugID;
	  },
	  getParentID: function (id) {
	    var item = get(id);
	    return item ? item.parentID : null;
	  },
	  getSource: function (id) {
	    var item = get(id);
	    var element = item ? item.element : null;
	    var source = element != null ? element._source : null;
	    return source;
	  },
	  getText: function (id) {
	    var element = ReactComponentTreeHook.getElement(id);
	    if (typeof element === 'string') {
	      return element;
	    } else if (typeof element === 'number') {
	      return '' + element;
	    } else {
	      return null;
	    }
	  },
	  getUpdateCount: function (id) {
	    var item = get(id);
	    return item ? item.updateCount : 0;
	  },


	  getRegisteredIDs: getRegisteredIDs,

	  getRootIDs: getRootIDs
	};

	module.exports = ReactComponentTreeHook;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule checkReactTypeSpec
	 */

	'use strict';

	var _prodInvariant = __webpack_require__(111);

	var ReactPropTypeLocationNames = __webpack_require__(128);
	var ReactPropTypesSecret = __webpack_require__(134);

	var invariant = __webpack_require__(112);
	var warning = __webpack_require__(115);

	var ReactComponentTreeHook;

	if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
	  // Temporary hack.
	  // Inline requires don't work well with Jest:
	  // https://github.com/facebook/react/issues/7240
	  // Remove the inline requires when we don't need them anymore:
	  // https://github.com/facebook/react/pull/7178
	  ReactComponentTreeHook = __webpack_require__(132);
	}

	var loggedTypeFailures = {};

	/**
	 * Assert that the values match with the type specs.
	 * Error messages are memorized and will only be shown once.
	 *
	 * @param {object} typeSpecs Map of name to a ReactPropType
	 * @param {object} values Runtime values that need to be type-checked
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @param {string} componentName Name of the component for error messages.
	 * @param {?object} element The React element that is being type-checked
	 * @param {?number} debugID The React component instance that is being type-checked
	 * @private
	 */
	function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
	  for (var typeSpecName in typeSpecs) {
	    if (typeSpecs.hasOwnProperty(typeSpecName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
	        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;

	        var componentStackInfo = '';

	        if (process.env.NODE_ENV !== 'production') {
	          if (!ReactComponentTreeHook) {
	            ReactComponentTreeHook = __webpack_require__(132);
	          }
	          if (debugID !== null) {
	            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
	          } else if (element !== null) {
	            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
	          }
	        }

	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
	      }
	    }
	  }
	}

	module.exports = checkReactTypeSpec;

/***/ },
/* 134 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypesSecret
	 */

	'use strict';

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	module.exports = ReactPropTypesSecret;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */

	'use strict';

	var ReactElement = __webpack_require__(113);
	var ReactPropTypeLocationNames = __webpack_require__(128);
	var ReactPropTypesSecret = __webpack_require__(134);

	var emptyFunction = __webpack_require__(116);
	var getIteratorFn = __webpack_require__(119);
	var warning = __webpack_require__(115);

	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */

	var ANONYMOUS = '<<anonymous>>';

	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	  symbol: createPrimitiveTypeChecker('symbol'),

	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};

	/**
	 * inlined Object.is polyfill to avoid requiring consumers ship their own
	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
	 */
	/*eslint-disable no-self-compare*/
	function is(x, y) {
	  // SameValue algorithm
	  if (x === y) {
	    // Steps 1-5, 7-10
	    // Steps 6.b-6.e: +0 != -0
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    // Step 6.a: NaN == NaN
	    return x !== x && y !== y;
	  }
	}
	/*eslint-enable no-self-compare*/

	/**
	 * We use an Error-like object for backward compatibility as people may call
	 * PropTypes directly and inspect their output. However we don't use real
	 * Errors anymore. We don't inspect their stack anyway, and creating them
	 * is prohibitively expensive if they are created too often, such as what
	 * happens in oneOfType() for any type before the one that matched.
	 */
	function PropTypeError(message) {
	  this.message = message;
	  this.stack = '';
	}
	// Make `instanceof Error` still work for returned errors.
	PropTypeError.prototype = Error.prototype;

	function createChainableTypeChecker(validate) {
	  if (process.env.NODE_ENV !== 'production') {
	    var manualPropTypeCallCache = {};
	  }
	  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (process.env.NODE_ENV !== 'production') {
	      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
	        var cacheKey = componentName + ':' + propName;
	        if (!manualPropTypeCallCache[cacheKey]) {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in the next major version. You may be ' + 'seeing this warning due to a third-party PropTypes library. ' + 'See https://fb.me/react-warning-dont-call-proptypes for details.', propFullName, componentName) : void 0;
	          manualPropTypeCallCache[cacheKey] = true;
	        }
	      }
	    }
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new PropTypeError('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }

	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);

	  return chainedCheckType;
	}

	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName, secret) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);

	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}

	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
	    }
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!ReactElement.isValidElement(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }

	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (is(propValue, expectedValues[i])) {
	        return null;
	      }
	    }

	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}

	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (typeof typeChecker !== 'function') {
	      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
	    }
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
	    return emptyFunction.thatReturnsNull;
	  }

	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
	        return null;
	      }
	    }

	    var locationName = ReactPropTypeLocationNames[location];
	    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}

	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}

	function isNode(propValue) {
	  switch (typeof propValue) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }

	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }

	      return true;
	    default:
	      return false;
	  }
	}

	function isSymbol(propType, propValue) {
	  // Native Symbol.
	  if (propType === 'symbol') {
	    return true;
	  }

	  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
	  if (propValue['@@toStringTag'] === 'Symbol') {
	    return true;
	  }

	  // Fallback for non-spec compliant Symbols which are polyfilled.
	  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
	    return true;
	  }

	  return false;
	}

	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue;
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  if (isSymbol(propType, propValue)) {
	    return 'symbol';
	  }
	  return propType;
	}

	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}

	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return ANONYMOUS;
	  }
	  return propValue.constructor.name;
	}

	module.exports = ReactPropTypes;

/***/ },
/* 136 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */

	'use strict';

	module.exports = '15.3.2';

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';

	var _prodInvariant = __webpack_require__(111);

	var ReactElement = __webpack_require__(113);

	var invariant = __webpack_require__(112);

	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection.
	 *
	 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
	 *
	 * The current implementation of this function assumes that a single child gets
	 * passed without a wrapper, but the purpose of this helper function is to
	 * abstract away the particular structure of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactElement} The first and only `ReactElement` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
	  return children;
	}

	module.exports = onlyChild;

/***/ },
/* 138 */
/***/ function(module, exports) {

	module.exports = require("react-dom");

/***/ },
/* 139 */
/***/ function(module, exports) {

	"use strict";
	function parseCommentMetadata(name, code) {
	    const comments = code.match(/\/\*[\s\S]+?\*\//g) || [];
	    const matches = [];
	    for (const comment of comments) {
	        const match = comment.match(/\/\*\s?(\w+):/);
	        if (match && match[1] === name) {
	            const json = comment.match(/\/\*\w+:\s*([\s\S]+)\*\//)[1];
	            matches.push(JSON.parse(json));
	        }
	    }
	    return matches;
	}
	exports.parseCommentMetadata = parseCommentMetadata;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	// export { default as Model } from './base';
	__export(__webpack_require__(141));


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const ioc_1 = __webpack_require__(54);
	const decorators_1 = __webpack_require__(69);
	const observable_1 = __webpack_require__(91);
	class File extends observable_1.Observable {
	    constructor() {
	        super();
	        // this.updateFromSourceData(data);
	    }
	    dispose() {
	        if (this._watcher) {
	            this._watcher.dispose();
	            this._watcher = undefined;
	        }
	    }
	    save() {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.mtime = Date.now();
	        });
	    }
	}
	__decorate([
	    decorators_1.bindable()
	], File.prototype, "path", void 0);
	__decorate([
	    decorators_1.bindable()
	], File.prototype, "mtime", void 0);
	__decorate([
	    decorators_1.bindable()
	], File.prototype, "content", void 0);
	__decorate([
	    decorators_1.inject(ioc_1.InjectorProvider.ID)
	], File.prototype, "_injector", void 0);
	__decorate([
	    decorators_1.inject(ioc_1.PrivateBusProvider.ID)
	], File.prototype, "_bus", void 0);
	exports.File = File;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(143));


/***/ },
/* 143 */
/***/ function(module, exports) {

	"use strict";
	class DisposableCollection extends Array {
	    constructor(...items) {
	        super(...items);
	    }
	    dispose() {
	        for (const disposable of this)
	            disposable.dispose();
	    }
	}
	exports.DisposableCollection = DisposableCollection;


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const base_1 = __webpack_require__(145);
	exports.IReference = base_1.IReference;
	class ValueReference {
	    constructor(value) {
	        this.value = value;
	    }
	}
	exports.ValueReference = ValueReference;
	class MetadataValueReference {
	    constructor(_metadata, _key) {
	        this._metadata = _metadata;
	        this._key = _key;
	    }
	    get value() {
	        return this._metadata.get(this._key);
	    }
	    set value(value) {
	        this._metadata.set(this._key, value);
	    }
	}
	exports.MetadataValueReference = MetadataValueReference;
	class MinMaxValueReference {
	    constructor(_target, _min = -Infinity, _max = Infinity) {
	        this._target = _target;
	        this._min = _min;
	        this._max = _max;
	    }
	    get value() {
	        return this._minMax(this._target.value);
	    }
	    set value(value) {
	        this._target.value = this._minMax(value);
	    }
	    _minMax(value) {
	        return Math.max(this._min, Math.min(this._max, value));
	    }
	}
	exports.MinMaxValueReference = MinMaxValueReference;
	class DefaultValueReference {
	    constructor(_target, defaultValue) {
	        this._target = _target;
	        this.defaultValue = defaultValue;
	    }
	    get value() {
	        const value = this._target.value;
	        return value == null ? this.defaultValue : value;
	    }
	    set value(value) {
	        this._target.value = value;
	    }
	}
	exports.DefaultValueReference = DefaultValueReference;


/***/ },
/* 145 */
/***/ function(module, exports) {

	"use strict";


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(87));


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(148));
	__export(__webpack_require__(150));
	__export(__webpack_require__(151));


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const base_1 = __webpack_require__(149);
	exports.ITreeNode = base_1.ITreeNode;
	const observable_1 = __webpack_require__(91);
	const mesh_1 = __webpack_require__(13);
	const messages_1 = __webpack_require__(47);
	var TreeNodeMutationTypes;
	(function (TreeNodeMutationTypes) {
	    TreeNodeMutationTypes.NODE_ADDED = "nodeAdded";
	    TreeNodeMutationTypes.NODE_REMOVED = "nodeRemoved";
	})(TreeNodeMutationTypes = exports.TreeNodeMutationTypes || (exports.TreeNodeMutationTypes = {}));
	class TreeNode extends observable_1.Observable {
	    constructor() {
	        super();
	        this._children = this.createChildren();
	        this._childObserver = new mesh_1.CallbackDispatcher(this.onChildAction.bind(this));
	    }
	    get children() {
	        return this._children;
	    }
	    get firstChild() {
	        return this._children[0];
	    }
	    get lastChild() {
	        return this._children[this._children.length - 1];
	    }
	    appendChild(child) {
	        this.insertChildAt(child, this._children.length);
	        return child;
	    }
	    removeAllChildren() {
	        while (this._children.length) {
	            this.removeChild(this._children[0]);
	        }
	    }
	    createChildren() {
	        return [];
	    }
	    removeChild(child) {
	        const index = this._children.indexOf(child);
	        if (index === -1) {
	            return undefined;
	        }
	        this._children.splice(index, 1);
	        this.onChildRemoved(child, index);
	        return child;
	    }
	    insertChildAt(newChild, index) {
	        if (newChild._parent) {
	            newChild._parent.removeChild(newChild);
	        }
	        this._children.splice(index, 0, newChild);
	        this.onChildAdded(newChild, index);
	    }
	    insertBefore(newChild, existingChild) {
	        if (existingChild == null)
	            return this.appendChild(newChild);
	        const index = this._children.indexOf(existingChild);
	        if (index !== -1) {
	            this.insertChildAt(newChild, index);
	        }
	        return newChild;
	    }
	    replaceChild(newChild, existingChild) {
	        const index = this._children.indexOf(existingChild);
	        if (index !== -1) {
	            this.insertChildAt(newChild, index);
	            this.removeChild(existingChild);
	        }
	        return existingChild;
	    }
	    get parent() {
	        return this._parent;
	    }
	    get root() {
	        let p = this;
	        while (p.parent)
	            p = p.parent;
	        return p;
	    }
	    get ancestors() {
	        const ancestors = [];
	        let p = this.parent;
	        while (p) {
	            ancestors.push(p);
	            p = p.parent;
	        }
	        return ancestors;
	    }
	    get nextSibling() {
	        return this._parent ? this._parent.children[this._parent.children.indexOf(this) + 1] : undefined;
	    }
	    get previousSibling() {
	        return this._parent ? this._parent.children[this._parent.children.indexOf(this) - 1] : undefined;
	    }
	    get depth() {
	        return this.ancestors.length;
	    }
	    onChildAdded(child, index) {
	        child._parent = this;
	        child.observe(this._childObserver);
	        child.notify(new messages_1.InsertChildMutation(TreeNodeMutationTypes.NODE_ADDED, this, child, index).toEvent());
	        child.onAdded();
	    }
	    onChildRemoved(child, index) {
	        child.onRemoved();
	        child.notify(new messages_1.RemoveChildMutation(TreeNodeMutationTypes.NODE_REMOVED, this, child, index).toEvent());
	        child.unobserve(this._childObserver);
	        child._parent = undefined;
	    }
	    onAdded() {
	    }
	    onRemoved() {
	    }
	    clone(deep) {
	        const clone = this.cloneLeaf();
	        if (deep) {
	            for (let i = 0, n = this.children.length; i < n; i++) {
	                clone.appendChild(this.children[i].clone(deep));
	            }
	        }
	        return clone;
	    }
	    cloneLeaf() {
	        return new TreeNode();
	    }
	    onChildAction(action) {
	        this.notify(action);
	    }
	    visitWalker(walker) {
	        this.children.forEach(child => walker.accept(child));
	    }
	}
	exports.TreeNode = TreeNode;


/***/ },
/* 149 */
/***/ function(module, exports) {

	"use strict";


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const walker_1 = __webpack_require__(151);
	function traverseTree(node, each) {
	    return new walker_1.TreeWalker(each).accept(node);
	}
	exports.traverseTree = traverseTree;
	;
	function filterTree(node, filter) {
	    const nodes = [];
	    traverseTree(node, (child) => {
	        if (filter(child))
	            nodes.push(child);
	    });
	    return nodes;
	}
	exports.filterTree = filterTree;
	;
	function flattenTree(node) {
	    return filterTree(node, child => true);
	}
	exports.flattenTree = flattenTree;
	;
	function findTreeNode(node, filter) {
	    let found;
	    const walker = new walker_1.TreeWalker((node) => {
	        if (filter(node)) {
	            found = node;
	            return false;
	        }
	    });
	    walker.accept(node);
	    return found;
	}
	exports.findTreeNode = findTreeNode;
	;
	function getTreeAncestors(node) {
	    const ancestors = [];
	    let current = node.parent;
	    while (current) {
	        ancestors.push(current);
	        current = current.parent;
	    }
	    return ancestors;
	}
	exports.getTreeAncestors = getTreeAncestors;
	;
	function getNextTreeSiblings(node) {
	    const nextSiblings = [];
	    let current = node.nextSibling;
	    while (current) {
	        nextSiblings.push(current);
	        current = current.nextSibling;
	    }
	    return nextSiblings;
	}
	exports.getNextTreeSiblings = getNextTreeSiblings;
	;
	function getPreviousTreeSiblings(node) {
	    const nextSiblings = [];
	    let current = node.previousSibling;
	    while (current) {
	        nextSiblings.push(current);
	        current = current.previousSibling;
	    }
	    return nextSiblings;
	}
	exports.getPreviousTreeSiblings = getPreviousTreeSiblings;
	;


/***/ },
/* 151 */
/***/ function(module, exports) {

	"use strict";
	class TreeWalker {
	    constructor(each) {
	        this.each = each;
	    }
	    accept(visitor) {
	        if (!this._stopped && this.each(visitor) !== false) {
	            visitor.visitWalker(this);
	        }
	        else {
	            this._stopped = true;
	        }
	    }
	}
	exports.TreeWalker = TreeWalker;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(153));
	__export(__webpack_require__(155));


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const decorators_1 = __webpack_require__(69);
	const mongoid = __webpack_require__(154);
	const observable_1 = __webpack_require__(91);
	const mesh_1 = __webpack_require__(13);
	const ioc_1 = __webpack_require__(54);
	const messages_1 = __webpack_require__(47);
	// TODO - need to queue requests
	// TODO - add schema here
	class BaseActiveRecord extends observable_1.Observable {
	    constructor(_source, collectionName) {
	        super();
	        this._source = _source;
	        this.collectionName = collectionName;
	        // TODO - move this to reflect metadata
	        this.idProperty = "_id";
	        if (this._source) {
	            this.setPropertiesFromSource(_source);
	        }
	    }
	    get isNew() {
	        return this[this.idProperty] == null;
	    }
	    get source() {
	        return this._source;
	    }
	    /**
	     * Refreshes the active record from the DS if the source data
	     * is stale.
	     */
	    refresh() {
	        return this.fetch(new mesh_1.DSFindRequest(this.collectionName, this.sourceQuery));
	    }
	    save() {
	        return this.isNew ? this.insert() : this.update();
	    }
	    dispose() {
	        this.notify(new messages_1.DisposeEvent());
	    }
	    insert() {
	        this.willSave();
	        const newData = this.serialize();
	        if (newData[this.idProperty] == null) {
	            newData[this.idProperty] = String(mongoid());
	        }
	        return this.fetch(new mesh_1.DSInsertRequest(this.collectionName, newData));
	    }
	    remove() {
	        return this.fetch(new mesh_1.DSRemoveRequest(this.collectionName, this.sourceQuery));
	    }
	    get sourceQuery() {
	        if (this.isNew) {
	            throw new Error("Cannot query active record if it does not have an identifier.");
	        }
	        ;
	        const id = this[this.idProperty];
	        return {
	            [this.idProperty]: id
	        };
	    }
	    shouldUpdate() {
	        return true;
	    }
	    /**
	     * Called immediately before update()
	     * @protected
	     */
	    willUpdate() {
	    }
	    /**
	     * Called immediately before insert() and update()
	     */
	    willSave() {
	    }
	    update() {
	        if (!this.shouldUpdate()) {
	            return Promise.resolve(this);
	        }
	        this.willUpdate();
	        this.willSave();
	        const newData = this.serialize();
	        return this.fetch(new mesh_1.DSUpdateRequest(this.collectionName, newData, this.sourceQuery));
	    }
	    toJSON() {
	        return this.serialize();
	    }
	    deserialize(source) {
	        if (this.shouldDeserialize(source)) {
	            this._source = source;
	            this.setPropertiesFromSource(source);
	            this.notify(new messages_1.ActiveRecordEvent(messages_1.ActiveRecordEvent.ACTIVE_RECORD_DESERIALIZED));
	        }
	    }
	    shouldDeserialize(b) {
	        return true;
	    }
	    setPropertiesFromSource(source) {
	        for (const key in source) {
	            this[key] = source[key];
	        }
	    }
	    fetch(action) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const { value, done } = yield mesh_1.readOneChunk(this.dispatcher.dispatch(action));
	            if (value) {
	                this.deserialize(value);
	            }
	            return this;
	        });
	    }
	}
	__decorate([
	    decorators_1.inject(ioc_1.PrivateBusProvider.ID)
	], BaseActiveRecord.prototype, "dispatcher", void 0);
	exports.BaseActiveRecord = BaseActiveRecord;


/***/ },
/* 154 */
/***/ function(module, exports) {

	module.exports = require("mongoid-js");

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const sift = __webpack_require__(43);
	const observable_1 = __webpack_require__(91);
	const messages_1 = __webpack_require__(47);
	const ioc_1 = __webpack_require__(54);
	const mesh_1 = __webpack_require__(13);
	// TODO - remove global listener
	// TODO - listen to DS mediator for updates on record collection
	class ActiveRecordCollection extends observable_1.ObservableCollection {
	    constructor(...items) {
	        super();
	    }
	    static create(collectionName, injector, createActiveRecord, query = {}) {
	        return new this().setup(collectionName, injector, createActiveRecord, query);
	    }
	    setup(collectionName, injector, createActiveRecord, query) {
	        this.collectionName = collectionName;
	        this._bus = ioc_1.PrivateBusProvider.getInstance(injector);
	        this.createActiveRecord = createActiveRecord;
	        this._globalMessageObserver = new mesh_1.FilterBus((action) => {
	            return (action.type === mesh_1.DSUpdateRequest.DS_UPDATE || action.type === mesh_1.DSInsertRequest.DS_INSERT || action.type === messages_1.PostDSMessage.DS_DID_UPDATE || action.type === messages_1.PostDSMessage.DS_DID_INSERT) && action.collectionName === this.collectionName && sift(this.query)(action.data);
	        }, new mesh_1.CallbackDispatcher(this.onPostDSMessage.bind(this)));
	        this.query = query || {};
	        return this;
	    }
	    reload() {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.splice(0, this.length);
	            this.load();
	        });
	    }
	    load() {
	        return __awaiter(this, void 0, void 0, function* () {
	            // TODO - need to check for duplicates
	            this.push(...(yield mesh_1.readAllChunks(this._bus.dispatch(new mesh_1.DSFindRequest(this.collectionName, this.query, true)))).map(value => {
	                return this.createActiveRecord(value);
	            }));
	        });
	    }
	    sync() {
	        if (this._sync)
	            return this._sync;
	        // TODO - this is very smelly. Collections should not be registering themselves
	        // to the global message bus. Instead they should be registering themselves to a DS manager
	        // which handles all incomming and outgoing DS actions from the message bus.
	        this._bus.register(this._globalMessageObserver);
	        return this._sync = {
	            dispose: () => {
	                this._sync = undefined;
	                this._bus.unregister(this._globalMessageObserver);
	            }
	        };
	    }
	    /**
	     * loads an item with the given query from the DS
	     */
	    loadItem(query) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const { value, done } = yield mesh_1.readOneChunk(this._bus.dispatch(new mesh_1.DSFindRequest(this.collectionName, query, false)));
	            // item exists, so add and return it. Otherwise return undefined indicating
	            // that the item does not exist.
	            if (value) {
	                const item = this.createActiveRecord(value);
	                this.push(item);
	                return item;
	            }
	        });
	    }
	    /**
	     * Loads an item into this collection if it exists, otherwise creates an item
	     */
	    loadOrInsertItem(query, source = query) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const loadedItem = yield this.loadItem(query);
	            return loadedItem || this.create(source).insert();
	        });
	    }
	    /**
	     * Synchronously creates a new active record (without persisting) with the given data
	     * source.
	     *
	     * @param {U} source The source data represented by the new active record.
	     * @returns
	     */
	    create(source) {
	        const record = this.createActiveRecord(source);
	        this.push(record);
	        return record;
	    }
	    onPostDSMessage(action) {
	        this._updateActiveRecord(action.data);
	    }
	    _updateActiveRecord(source) {
	        let record = this.find((record) => record[record.idProperty] === source[record.idProperty]);
	        if (record) {
	            record.deserialize(source);
	            return record;
	        }
	        return this.create(source);
	    }
	}
	exports.ActiveRecordCollection = ActiveRecordCollection;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(157));
	module.exports = typeof window === "undefined" ? __webpack_require__(158) : __webpack_require__(157);


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const mesh_1 = __webpack_require__(13);
	const serialize_1 = __webpack_require__(11);
	let loadedScripts;
	let lastScriptSrc;
	exports.isMaster = typeof window !== "undefined";
	if (exports.isMaster) {
	    loadedScripts = document.querySelectorAll("script");
	    lastScriptSrc = loadedScripts.length && loadedScripts[loadedScripts.length - 1].src;
	}
	class Serializer {
	    constructor(clazz, serialize, deserialize) {
	        this.serialize = serialize;
	        this.deserialize = deserialize;
	        this.name = clazz.name;
	    }
	}
	exports.Serializer = Serializer;
	const workers = [];
	const threadedFunctions = [];
	const jobPromises = {};
	let currentWorkerIndex = 0;
	let cid = 0;
	function getNextWorker() {
	    return workers.length ? workers[currentWorkerIndex = (currentWorkerIndex + 1) % workers.length] : undefined;
	}
	function createWorkerBus(family, worker, localBus) {
	    return new mesh_1.RemoteBus({
	        family: family,
	        testMessage: mesh_1.filterFamilyMessage,
	        adapter: {
	            send(message) {
	                worker.postMessage(message);
	            },
	            addListener(listener) {
	                worker.addEventListener("message", (message) => {
	                    listener(message.data);
	                });
	            }
	        }
	    }, localBus, { serialize: serialize_1.serialize, deserialize: serialize_1.deserialize });
	}
	/**
	 */
	function fork(family, localBus, pathName, argv, env) {
	    return createWorkerBus(family, new Worker(pathName || lastScriptSrc), localBus);
	}
	exports.fork = fork;
	/**
	 */
	function hook(family, localBus) {
	    return createWorkerBus(family, self, localBus);
	}
	exports.hook = hook;
	/**
	 *
	 */
	if (exports.isMaster) {
	    const KILL_TIMEOUT = 1000 * 60 * 5; // 5 minute
	    // worker cleanup
	    setInterval(() => {
	        for (let cid in jobPromises) {
	            const promise = jobPromises[cid];
	            // may have been deleted -- waiting for GC to kick in
	            if (!promise)
	                continue;
	            if (promise.timestamp < Date.now() - KILL_TIMEOUT) {
	                console.warn(`Killing zombie job: ${cid}`);
	                // return Timeout error
	                jobPromises[cid] = undefined;
	                promise.reject(new Error(`Timeout`));
	            }
	        }
	    }, 1000 * 10);
	}
	else if (typeof self !== "undefined") {
	    self.addEventListener("message", function (message) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const { cid, index, args } = message.data;
	            const fn = threadedFunctions[index];
	            function resolve(data) {
	                self.postMessage({ cid, data }, undefined);
	            }
	            function reject(data) {
	                self.postMessage({ cid, data, error: true }, undefined);
	            }
	            try {
	                resolve(fn(...args));
	            }
	            catch (e) {
	                reject({ message: e.message });
	            }
	        });
	    });
	}


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const cluster_1 = __webpack_require__(3);
	exports.isMaster = cluster_1.isMaster;
	const child_process_1 = __webpack_require__(159);
	const mesh_1 = __webpack_require__(13);
	const common_1 = __webpack_require__(46);
	exports.fork = (family, localBus, pathName, argv, env) => {
	    const remoteBus = new mesh_1.ProxyBus();
	    const spawn = () => {
	        const worker = child_process_1.fork(pathName || process.argv[1], argv || process.argv.slice(2), { env: env });
	        remoteBus.target = exports.createProcessBus(family, worker, localBus);
	        worker.on("disconnect", () => {
	            remoteBus.target = undefined;
	            // add timeout in case the worker is crashing repeatedly
	            setTimeout(spawn, 1000);
	        });
	    };
	    spawn();
	    return remoteBus;
	};
	exports.createProcessBus = (family, proc, target) => {
	    return new mesh_1.RemoteBus({
	        family,
	        testMessage: mesh_1.filterFamilyMessage,
	        adapter: {
	            send(message) {
	                proc.send(message);
	            },
	            addListener(listener) {
	                proc.on("message", (message) => {
	                    listener(message);
	                });
	            }
	        }
	    }, target, { serialize: common_1.serialize, deserialize: common_1.deserialize });
	};
	exports.hook = (family, localBus) => {
	    return exports.createProcessBus(family, process, localBus);
	};


/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports = require("child_process");

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(161));


/***/ },
/* 161 */
/***/ function(module, exports) {

	"use strict";
	exports.HTML_MIME_TYPE = "text/html";
	exports.CSS_MIME_TYPE = "text/css";
	exports.PLAIN_TEXT_MIME_TYPE = "text/plain";
	exports.JS_MIME_TYPE = "application/javascript";


/***/ },
/* 162 */
/***/ function(module, exports) {

	"use strict";
	class Queue {
	    constructor() {
	        this._items = [];
	    }
	    add(callback) {
	        return new Promise((resolve, reject) => {
	            this._items.push([resolve, reject, callback]);
	            if (this._running)
	                return;
	            this._running = true;
	            const next = () => {
	                if (!this._items.length) {
	                    this._running = false;
	                    return;
	                }
	                const [resolve, reject, callback] = this._items.shift();
	                const complete = (err, ...rest) => {
	                    if (err != null) {
	                        reject();
	                    }
	                    else {
	                        resolve(...rest);
	                    }
	                    next();
	                };
	                callback().then(complete.bind(this, undefined), complete);
	            };
	            next();
	        });
	    }
	}
	exports.Queue = Queue;


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const React = __webpack_require__(106);
	const decorators_1 = __webpack_require__(69);
	const ioc_1 = __webpack_require__(54);
	exports.appComponentContextTypes = {
	    bus: React.PropTypes.object,
	    injector: React.PropTypes.object
	};
	let BaseApplicationComponent = class BaseApplicationComponent extends React.Component {
	    constructor(props, context, callbacks) {
	        super(props, context, callbacks);
	        if (context.injector) {
	            context.injector.inject(this);
	        }
	        else {
	            console.warn(`Failed to inject properties into `, this.constructor.name);
	        }
	    }
	    $didInject() {
	    }
	};
	BaseApplicationComponent.contextTypes = exports.appComponentContextTypes;
	__decorate([
	    decorators_1.inject(ioc_1.PrivateBusProvider.ID)
	], BaseApplicationComponent.prototype, "bus", void 0);
	__decorate([
	    decorators_1.inject(ioc_1.InjectorProvider.ID)
	], BaseApplicationComponent.prototype, "injector", void 0);
	BaseApplicationComponent = __decorate([
	    decorators_1.loggable()
	], BaseApplicationComponent);
	exports.BaseApplicationComponent = BaseApplicationComponent;
	class RootApplicationComponent extends React.Component {
	    getChildContext() {
	        return {
	            bus: this.props.bus,
	            injector: this.props.injector
	        };
	    }
	    render() {
	        return React.createElement("span", null, 
	            this.props.children, 
	            " ");
	    }
	}
	RootApplicationComponent.childContextTypes = exports.appComponentContextTypes;
	exports.RootApplicationComponent = RootApplicationComponent;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const serialize_1 = __webpack_require__(11);
	let Status_1 = class Status {
	    constructor(type, data) {
	        this.type = type;
	        this.data = data;
	    }
	    clone() {
	        return new Status_1(this.type, this.data);
	    }
	};
	let Status = Status_1;
	Status.IDLE = "idle";
	Status.ERROR = "error";
	Status.LOADING = "loading";
	Status.COMPLETED = "completed";
	Status = Status_1 = __decorate([
	    serialize_1.serializable({
	        serialize({ type, data }) {
	            return { type, data: serialize_1.serialize(data) };
	        },
	        deserialize({ type, data }, injector) {
	            return new Status(type, serialize_1.deserialize(data, injector));
	        }
	    })
	], Status);
	exports.Status = Status;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const common_1 = __webpack_require__(46);
	const providers_1 = __webpack_require__(166);
	const common_2 = __webpack_require__(46);
	const mesh_1 = __webpack_require__(13);
	const sandbox_1 = __webpack_require__(167);
	function createBusProviders() {
	    const privateBus = new common_2.BrokerBus(mesh_1.SequenceBus);
	    return new common_2.Injector(new common_2.PrivateBusProvider(privateBus));
	}
	function createCoreApplicationProviders(config, fileSystemClass, fileResolverClass) {
	    return new common_2.Injector(createBusProviders(), new common_2.InjectorProvider(), new providers_1.ApplicationConfigurationProvider(config), sandbox_1.createSandboxProviders(fileSystemClass, fileResolverClass));
	}
	exports.createCoreApplicationProviders = createCoreApplicationProviders;
	class ServiceApplication extends common_1.Application {
	    willLoad() {
	        super.willLoad();
	        // create the services before loading so that they can hook themselves into the application
	        // context.
	        for (const serviceProvider of providers_1.ApplicationServiceProvider.findAll(this.injector)) {
	            serviceProvider.create();
	        }
	    }
	}
	exports.ServiceApplication = ServiceApplication;
	__export(__webpack_require__(166));
	__export(__webpack_require__(207));


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	class ApplicationServiceProvider extends common_1.ClassFactoryProvider {
	    constructor(name, value) {
	        super(ApplicationServiceProvider.getId(name), value);
	    }
	    static getId(name) {
	        return [this.NS, name].join("/");
	    }
	    create() {
	        return super.create();
	    }
	    static findAll(injector) {
	        return injector.queryAll(this.getId("**"));
	    }
	}
	ApplicationServiceProvider.NS = "services";
	exports.ApplicationServiceProvider = ApplicationServiceProvider;
	/**
	 * The application configuration dependency
	 */
	class ApplicationConfigurationProvider extends common_1.Provider {
	    constructor(value) {
	        super(ApplicationConfigurationProvider.ID, value);
	    }
	}
	ApplicationConfigurationProvider.ID = "config";
	exports.ApplicationConfigurationProvider = ApplicationConfigurationProvider;


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(168));
	__export(__webpack_require__(169));
	__export(__webpack_require__(170));
	__export(__webpack_require__(171));
	__export(__webpack_require__(176));
	__export(__webpack_require__(181));
	__export(__webpack_require__(197));
	__export(__webpack_require__(201));
	__export(__webpack_require__(205));
	__export(__webpack_require__(206));


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	class ContentEditorFactoryProvider extends common_1.ClassFactoryProvider {
	    constructor(mimeType, clazz, autoSave = false) {
	        super(ContentEditorFactoryProvider.getNamespace(mimeType), clazz);
	        this.mimeType = mimeType;
	        this.clazz = clazz;
	        this.autoSave = autoSave;
	    }
	    clone() {
	        return new ContentEditorFactoryProvider(this.mimeType, this.clazz, this.autoSave);
	    }
	    static getNamespace(mimeType) {
	        return [ContentEditorFactoryProvider.NS, mimeType].join("/");
	    }
	    create(filePath, content) {
	        return super.create(filePath, content);
	    }
	    static find(mimeType, injector) {
	        return injector.query(this.getNamespace(mimeType));
	    }
	}
	ContentEditorFactoryProvider.NS = "contentEditors";
	exports.ContentEditorFactoryProvider = ContentEditorFactoryProvider;
	// Necessary for certain libraries that think it's really
	// cute to add custom protocols.
	class ProtocolURLResolverProvider extends common_1.ClassFactoryProvider {
	    constructor(name, clazz) {
	        super(ProtocolURLResolverProvider.getId(name), clazz);
	        this.name = name;
	        this.clazz = clazz;
	    }
	    clone() {
	        return new ProtocolURLResolverProvider(this.name, this.clazz);
	    }
	    create() {
	        return super.create();
	    }
	    static getId(name) {
	        return [this.NS, name].join("/");
	    }
	    static find(url, injector) {
	        const provider = injector.query(this.getId(url.split(":").shift()));
	        return provider;
	    }
	    static resolve(url, injector) {
	        const provider = this.find(url, injector);
	        return (provider && provider.create().resolve(url)) || url;
	    }
	}
	ProtocolURLResolverProvider.NS = "protocolReader";
	exports.ProtocolURLResolverProvider = ProtocolURLResolverProvider;
	exports.FileSystemProvider = common_1.createSingletonProviderClass("fileSystem");
	exports.FileResolverProvider = common_1.createSingletonProviderClass("fileResolver");
	exports.FileCacheProvider = common_1.createSingletonProviderClass("fileCache");
	exports.FileEditorProvider = common_1.createSingletonProviderClass("fileEditor");
	// TODO - this needs to be a singleton based on a given strategy (webpack, systemjs, rollup)
	// export const DependencyGraphProvider    = createSingletonProviderClass<DependencyGraph>("bundler"); 


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const common_1 = __webpack_require__(46);
	const mesh_1 = __webpack_require__(13);
	let ApplyFileEditRequest_1 = class ApplyFileEditRequest extends mesh_1.Message {
	    constructor(mutations, saveFile = false) {
	        super(ApplyFileEditRequest_1.APPLY_EDITS);
	        this.mutations = mutations;
	        this.saveFile = saveFile;
	    }
	};
	let ApplyFileEditRequest = ApplyFileEditRequest_1;
	ApplyFileEditRequest.APPLY_EDITS = "applyMutations";
	ApplyFileEditRequest = ApplyFileEditRequest_1 = __decorate([
	    common_1.serializable({
	        serialize({ mutations }) {
	            return {
	                mutations: mutations.map(common_1.serialize)
	            };
	        },
	        deserialize({ mutations }, injector) {
	            return new ApplyFileEditRequest(mutations.map(action => common_1.deserialize(action, injector)));
	        }
	    })
	], ApplyFileEditRequest);
	exports.ApplyFileEditRequest = ApplyFileEditRequest;
	class ModuleImporterAction extends mesh_1.Message {
	}
	ModuleImporterAction.MODULE_CONTENT_CHANGED = "moduleContentChanged";
	exports.ModuleImporterAction = ModuleImporterAction;
	class SandboxModuleAction extends mesh_1.Message {
	}
	SandboxModuleAction.EVALUATING = "evaluating";
	SandboxModuleAction.EDITED = "edited";
	exports.SandboxModuleAction = SandboxModuleAction;
	let ResolveFileRequest_1 = class ResolveFileRequest extends mesh_1.Message {
	    constructor(relativePath, cwd, options) {
	        super(ResolveFileRequest_1.RESOLVE_FILE);
	        this.relativePath = relativePath;
	        this.cwd = cwd;
	        this.options = options;
	    }
	};
	let ResolveFileRequest = ResolveFileRequest_1;
	ResolveFileRequest.RESOLVE_FILE = "resolveFile";
	ResolveFileRequest = ResolveFileRequest_1 = __decorate([
	    common_1.serializable()
	], ResolveFileRequest);
	exports.ResolveFileRequest = ResolveFileRequest;
	class FileCacheAction extends mesh_1.Message {
	    constructor(type, item) {
	        super(type);
	        this.item = item;
	    }
	}
	FileCacheAction.ADDED_ENTITY = "addedEntity";
	exports.FileCacheAction = FileCacheAction;
	let ReadFileRequest_1 = class ReadFileRequest extends mesh_1.Message {
	    constructor(filePath) {
	        super(ReadFileRequest_1.READ_FILE);
	        this.filePath = filePath;
	    }
	    static dispatch(filePath, bus) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return new Buffer((yield mesh_1.readOneChunk(bus.dispatch(new ReadFileRequest_1(filePath)))).value, "base64");
	        });
	    }
	};
	let ReadFileRequest = ReadFileRequest_1;
	ReadFileRequest.READ_FILE = "readFile";
	ReadFileRequest = ReadFileRequest_1 = __decorate([
	    common_1.serializable()
	], ReadFileRequest);
	exports.ReadFileRequest = ReadFileRequest;
	let ReadDirectoryRequest_1 = class ReadDirectoryRequest extends mesh_1.Message {
	    constructor(directoryPath) {
	        super(ReadDirectoryRequest_1.READ_DIRECTORY);
	        this.directoryPath = directoryPath;
	    }
	    static dispatch(directoryPath, bus) {
	        return bus.dispatch(new ReadDirectoryRequest_1(directoryPath)).readable;
	    }
	};
	let ReadDirectoryRequest = ReadDirectoryRequest_1;
	ReadDirectoryRequest.READ_DIRECTORY = "readDirectory";
	ReadDirectoryRequest = ReadDirectoryRequest_1 = __decorate([
	    common_1.serializable()
	], ReadDirectoryRequest);
	exports.ReadDirectoryRequest = ReadDirectoryRequest;
	let WatchFileRequest_1 = class WatchFileRequest extends mesh_1.Message {
	    constructor(filePath) {
	        super(WatchFileRequest_1.WATCH_FILE);
	        this.filePath = filePath;
	    }
	    static dispatch(filePath, bus, onFileChange) {
	        const { readable } = bus.dispatch(new WatchFileRequest_1(filePath));
	        readable.pipeTo(new mesh_1.WritableStream({
	            write: onFileChange
	        }));
	        return {
	            dispose: () => readable.cancel(undefined)
	        };
	    }
	};
	let WatchFileRequest = WatchFileRequest_1;
	WatchFileRequest.WATCH_FILE = "watchFile";
	WatchFileRequest = WatchFileRequest_1 = __decorate([
	    common_1.serializable()
	], WatchFileRequest);
	exports.WatchFileRequest = WatchFileRequest;


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	let _i = 0;
	function generateSyntheticUID() {
	    // TODO - add seed & platform information here
	    return _i++;
	}
	exports.generateSyntheticUID = generateSyntheticUID;
	function syntheticSourceInfoEquals(a, b) {
	    return (a == null && b == null) || (a && b && a.kind === b.kind && a.filePath === b.filePath && common_1.sourcePositionEquals(a.start, b.start) && common_1.sourcePositionEquals(a.end, b.end));
	}
	exports.syntheticSourceInfoEquals = syntheticSourceInfoEquals;
	/**
	 * Converts the synthetic object into a format that can be transfered over a network.
	 */
	class SyntheticObjectSerializer {
	    constructor(childSerializer) {
	        this.childSerializer = childSerializer;
	    }
	    serialize(value) {
	        return Object.assign(this.childSerializer.serialize(value), {
	            source: value.$source,
	            uid: value.$uid
	        });
	    }
	    deserialize(value, injector, ctor) {
	        return Object.assign(this.childSerializer.deserialize(value, injector, ctor), {
	            $source: value.source,
	            $uid: value.uid
	        });
	    }
	}
	exports.SyntheticObjectSerializer = SyntheticObjectSerializer;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(172));
	__export(__webpack_require__(173));
	__export(__webpack_require__(175));


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const common_1 = __webpack_require__(46);
	let BaseFileSystem = class BaseFileSystem {
	    constructor() {
	        this._fileWatchers = {};
	    }
	    watchFile(filePath, onChange) {
	        let _fileWatcher;
	        if (!(_fileWatcher = this._fileWatchers[filePath])) {
	            _fileWatcher = this._fileWatchers[filePath] = {
	                listeners: [],
	                instance: this.watchFile2(filePath, () => {
	                    for (let i = _fileWatcher.listeners.length; i--;) {
	                        _fileWatcher.listeners[i]();
	                    }
	                })
	            };
	        }
	        const { listeners, instance } = _fileWatcher;
	        listeners.push(onChange);
	        return {
	            dispose: () => {
	                const index = listeners.indexOf(onChange);
	                if (index === -1)
	                    return;
	                listeners.splice(index, 1);
	                if (listeners.length === 0) {
	                    instance.dispose();
	                }
	            }
	        };
	    }
	};
	BaseFileSystem = __decorate([
	    common_1.loggable()
	], BaseFileSystem);
	exports.BaseFileSystem = BaseFileSystem;


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const fs = __webpack_require__(174);
	const mesh_1 = __webpack_require__(13);
	const base_1 = __webpack_require__(172);
	let _i = 0;
	class LocalFileSystem extends base_1.BaseFileSystem {
	    readDirectory(directoryPath) {
	        return new mesh_1.ReadableStream({
	            start(controller) {
	                fs.readdir(directoryPath, (err, result) => {
	                    if (err)
	                        return controller.error(err);
	                    result.map(name => ({
	                        name: name,
	                        isDirectory: fs.lstatSync(directoryPath + "/" + name).isDirectory()
	                    })).sort((a, b) => {
	                        return a.isDirectory && !b.isDirectory ? -1 : a.isDirectory === b.isDirectory ? a.name > b.name ? 1 : -1 : 1;
	                    }).forEach((file) => {
	                        controller.enqueue(file);
	                    });
	                    controller.close();
	                });
	            }
	        });
	    }
	    readFile(filePath) {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.logger.debug("read", filePath);
	            return new Promise((resolve, reject) => {
	                fs.readFile(filePath, (err, data) => {
	                    if (err)
	                        return reject(err);
	                    resolve(data);
	                });
	            });
	        });
	    }
	    fileExists(filePath) {
	        return new Promise((resolve) => {
	            fs.exists(filePath, resolve);
	        });
	    }
	    writeFile(filePath, content) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return new Promise((resolve, reject) => {
	                fs.writeFile(filePath, content, (err, result) => {
	                    if (err)
	                        return reject(err);
	                    resolve();
	                });
	            });
	        });
	    }
	    watchFile2(filePath, onChange) {
	        this.logger.debug("watch", filePath);
	        let currentStat = fs.lstatSync(filePath);
	        const listener = () => {
	            let newStat = fs.lstatSync(filePath);
	            if (newStat.mtime.getTime() === currentStat.mtime.getTime())
	                return;
	            currentStat = newStat;
	            onChange();
	        };
	        fs.watchFile(filePath, { interval: 200 }, listener);
	        return {
	            dispose: () => {
	                fs.unwatchFile(filePath, listener);
	            }
	        };
	    }
	}
	exports.LocalFileSystem = LocalFileSystem;


/***/ },
/* 174 */
/***/ function(module, exports) {

	module.exports = require("fs");

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const base_1 = __webpack_require__(172);
	const common_1 = __webpack_require__(46);
	const messages_1 = __webpack_require__(169);
	class RemoteFileSystem extends base_1.BaseFileSystem {
	    readDirectory(directoryPath) {
	        return messages_1.ReadDirectoryRequest.dispatch(directoryPath, this.bus);
	    }
	    readFile(filePath) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return yield messages_1.ReadFileRequest.dispatch(filePath, this.bus);
	        });
	    }
	    fileExists(filePath) {
	        return __awaiter(this, void 0, void 0, function* () {
	            throw new Error(`Not implemented yet`);
	        });
	    }
	    writeFile(filePath, content) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return Promise.reject(new Error("not implemented yet"));
	        });
	    }
	    watchFile2(filePath, onChange) {
	        return messages_1.WatchFileRequest.dispatch(filePath, this.bus, onChange);
	    }
	}
	__decorate([
	    common_1.inject(common_1.PrivateBusProvider.ID)
	], RemoteFileSystem.prototype, "bus", void 0);
	exports.RemoteFileSystem = RemoteFileSystem;


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	// TODO - this is deprecated. Move to strategies/default
	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const fs = __webpack_require__(174);
	const memoize = __webpack_require__(177);
	const messages_1 = __webpack_require__(169);
	const mesh_1 = __webpack_require__(13);
	const common_1 = __webpack_require__(46);
	const resolve = __webpack_require__(178);
	const pkgpath = __webpack_require__(179);
	const createFileResolverOptions = (extensions, directories) => {
	    return {
	        extensions: extensions || [],
	        directories: directories || []
	    };
	};
	const combineResoverOptions = (...options) => {
	    return options.reduce((a, b) => {
	        if (!a)
	            a = createFileResolverOptions();
	        if (!b)
	            b = createFileResolverOptions();
	        return {
	            extensions: a.extensions.concat(b.extensions),
	            directories: a.directories.concat(b.directories)
	        };
	    });
	};
	let BaseFileResolver = class BaseFileResolver {
	    constructor() {
	        // TODO - there will be cases where we want to bust the cache on this.
	        this.resolve = memoize((relativePath, cwd, options) => __awaiter(this, void 0, void 0, function* () {
	            return this.resolve2(relativePath, cwd, combineResoverOptions(this.options, options));
	        }), { promise: true, normalizer: ([relativePath, cwd, options]) => relativePath + cwd + JSON.stringify(options) });
	        this._cache = {};
	        this.options = createFileResolverOptions();
	    }
	};
	BaseFileResolver = __decorate([
	    common_1.loggable()
	], BaseFileResolver);
	exports.BaseFileResolver = BaseFileResolver;
	class RemoteFileResolver extends BaseFileResolver {
	    resolve2(filePath, cwd, options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return (yield mesh_1.readOneChunk(this._bus.dispatch(new messages_1.ResolveFileRequest(filePath, cwd, options)))).value;
	        });
	    }
	}
	__decorate([
	    common_1.inject(common_1.PrivateBusProvider.ID)
	], RemoteFileResolver.prototype, "_bus", void 0);
	exports.RemoteFileResolver = RemoteFileResolver;
	class LocalFileResolver extends BaseFileResolver {
	    resolve2(relativePath, cwd, options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const { extensions, directories } = combineResoverOptions(options, {
	                extensions: [],
	                directories: []
	            });
	            let modulesBaseDir = cwd;
	            if (cwd) {
	                const pkgPath = fs.existsSync(cwd + "/package.json") ? cwd : pkgpath.sync(cwd);
	                const pkg = pkgPath && !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
	                // check browser flag in package.json
	                if (!/^(\.|\/)/.test(relativePath)) {
	                    modulesBaseDir = pkgPath;
	                }
	                if (pkg && pkg.browser && pkg.browser[relativePath] != null) {
	                    relativePath = pkg.browser[relativePath];
	                }
	                directories.push(modulesBaseDir + "/node_modules");
	                if (relativePath === false)
	                    return Promise.resolve(undefined);
	            }
	            else {
	                modulesBaseDir = process.cwd();
	            }
	            // override resolve js functionality here -- directories here are
	            // typically scanned in the beginning. We want to resolve from node_modules
	            // after the target directories.
	            directories.push(...modulesBaseDir.split("/").map((dir, index, parts) => {
	                return parts.slice(0, index + 1).join("/") + "/node_modules";
	            }), cwd);
	            const resolvedPath = resolve.sync(relativePath, {
	                basedir: modulesBaseDir,
	                extensions: extensions,
	                paths: directories.filter(dir => !!dir),
	                // moduleDirectory is required, but it foos with
	                // dependency resolution. Solution: give a directory that doesn't have anything
	                moduleDirectory: "/i/should/not/exist",
	                packageFilter: (pkg, filePath) => {
	                    const main = (pkg.browser && typeof pkg.browser === "object" ? pkg.browser[pkg.main] : pkg.browser) || pkg.main;
	                    return {
	                        main: main
	                    };
	                }
	            });
	            this.logger.debug(`Resolved ${relativePath}:${resolvedPath}`);
	            return resolvedPath;
	        });
	    }
	}
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], LocalFileResolver.prototype, "_injector", void 0);
	exports.LocalFileResolver = LocalFileResolver;


/***/ },
/* 177 */
/***/ function(module, exports) {

	module.exports = require("memoizee");

/***/ },
/* 178 */
/***/ function(module, exports) {

	module.exports = require("resolve");

/***/ },
/* 179 */
/***/ function(module, exports) {

	module.exports = require("package-path");

/***/ },
/* 180 */
/***/ function(module, exports) {

	function webpackContext(req) {
		throw new Error("Cannot find module '" + req + "'.");
	}
	webpackContext.keys = function() { return []; };
	webpackContext.resolve = webpackContext;
	module.exports = webpackContext;
	webpackContext.id = 180;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(182));
	__export(__webpack_require__(183));
	__export(__webpack_require__(192));
	__export(__webpack_require__(193));
	__export(__webpack_require__(195));
	__export(__webpack_require__(196));
	__export(__webpack_require__(191));
	__export(__webpack_require__(194));


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	class DependencyEvent extends common_1.CoreEvent {
	}
	DependencyEvent.DEPENDENCY_LOADED = "dependencyReady";
	exports.DependencyEvent = DependencyEvent;


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(184));
	__export(__webpack_require__(185));
	__export(__webpack_require__(190));


/***/ },
/* 184 */
/***/ function(module, exports) {

	"use strict";


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	// A bit of a cluster fuck this is. Needs cleaning after many of mysteries
	// around webpack are resolved.
	const common_1 = __webpack_require__(46);
	const md5 = __webpack_require__(186);
	const fs = __webpack_require__(174);
	const nodeLibs = __webpack_require__(187);
	const detective = __webpack_require__(188);
	const providers_1 = __webpack_require__(166);
	const providers_2 = __webpack_require__(168);
	const path = __webpack_require__(6);
	const resolve = __webpack_require__(178);
	function testLoader(filePath, loader) {
	    if (!(typeof loader.test === "function" ? loader.test(filePath) : loader.test.test(filePath)))
	        return false;
	    // more here
	    return true;
	}
	class MockWebpackCompiler {
	    plugin(key, callback) { }
	}
	exports.MockWebpackCompiler = MockWebpackCompiler;
	class WebpackLoaderContextModule {
	    constructor() {
	        this.meta = {};
	        this.errors = [];
	    }
	}
	let WebpackLoaderContext = class WebpackLoaderContext {
	    constructor(loaders, loader, strategy, resourcePath, id, _dependencies) {
	        this.loaders = loaders;
	        this.loader = loader;
	        this.strategy = strategy;
	        this.resourcePath = resourcePath;
	        this.id = id;
	        this._dependencies = _dependencies;
	        this._compiler = strategy.compiler;
	        this.query = loader.query;
	        this.options = Object.assign({ context: "" }, strategy.config);
	        this.loaderIndex = this.loaders.indexOf(loader);
	        this._module = new WebpackLoaderContextModule();
	        this.remainingRequest = this.loaderIndex === this.loaders.length - 1 ? this.resourcePath : undefined;
	    }
	    emitWarning() {
	    }
	    get includedDependencyPaths() {
	        return this._dependencies;
	    }
	    get module() {
	        return __webpack_require__(189)(this.loader.modulePath);
	    }
	    load(content, map) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return new Promise((resolve, reject) => {
	                this._resolve = resolve;
	                this._reject = reject;
	                const result = this.module.call(this, this.module.raw ? content : String(content), map);
	                if (!this._async) {
	                    return resolve(result && { content: result });
	                }
	            });
	        });
	    }
	    capture() {
	        const module = this.module;
	        if (!module.pitch)
	            return;
	        const remainingRequests = this.loaders.slice(this.loaderIndex + 1).map((loader) => {
	            return loader.modulePath + (loader.query || "");
	        });
	        remainingRequests.push(this.resourcePath);
	        const result = module.pitch(remainingRequests.join("!"));
	        if (result == null)
	            return;
	        return { content: result, map: undefined };
	    }
	    emitFile(fileName, content) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const uri = "webpack://" + fileName;
	            // this.addDependency(uri);
	            this.logger.debug(`Emitting asset ${fileName}`);
	            const fileCache = providers_2.FileCacheProvider.getInstance(this.strategy.injector);
	            const item = yield fileCache.item(uri);
	            item.setDataUrlContent(content);
	            yield item.save();
	        });
	    }
	    async() {
	        this._async = true;
	        return (err, content, map) => {
	            if (err)
	                return this._reject(err);
	            // change sources to absolute path for edits
	            if (map) {
	                map.sources = map.sources.map(relativePath => {
	                    return relativePath.charAt(0) !== "/" ? path.join(this.strategy.config.context || process.cwd(), relativePath) : relativePath;
	                });
	            }
	            this._resolve({ content, map });
	        };
	    }
	    cacheable() {
	    }
	    clearProviders() {
	        this._dependencies = [];
	    }
	    addDependency(filePath) {
	        this._dependencies.push(filePath);
	    }
	    dependency(filePath) {
	        return this.addDependency(filePath);
	    }
	    resolve(cwd, relativePath, callback) {
	        this.strategy.resolve(relativePath, cwd).then((info) => {
	            callback(null, info.filePath);
	        }).catch(callback);
	    }
	};
	WebpackLoaderContext = __decorate([
	    common_1.loggable()
	], WebpackLoaderContext);
	let WebpackDependencyLoader = class WebpackDependencyLoader {
	    constructor(strategy, options) {
	        this.strategy = strategy;
	        this.options = options;
	    }
	    load({ filePath, hash }, { type, content, map }) {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.logger.debug("Loading", filePath);
	            const { config } = this.strategy;
	            // find the matching loaders
	            const usableConfigLoaders = [];
	            if (!this.options.disableAllLoaders) {
	                if (!this.options.disablePreloaders)
	                    usableConfigLoaders.push(...(config.module.preLoaders || []));
	                usableConfigLoaders.push(...config.module.loaders, ...(config.module.postLoaders || []));
	            }
	            const moduleLoaders = [
	                ...normalizeConfigLoaders(...usableConfigLoaders.filter(testLoader.bind(this, filePath))),
	                ...(this.options.loaders || [])
	            ];
	            const includedDependencyPaths = [];
	            const contexts = moduleLoaders.map((loader) => {
	                return this.strategy.injector.inject(new WebpackLoaderContext(moduleLoaders, loader, this.strategy, filePath, hash, includedDependencyPaths));
	            });
	            const loadNext = (content, map, index = 0) => __awaiter(this, void 0, void 0, function* () {
	                if (index >= contexts.length)
	                    return { content, map };
	                const context = contexts[index];
	                const result = ((yield context.capture()) || (yield loadNext(content, map, index + 1)));
	                return (yield context.load(result.content, result.map)) || result;
	            });
	            const result = yield loadNext(content, map, 0);
	            this.logger.debug("loaded", filePath);
	            const foundProviderPaths = detective(result.content);
	            return {
	                map: result.map,
	                type: common_1.JS_MIME_TYPE,
	                content: result.content,
	                importedDependencyPaths: foundProviderPaths,
	                includedDependencyPaths: includedDependencyPaths
	            };
	        });
	    }
	};
	WebpackDependencyLoader = __decorate([
	    common_1.loggable()
	], WebpackDependencyLoader);
	/**
	 */
	function normalizeConfigLoaders(...loaders) {
	    const normalizedLoaders = [];
	    for (const loader of loaders) {
	        normalizedLoaders.push(...parserLoaderOptions(loader.loader).loaders);
	    }
	    return normalizedLoaders;
	}
	/**
	 */
	function parserLoaderOptions(moduleInfo, hasFile = false) {
	    const loaderParts = moduleInfo.replace(/^(-|!)?!/, "").split("!");
	    if (hasFile)
	        loaderParts.pop();
	    const options = {
	        disablePreloaders: /^-?!/.test(moduleInfo),
	        disableAllLoaders: /^(-|!)!/.test(moduleInfo),
	        loaders: loaderParts.map((loaderName) => {
	            const [moduleName, query] = loaderName.split("?");
	            return {
	                modulePath: /*require.resolve*/(__webpack_require__(189).resolve(moduleName)),
	                query: query && "?" + query
	            };
	        })
	    };
	    return options;
	}
	class WebpackSandboxContext {
	    constructor(_target) {
	        this._target = _target;
	        this.module = this;
	        this.id = _target.source.hash;
	        // TODO - need to check webpack config for this.
	        this.__filename = _target.source.filePath;
	        this.__dirname = path.dirname(_target.source.filePath);
	    }
	    get exports() {
	        return this._target.exports;
	    }
	    set exports(value) {
	        this._target.exports = value;
	    }
	}
	exports.WebpackSandboxContext = WebpackSandboxContext;
	class WebpackProtocolResolver {
	    resolve(url) {
	        return __awaiter(this, void 0, void 0, function* () {
	            // cheap for now. Will need to scan all loaded webpack strategy singletons later
	            // on.
	            const relativePath = url.replace("webpack://", "");
	            return relativePath.charAt(0) === "/" && fs.existsSync(relativePath) ? relativePath : path.join(process.cwd(), relativePath);
	        });
	    }
	}
	exports.WebpackProtocolResolver = WebpackProtocolResolver;
	class WebpackProtocolHandler {
	}
	exports.WebpackProtocolHandler = WebpackProtocolHandler;
	/**
	 */
	let WebpackDependencyGraphStrategy = class WebpackDependencyGraphStrategy {
	    constructor(config) {
	        if (config && typeof config === "object") {
	            this.basedir = process.cwd();
	            this.config = config;
	        }
	        else {
	            this.basedir = config && path.dirname(config) || process.cwd();
	            this.config = __webpack_require__(189)(config || path.join(this.basedir, "webpack.config.js"));
	        }
	        this.compiler = new MockWebpackCompiler();
	        // custom config for TD environment.
	        if (this.config.tandem && this.config.tandem.setup) {
	            this.config.tandem.setup(this);
	        }
	    }
	    get injector() {
	        return this._injector;
	    }
	    createGlobalContext() {
	        // TODO - this needs to point to the proper registered protocol
	        return {
	            Buffer: Buffer,
	            __webpack_public_path__: "http://" + this._config.hostname + ":" + this._config.port + "/file-cache/" + encodeURIComponent("webpack://"),
	            // TODO _ this should be shared by other strategies later on
	            process: {
	                argv: [],
	                version: process.version,
	                nextTick: next => setTimeout(next, 0),
	                env: process.env,
	                cwd: () => process.cwd()
	            }
	        };
	    }
	    createModuleContext(module) {
	        return new WebpackSandboxContext(module);
	    }
	    /**
	     * Results the relative file path from the cwd, and provides
	     * information about how it should be treared.
	     *
	     * Examples:
	     * const dependencyInfo = resolver.resolve('text!./module.mu');
	     * const dependencyInfo = resolver.resolve('template!./module.mu');
	     */
	    getLoader(options) {
	        return this._injector.inject(new WebpackDependencyLoader(this, options));
	    }
	    resolve(moduleInfo, cwd) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const { config } = this;
	            moduleInfo = config.resolve.alias && config.resolve.alias[moduleInfo] || moduleInfo;
	            let loaderOptions = parserLoaderOptions(moduleInfo, true);
	            let resolvedFilePath;
	            const relativeFilePath = moduleInfo.split("!").pop();
	            try {
	                this.logger.debug(`Resolving ${cwd}:${relativeFilePath} (${moduleInfo})`);
	                resolvedFilePath = yield this._resolver.resolve(relativeFilePath, cwd, {
	                    extensions: ["", ...this.config.resolve.extensions],
	                    directories: [...this.config.resolve.modulesDirectories, config.resolve.root, this.basedir]
	                });
	            }
	            catch (e) {
	                this.logger.warn(`Unable to resolve ${relativeFilePath}`);
	            }
	            const isCore = resolvedFilePath && resolve.isCore(resolvedFilePath);
	            if (isCore) {
	                let type = moduleInfo;
	                if (this.config.node) {
	                    const value = this.config.node[moduleInfo];
	                    if (this.config.node[moduleInfo] === "empty") {
	                        type = "empty";
	                    }
	                }
	                resolvedFilePath = nodeLibs[type] || /*require.resolve*/(__webpack_require__(189).resolve(`node-libs-browser/mock/${type}`));
	            }
	            return {
	                filePath: resolvedFilePath,
	                loaderOptions: loaderOptions,
	                hash: md5(`webpack:${resolvedFilePath}:${JSON.stringify(loaderOptions)}`)
	            };
	        });
	    }
	};
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], WebpackDependencyGraphStrategy.prototype, "_injector", void 0);
	__decorate([
	    common_1.inject(providers_2.FileResolverProvider.ID)
	], WebpackDependencyGraphStrategy.prototype, "_resolver", void 0);
	__decorate([
	    common_1.inject(providers_1.ApplicationConfigurationProvider.ID)
	], WebpackDependencyGraphStrategy.prototype, "_config", void 0);
	WebpackDependencyGraphStrategy = __decorate([
	    common_1.loggable()
	], WebpackDependencyGraphStrategy);
	exports.WebpackDependencyGraphStrategy = WebpackDependencyGraphStrategy;


/***/ },
/* 186 */
/***/ function(module, exports) {

	module.exports = require("md5");

/***/ },
/* 187 */
/***/ function(module, exports) {

	module.exports = require("node-libs-browser");

/***/ },
/* 188 */
/***/ function(module, exports) {

	module.exports = function() {
		this.cacheable();
		return "// empty (null-loader)";
	};
	module.exports.pitch = function() {
		this.cacheable();
		return "// empty (null-loader)";
	};

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./index": 185,
		"./index.ts": 185
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 189;


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const md5 = __webpack_require__(186);
	const path = __webpack_require__(6);
	const providers_1 = __webpack_require__(168);
	const providers_2 = __webpack_require__(191);
	const common_1 = __webpack_require__(46);
	class BaseDependencyLoader {
	    constructor(strategy) {
	        this.strategy = strategy;
	    }
	}
	exports.BaseDependencyLoader = BaseDependencyLoader;
	class DefaultDependencyLoader {
	    constructor(stragegy, options) {
	        this.stragegy = stragegy;
	        this.options = options;
	    }
	    load(info, content) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const importedDependencyPaths = [];
	            let current = Object.assign({}, content);
	            let dependency;
	            // Some loaders may return the same mime type (such as html-loader, and css-loader which simply return an AST node).
	            // This ensures that they don't get re-used.
	            const used = {};
	            while (current.type && (dependency = providers_2.DependencyLoaderFactoryProvider.find(common_1.MimeTypeAliasProvider.lookup(current.type, this._injector), this._injector)) && !used[dependency.id]) {
	                used[dependency.id] = true;
	                current = yield dependency.create(this.stragegy).load(info, current);
	                if (current.importedDependencyPaths) {
	                    importedDependencyPaths.push(...current.importedDependencyPaths);
	                }
	            }
	            return {
	                map: current.map,
	                type: current.type,
	                content: current.content,
	                importedDependencyPaths: importedDependencyPaths
	            };
	        });
	    }
	}
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], DefaultDependencyLoader.prototype, "_injector", void 0);
	exports.DefaultDependencyLoader = DefaultDependencyLoader;
	class DefaultDependencyGraphStrategy {
	    getLoader(loaderOptions) {
	        return this._injector.inject(new DefaultDependencyLoader(this, loaderOptions));
	    }
	    createGlobalContext() {
	        return {};
	    }
	    createModuleContext(module) {
	        return {
	            module: module,
	            exports: module.exports,
	            __filename: module.source.filePath,
	            __dirname: path.dirname(module.source.filePath)
	        };
	    }
	    resolve(relativeFilePath, cwd) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const filePath = yield this._resolver.resolve(relativeFilePath, cwd);
	            return {
	                filePath: filePath,
	                hash: md5(filePath)
	            };
	        });
	    }
	}
	__decorate([
	    common_1.inject(providers_1.FileResolverProvider.ID)
	], DefaultDependencyGraphStrategy.prototype, "_resolver", void 0);
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], DefaultDependencyGraphStrategy.prototype, "_injector", void 0);
	exports.DefaultDependencyGraphStrategy = DefaultDependencyGraphStrategy;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	class DependencyLoaderFactoryProvider extends common_1.ClassFactoryProvider {
	    constructor(mimeType, value) {
	        super(DependencyLoaderFactoryProvider.getNamespace(mimeType), value);
	        this.mimeType = mimeType;
	    }
	    static getNamespace(mimeType) {
	        return [DependencyLoaderFactoryProvider.NS, mimeType].join("/");
	    }
	    create(strategy) {
	        return super.create(strategy);
	    }
	    static find(mimeType, injector) {
	        return injector.query(this.getNamespace(mimeType));
	    }
	    clone() {
	        return new DependencyLoaderFactoryProvider(this.mimeType, this.value);
	    }
	}
	DependencyLoaderFactoryProvider.NS = "bundleLoader";
	exports.DependencyLoaderFactoryProvider = DependencyLoaderFactoryProvider;
	class DependencyGraphStrategyProvider extends common_1.ClassFactoryProvider {
	    constructor(name, clazz) {
	        super(DependencyGraphStrategyProvider.getNamespace(name), clazz);
	        this.name = name;
	    }
	    static getNamespace(name) {
	        return [DependencyGraphStrategyProvider.ID, name].join("/");
	    }
	    static create(strategyName, config, injector) {
	        const dependency = injector.query(this.getNamespace(strategyName));
	        return dependency && dependency.create(config);
	    }
	}
	DependencyGraphStrategyProvider.ID = "dependencyGraphStrategies";
	exports.DependencyGraphStrategyProvider = DependencyGraphStrategyProvider;
	class DependencyGraphProvider extends common_1.Provider {
	    constructor(clazz) {
	        super(DependencyGraphProvider.ID, clazz);
	        this.clazz = clazz;
	        this._instances = {};
	    }
	    clone() {
	        return new DependencyGraphProvider(this.clazz);
	    }
	    getInstance(options) {
	        const strategyName = (options && options.name) || "default";
	        if (this._instances[strategyName])
	            return this._instances[strategyName];
	        return this._instances[strategyName] = this.owner.inject(new this.clazz(options && DependencyGraphStrategyProvider.create(options.name, options.config, this.owner)));
	    }
	    static getInstance(options, injector) {
	        return injector.query(this.ID).getInstance(options);
	    }
	}
	DependencyGraphProvider.ID = "dependencyGraphs";
	exports.DependencyGraphProvider = DependencyGraphProvider;
	class DependencyGraphStrategyOptionsProvider extends common_1.Provider {
	    constructor(name, test, options) {
	        super(DependencyGraphStrategyOptionsProvider.getId(name), options);
	        this.name = name;
	        this.test = test;
	        this.options = options;
	    }
	    static getId(name) {
	        return [this.NS, name].join("/");
	    }
	    clone() {
	        return new DependencyGraphStrategyOptionsProvider(this.name, this.test, this.options);
	    }
	    static find(filePath, injector) {
	        const provider = injector.queryAll(this.getId("**")).find(provider => provider.test(filePath));
	        return provider && provider.value;
	    }
	}
	DependencyGraphStrategyOptionsProvider.NS = "dependencyGraphStrategyOptions";
	exports.DependencyGraphStrategyOptionsProvider = DependencyGraphStrategyOptionsProvider;


/***/ },
/* 192 */
/***/ function(module, exports) {

	"use strict";


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const path = __webpack_require__(6);
	const memoize = __webpack_require__(177);
	const lodash_1 = __webpack_require__(56);
	const messages_1 = __webpack_require__(182);
	const watcher_1 = __webpack_require__(194);
	const providers_1 = __webpack_require__(168);
	const mesh_1 = __webpack_require__(13);
	const common_1 = __webpack_require__(46);
	// TODO - cover case where depenedency doesn't exist
	let Dependency = class Dependency extends common_1.BaseActiveRecord {
	    constructor(source, collectionName, _graph) {
	        super(source, collectionName);
	        this._graph = _graph;
	        this.idProperty = "hash";
	        this.status = new common_1.Status(common_1.Status.IDLE);
	        this.load2 = memoize(() => __awaiter(this, void 0, void 0, function* () {
	            this.logger.debug("Loading...");
	            const logTimer = this.logger.startTimer(null, null, common_1.LogLevel.DEBUG);
	            const fileCache = yield this.getSourceFileCacheItem();
	            const sourceFileUpdatedAt = yield this.getLatestSourceFileUpdateTimestamp();
	            if (this._sourceUpdatedAt !== sourceFileUpdatedAt) {
	                // sync update times. TODO - need to include included files as well. This is at the beginning
	                // in case the file cache item changes while the dependency is loading (shouldn't happen so often).
	                this._sourceUpdatedAt = sourceFileUpdatedAt;
	                // catch errors during load -- this *will* happen if the content has syntax errors that the
	                // loader doesn't know how to handle.
	                try {
	                    yield this.loadHard();
	                }
	                catch (e) {
	                    this.logger.error(`Error: ${e.stack}`);
	                    this._sourceUpdatedAt = undefined;
	                    yield this.watchForChanges();
	                    throw e;
	                }
	                yield this.save();
	            }
	            else {
	                this.logger.debug("No change. Reusing cached content.");
	            }
	            yield this.loadDependencies();
	            logTimer.stop("loaded");
	            if (this._sourceUpdatedAt !== (yield this.getLatestSourceFileUpdateTimestamp())) {
	                this.logger.debug("File cache changed during load, reloading.");
	                return this.reload();
	            }
	            // watch for changes now prevent cyclical dependencies from cyclically
	            // listening and emitting the same "done" actions
	            yield this.watchForChanges();
	            return this;
	        }), { length: 0, promise: true });
	        this._fileCacheItemObserver = new mesh_1.CallbackDispatcher(this.onFileCacheAction.bind(this));
	    }
	    $didInject() {
	        this.logger.generatePrefix = () => `${this.hash}:${this.filePath} `;
	    }
	    /**
	     * The file cache reference that contains
	     *
	     * @readonly
	     * @type {FileCacheItem}
	     */
	    getSourceFileCacheItem() {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (this._fileCacheItem)
	                return this._fileCacheItem;
	            return this._fileCacheItem = yield this._fileCache.item(this.filePath);
	        });
	    }
	    get graph() {
	        return this._graph;
	    }
	    /**
	     * Timestamp of when the bundle was last persisted to the data store.
	     *
	     * @readonly
	     * @type {number}
	     */
	    get updatedAt() {
	        return this._updatedAt;
	    }
	    /**
	     */
	    get hash() {
	        return this._hash;
	    }
	    /**
	     * The source map of the transformed content.
	     *
	     * @readonly
	     */
	    get map() {
	        return this._map;
	    }
	    /**
	     * The source file path
	     *
	     * @readonly
	     */
	    get filePath() {
	        return this._filePath;
	    }
	    /**
	     */
	    get importedDependencyInfo() {
	        return this._importedDependencyInfo;
	    }
	    /**
	     */
	    get includedDependencyInfo() {
	        return this._includedDependencyInfo;
	    }
	    /**
	     */
	    get loaderOptions() {
	        return this._loaderOptions;
	    }
	    /**
	     * The relative to absolute dependency paths defined in this bundle
	     *
	     * @readonly
	     */
	    get absoluteProviderPaths() {
	        return this._importedDependencyInfo.map(info => info.filePath);
	    }
	    /**
	     * The loaded bundle type
	     *
	     * @readonly
	     */
	    get type() {
	        return this._type;
	    }
	    /**
	     * The dependency bundle references
	     *
	     * @readonly
	     * @type {Dependency[]}
	     */
	    get importedDependencies() {
	        return this._importedDependencyInfo.map((inf) => {
	            return this._graph.eagerFindByHash(inf.hash);
	        }).filter(dep => !!dep);
	    }
	    /**
	     * The loaded bundle content
	     *
	     * @readonly
	     * @type {string}
	     */
	    get content() {
	        return this._content;
	    }
	    willSave() {
	        this._updatedAt = Date.now();
	    }
	    getDependencyHash(relativeOrAbsolutePath) {
	        const info = this._importedDependencyInfo.find(info => info.relativePath === relativeOrAbsolutePath || info.filePath === relativeOrAbsolutePath);
	        return info && info.hash;
	    }
	    eagerGetDependency(relativeOrAbsolutePath) {
	        return this._graph.eagerFindByHash(this.getDependencyHash(relativeOrAbsolutePath));
	    }
	    serialize() {
	        return {
	            map: this._map,
	            hash: this._hash,
	            type: this._type,
	            content: this._content,
	            filePath: this.filePath,
	            updatedAt: this._updatedAt,
	            loaderOptions: this._loaderOptions,
	            sourceUpdatedAt: this._sourceUpdatedAt,
	            includedDependencyInfo: this._includedDependencyInfo,
	            importedDependencyInfo: this._importedDependencyInfo,
	        };
	    }
	    setPropertiesFromSource({ filePath, loaderOptions, type, updatedAt, map, content, importedDependencyInfo, includedDependencyInfo, hash, sourceUpdatedAt }) {
	        this._type = type;
	        this._filePath = filePath;
	        this._loaderOptions = loaderOptions || {};
	        this._updatedAt = updatedAt;
	        this._sourceUpdatedAt = sourceUpdatedAt;
	        this._hash = hash;
	        this._map = map;
	        this._content = content;
	        this._importedDependencyInfo = importedDependencyInfo || [];
	        this._includedDependencyInfo = includedDependencyInfo || [];
	    }
	    get watcher() {
	        return this._watcher || (this._watcher = new watcher_1.DependencyGraphWatcher(this));
	    }
	    load() {
	        return __awaiter(this, void 0, void 0, function* () {
	            // safe method that protects _loading from being locked
	            // from errors.
	            if (this.status.type === common_1.Status.LOADING || this.status.type === common_1.Status.COMPLETED) {
	                return this.load2();
	            }
	            return new Promise((resolve, reject) => {
	                this.status = new common_1.Status(common_1.Status.LOADING);
	                this.load2().then(() => {
	                    this.status = new common_1.Status(common_1.Status.COMPLETED);
	                    this.notify(new messages_1.DependencyEvent(messages_1.DependencyEvent.DEPENDENCY_LOADED));
	                    resolve(this);
	                }, (err) => {
	                    this.status = new common_1.Status(common_1.Status.ERROR);
	                    reject(err);
	                });
	            });
	        });
	    }
	    getLatestSourceFileUpdateTimestamp() {
	        return __awaiter(this, void 0, void 0, function* () {
	            return Math.max(this._sourceUpdatedAt || 0, ...((yield this.getSourceFiles()).map(sourceFile => sourceFile.updatedAt || 0)));
	        });
	    }
	    getSourceFiles() {
	        return __awaiter(this, void 0, void 0, function* () {
	            return [
	                yield this.getSourceFileCacheItem(),
	                ...(yield Promise.all(this._includedDependencyInfo.map(info => this._fileCache.item(info.filePath))))
	            ];
	        });
	    }
	    /**
	     */
	    loadHard() {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.logger.debug("Transforming source content using graph strategy");
	            const loader = this._graph.getLoader(this._loaderOptions);
	            const transformResult = yield loader.load(this, yield this.getInitialSourceContent());
	            this._content = transformResult.content;
	            this._map = transformResult.map;
	            this._type = transformResult.type;
	            this._importedDependencyInfo = [];
	            this._includedDependencyInfo = [];
	            const importedDependencyPaths = transformResult.importedDependencyPaths || [];
	            // cases where there's overlapping between imported & included dependencies (probably)
	            // a bug with the module loader, or discrepancy between how the strategy and target bundler should behave.
	            const includedDependencyPaths = lodash_1.pull(transformResult.includedDependencyPaths || [], ...importedDependencyPaths);
	            yield Promise.all([
	                this.resolveDependencies(includedDependencyPaths, this._includedDependencyInfo),
	                this.resolveDependencies(importedDependencyPaths, this._importedDependencyInfo)
	            ]);
	        });
	    }
	    /**
	     */
	    loadDependencies() {
	        return __awaiter(this, void 0, void 0, function* () {
	            yield Promise.all(this.importedDependencyInfo.map((info) => __awaiter(this, void 0, void 0, function* () {
	                if (!info.filePath)
	                    return Promise.resolve();
	                const dependency = yield this._graph.getDependency(info);
	                const waitLogger = this.logger.startTimer(`Waiting for dependency ${info.hash}:${info.filePath} to load...`, 1000 * 10, common_1.LogLevel.DEBUG);
	                // if the dependency is loading, then they're likely a cyclical dependency
	                if (dependency.status.type !== common_1.Status.LOADING) {
	                    try {
	                        yield dependency.load();
	                    }
	                    catch (e) {
	                        waitLogger.stop(`Error while loading dependency: ${info.filePath}`);
	                        throw e;
	                    }
	                }
	                waitLogger.stop(`Loaded dependency ${info.hash}:${info.filePath}`);
	            })));
	        });
	    }
	    /**
	     * TODO: may be better to make this part of the loader
	     */
	    getInitialSourceContent() {
	        return __awaiter(this, void 0, void 0, function* () {
	            return {
	                type: this.filePath && common_1.MimeTypeProvider.lookup(this.filePath, this._injector) || common_1.PLAIN_TEXT_MIME_TYPE,
	                content: this.filePath && (yield (yield this.getSourceFileCacheItem()).read())
	            };
	        });
	    }
	    shouldDeserialize(b) {
	        return b.updatedAt > this.updatedAt;
	    }
	    watchForChanges() {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (this._changeWatchers) {
	                this._changeWatchers.dispose();
	            }
	            const changeWatchers = this._changeWatchers = new common_1.DisposableCollection();
	            // included dependencies aren't self contained, so they don't get a Dependency object. For
	            // that we'll need to watch their file cache active record and watch it for any changes. Since
	            // they're typically included in the
	            for (const sourceFile of yield this.getSourceFiles()) {
	                this.logger.debug(`Watching file cache ${sourceFile.filePath} for changes`);
	                sourceFile.observe(this._fileCacheItemObserver);
	                changeWatchers.push({
	                    dispose: () => sourceFile.unobserve(this._fileCacheItemObserver)
	                });
	            }
	        });
	    }
	    visitWalker(walker) {
	        this.importedDependencies.forEach(dependency => walker.accept(dependency));
	    }
	    resolveDependencies(dependencyPaths, info) {
	        return Promise.all(dependencyPaths.map((relativePath) => __awaiter(this, void 0, void 0, function* () {
	            this.logger.debug("Resolving dependency", relativePath);
	            const dependencyInfo = yield this._graph.resolve(relativePath, path.dirname(this.filePath));
	            dependencyInfo.relativePath = relativePath;
	            info.push(dependencyInfo);
	        })));
	    }
	    reload() {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.load2["clear"]();
	            this.status = new common_1.Status(common_1.Status.IDLE);
	            this.logger.debug("Reloading");
	            return this.load();
	        });
	    }
	    onFileCacheAction({ mutation }) {
	        // reload the dependency if file cache item changes -- could be the data url, source file, etc.
	        if (mutation && mutation.type === common_1.PropertyMutation.PROPERTY_CHANGE && this.status.type !== common_1.Status.LOADING) {
	            this.logger.info("Source file changed ");
	            this.reload();
	        }
	    }
	};
	__decorate([
	    common_1.inject(providers_1.FileCacheProvider.ID)
	], Dependency.prototype, "_fileCache", void 0);
	__decorate([
	    common_1.inject(providers_1.FileSystemProvider.ID)
	], Dependency.prototype, "_fileSystem", void 0);
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], Dependency.prototype, "_injector", void 0);
	__decorate([
	    common_1.bindable()
	], Dependency.prototype, "status", void 0);
	Dependency = __decorate([
	    common_1.loggable()
	], Dependency);
	exports.Dependency = Dependency;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const memoize = __webpack_require__(177);
	const mesh_1 = __webpack_require__(13);
	const common_1 = __webpack_require__(46);
	const utils_1 = __webpack_require__(195);
	const RELOAD_TIMEOUT = 1000 * 3;
	let DependencyGraphWatcher = class DependencyGraphWatcher extends common_1.Observable {
	    constructor(entry) {
	        super();
	        this.entry = entry;
	        this.waitForAllDependencies = memoize(() => __awaiter(this, void 0, void 0, function* () {
	            this.status = new common_1.Status(common_1.Status.LOADING);
	            let deps;
	            try {
	                while (true) {
	                    yield this.entry.load();
	                    deps = utils_1.flattenDependencies(this.entry);
	                    const loadingDependencies = deps.filter(dep => dep.status.type === common_1.Status.LOADING);
	                    // Break if everything is loaded in the dependency graph starting from this instance.
	                    // if there were loading deps, then there may be more imported deps that are being loaded in,
	                    // so we'll need to re-traverse the entire DEP graph to ensure that they're checked.
	                    if (!loadingDependencies.length)
	                        break;
	                    this.logger.debug(`Waiting for ${loadingDependencies.length} dependencies to load`);
	                    yield Promise.all(loadingDependencies.map(dep => dep.load()));
	                }
	            }
	            catch (e) {
	                this.status = new common_1.Status(common_1.Status.ERROR, e);
	                // watch whatever is currently loaded in
	                this.watchDependencies();
	                throw e;
	            }
	            this.watchDependencies();
	            this.status = new common_1.Status(common_1.Status.COMPLETED);
	        }), { promise: true });
	        this._dependencyObserver = new mesh_1.CallbackDispatcher(this.onDependencyEvent.bind(this));
	    }
	    dispose() {
	        this._dependencyObservers.dispose();
	        this._dependencyObservers = undefined;
	    }
	    watchDependencies() {
	        if (this._dependencyObservers) {
	            this._dependencyObservers.dispose();
	        }
	        this._dependencyObservers = new common_1.DisposableCollection();
	        for (const dep of utils_1.flattenDependencies(this.entry)) {
	            dep.observe(this._dependencyObserver);
	            this._dependencyObservers.push({
	                dispose: () => dep.unobserve(this._dependencyObserver)
	            });
	        }
	    }
	    onDependencyEvent(action) {
	        if (this.status && this.status.type === common_1.Status.LOADING)
	            return;
	        this.waitForAllDependencies["clear"]();
	        this.waitForAllDependencies();
	    }
	};
	__decorate([
	    common_1.bindable(true)
	], DependencyGraphWatcher.prototype, "status", void 0);
	DependencyGraphWatcher = __decorate([
	    common_1.loggable()
	], DependencyGraphWatcher);
	exports.DependencyGraphWatcher = DependencyGraphWatcher;


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	class DependencyWalker extends common_1.TreeWalker {
	    constructor(each) {
	        super(each);
	        this._walked = {};
	    }
	    accept(dependency) {
	        if (this._walked[dependency.hash])
	            return;
	        this._walked[dependency.hash] = true;
	        super.accept(dependency);
	    }
	}
	exports.DependencyWalker = DependencyWalker;
	function flattenDependencies(root) {
	    const deps = [];
	    new DependencyWalker((dependency) => {
	        deps.push(dependency);
	    }).accept(root);
	    return deps;
	}
	exports.flattenDependencies = flattenDependencies;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const memoize = __webpack_require__(177);
	const strategies_1 = __webpack_require__(183);
	const dependency_1 = __webpack_require__(193);
	const common_1 = __webpack_require__(46);
	/**
	 * Singleton graph dependency for mapping and transforming application source code
	 * into one bundle file.
	 */
	let DependencyGraph = class DependencyGraph extends common_1.Observable {
	    constructor(_strategy) {
	        super();
	        this._strategy = _strategy;
	        /**
	         */
	        this.getDependency = memoize((ops) => __awaiter(this, void 0, void 0, function* () {
	            return this.eagerFindByHash(ops.hash) || (yield this.collection.loadOrInsertItem({ hash: ops.hash }, ops));
	        }), { promise: true, normalizer: args => args[0].hash });
	        /**
	         */
	        this.loadDependency = memoize((ops) => __awaiter(this, void 0, void 0, function* () {
	            const entry = yield this.getDependency(ops);
	            const logTimer = this.logger.startTimer();
	            yield entry.load();
	            logTimer.stop(`Loaded ${ops.filePath}`);
	            return entry;
	        }), { promise: true, normalizer: args => args[0].hash });
	    }
	    $didInject() {
	        // temporary - this should be passed into the constructor
	        this.$strategy = this._strategy || this.$injector.inject(new strategies_1.DefaultDependencyGraphStrategy());
	        this._collection = common_1.ActiveRecordCollection.create(this.collectionName, this.$injector, (source) => {
	            return this.$injector.inject(new dependency_1.Dependency(source, this.collectionName, this));
	        });
	        this.logger.generatePrefix = () => `(~${this.$strategy.constructor.name}~) `;
	        this.logger.debug("Created");
	        this.collection.sync();
	    }
	    get collection() {
	        return this._collection;
	    }
	    createGlobalContext() {
	        return this.$strategy.createGlobalContext();
	    }
	    createModuleContext(module) {
	        return this.$strategy.createModuleContext(module);
	    }
	    getLoader(loaderOptions) {
	        return this.$strategy.getLoader(loaderOptions);
	    }
	    get collectionName() {
	        return "dependencyGraph";
	    }
	    /**
	     * Looks for a loaded item. Though, it may not exist in memory, but it *may* exist in some other
	     * process.
	     */
	    eagerFindByHash(hash) {
	        return this.collection.find((entity) => entity.hash === hash);
	    }
	    /**
	     */
	    resolve(filePath, cwd) {
	        return this.$strategy.resolve(filePath, cwd);
	    }
	};
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], DependencyGraph.prototype, "$injector", void 0);
	DependencyGraph = __decorate([
	    common_1.loggable()
	], DependencyGraph);
	exports.DependencyGraph = DependencyGraph;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(198));
	__export(__webpack_require__(199));


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const memoize = __webpack_require__(177);
	const mesh_1 = __webpack_require__(13);
	const common_1 = __webpack_require__(46);
	let _i = 0;
	// TODO - filePath should be sourceUrl to enable different protocols such as urls
	class FileCacheItem extends common_1.BaseActiveRecord {
	    constructor(source, collectionName, _fileSystem) {
	        super(source, collectionName);
	        this._fileSystem = _fileSystem;
	        this.idProperty = "filePath";
	        this.read = memoize(() => __awaiter(this, void 0, void 0, function* () {
	            if (/^file:\/\//.test(this.url)) {
	                return yield this._fileSystem.readFile(this.url.substr("file://".length));
	            }
	            else {
	                // pollyfills don't work for data uris in Node.JS. Need to PR node-fetch for that. Quick
	                // fix or bust for now.
	                if (common_1.ENV_IS_NODE) {
	                    const data = parseDataURI(this.url);
	                    if (!data)
	                        throw new Error(`Cannot load ${this.url}.`);
	                    return new Buffer(data.content, "base64");
	                }
	                const response = yield fetch(this.url);
	                return yield response.text();
	            }
	        }), { promise: true, length: 0 });
	        this.observe(new mesh_1.CallbackDispatcher(this.onAction.bind(this)));
	    }
	    serialize() {
	        return {
	            updatedAt: this.updatedAt,
	            filePath: this.filePath,
	            sourceFileModifiedAt: this.sourceFileModifiedAt,
	            url: this.url,
	            metadata: this.metadata.data
	        };
	    }
	    shouldUpdate() {
	        return this.url !== this.source.url || this.sourceFileModifiedAt !== this.source.sourceFileModifiedAt;
	    }
	    willSave() {
	        this.updatedAt = Date.now();
	    }
	    setDataUrlContent(content, mimeType = "text/plain") {
	        if (!(content instanceof Buffer)) {
	            content = new Buffer(content, "utf8");
	        }
	        this.url = `data:${mimeType},${content.toString("base64")}`;
	        return this;
	    }
	    setFileUrl(url) {
	        this.url = `file://${url}`;
	        return this;
	    }
	    shouldDeserialize(b) {
	        return this.updatedAt < b.updatedAt;
	    }
	    setPropertiesFromSource({ filePath, updatedAt, url, metadata, sourceFileModifiedAt }) {
	        this.filePath = filePath;
	        this.url = url;
	        this.updatedAt = updatedAt;
	        this.metadata = new common_1.Metadata(metadata);
	        this.sourceFileModifiedAt = sourceFileModifiedAt;
	    }
	    onAction({ mutation }) {
	        if (mutation && mutation.type === common_1.PropertyMutation.PROPERTY_CHANGE) {
	            this.clearCache();
	        }
	    }
	    clearCache() {
	        this.read["clear"]();
	    }
	}
	__decorate([
	    common_1.bindable(true)
	], FileCacheItem.prototype, "updatedAt", void 0);
	__decorate([
	    common_1.bindable(true)
	], FileCacheItem.prototype, "sourceFileModifiedAt", void 0);
	__decorate([
	    common_1.bindable(true)
	], FileCacheItem.prototype, "url", void 0);
	__decorate([
	    common_1.bindable(true)
	], FileCacheItem.prototype, "filePath", void 0);
	__decorate([
	    common_1.bindable(true)
	], FileCacheItem.prototype, "metadata", void 0);
	exports.FileCacheItem = FileCacheItem;
	function parseDataURI(uri) {
	    const parts = uri.match(/data:(.*?),(.*)/);
	    return parts && { type: parts[1], content: parts[2] };
	}


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const memoize = __webpack_require__(177);
	const synchronizer_1 = __webpack_require__(200);
	const common_1 = __webpack_require__(46);
	const providers_1 = __webpack_require__(168);
	const item_1 = __webpack_require__(198);
	// TODO - move a lot of this logic to ActiveRecordCollection
	// TODO - remove files here after TTL
	class FileCache extends common_1.Observable {
	    constructor() {
	        super();
	        /**
	         * Returns an existing cache item entry, or creates a new one
	         * from the file system
	         */
	        this.item = memoize((filePath) => __awaiter(this, void 0, void 0, function* () {
	            if (filePath == null)
	                throw new Error(`File path must not be null or undefined`);
	            return this.collection.find((entity) => entity.filePath === filePath) || (yield this.collection.loadOrInsertItem({ filePath }, {
	                filePath: filePath,
	                url: "file://" + filePath
	            }));
	        }), { promise: true });
	    }
	    $didInject() {
	        this._collection = common_1.ActiveRecordCollection.create(this.collectionName, this._injector, (source) => {
	            return this._injector.inject(new item_1.FileCacheItem(source, this.collectionName, this._fileSystem));
	        });
	        this._collection.load();
	        this._collection.sync();
	    }
	    eagerFindByFilePath(filePath) {
	        return this.collection.find(item => item.filePath === filePath);
	    }
	    get collection() {
	        return this._collection;
	    }
	    get collectionName() {
	        return "fileCache";
	    }
	    /**
	     * Synchronizes the file cache DS with the file system. This is intended
	     * to be used the master process -- typically the node server.
	     */
	    syncWithLocalFiles() {
	        return this._synchronizer || (this._synchronizer = this._injector.inject(new synchronizer_1.FileCacheSynchronizer(this, this._bus, this._fileSystem)));
	    }
	}
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], FileCache.prototype, "_injector", void 0);
	__decorate([
	    common_1.inject(common_1.PrivateBusProvider.ID)
	], FileCache.prototype, "_bus", void 0);
	__decorate([
	    common_1.inject(providers_1.FileSystemProvider.ID)
	], FileCache.prototype, "_fileSystem", void 0);
	exports.FileCache = FileCache;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const mesh_1 = __webpack_require__(13);
	const common_1 = __webpack_require__(46);
	// TODO - need to check if file cache is up to date with local
	// TODO - needs to support other protocols such as http, and in-app
	let FileCacheSynchronizer = class FileCacheSynchronizer {
	    constructor(_cache, _bus, _fileSystem) {
	        this._cache = _cache;
	        this._bus = _bus;
	        this._fileSystem = _fileSystem;
	        this._watchers = {};
	        this._cache.collection.observe(new mesh_1.CallbackDispatcher(this.update.bind(this)));
	        this.update();
	    }
	    update() {
	        const a = Object.keys(this._watchers);
	        const b = this._cache.collection.map((item) => item.filePath);
	        common_1.diffArray(a, b, (a, b) => a === b ? 0 : -1).accept({
	            visitInsert: ({ index, value }) => {
	                // TODO - fix this -- shouldn't be watching files that do not exist
	                try {
	                    if (!/^\w+:\/\//.test(value)) {
	                        this._watchers[value] = this._fileSystem.watchFile(value, this.onLocalFindChange.bind(this, value));
	                    }
	                }
	                catch (e) {
	                    this.logger.error(e.stack);
	                }
	            },
	            visitRemove: ({ index }) => {
	                this._watchers[a[index]].dispose();
	            },
	            visitUpdate() { }
	        });
	    }
	    onLocalFindChange(filePath) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const entity = yield this._cache.item(filePath);
	            this.logger.debug(`${filePath} changed, updating cache.`);
	            // just set the timestamp instead of checking lstat -- primarily
	            // to ensure that this class works in other environments.
	            entity.sourceFileModifiedAt = Date.now();
	            // override any data urls that might be stored on the entity
	            entity.setFileUrl(filePath).save();
	        });
	    }
	};
	FileCacheSynchronizer = __decorate([
	    common_1.loggable()
	], FileCacheSynchronizer);
	exports.FileCacheSynchronizer = FileCacheSynchronizer;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const vm = __webpack_require__(202);
	const providers_1 = __webpack_require__(203);
	const common_1 = __webpack_require__(46);
	class SandboxModule {
	    constructor(sandbox, source) {
	        this.sandbox = sandbox;
	        this.source = source;
	        this.exports = {};
	    }
	    get filePath() {
	        return this.source.filePath;
	    }
	}
	exports.SandboxModule = SandboxModule;
	/**
	 * TODO - consider removing require() statement and using evaluate(bundle) instead
	 */
	let Sandbox = class Sandbox extends common_1.Observable {
	    constructor(_injector, createGlobal = () => { }) {
	        super();
	        this._injector = _injector;
	        this.createGlobal = createGlobal;
	        // for logging
	        this._injector.inject(this);
	        this._modules = {};
	    }
	    pause() {
	        this._paused = true;
	    }
	    resume() {
	        this._paused = false;
	        if (this._shouldEvaluate) {
	            this.reset();
	        }
	    }
	    get vmContext() {
	        return this._context;
	    }
	    get exports() {
	        return this._exports;
	    }
	    get global() {
	        return this._global;
	    }
	    get entry() {
	        return this._entry;
	    }
	    open(entry) {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (this._graphWatcherWatcher) {
	                this._graphWatcherWatcher.dispose();
	            }
	            this._entry = entry;
	            this._graphWatcherWatcher = common_1.watchProperty(entry.watcher, "status", this.onDependencyGraphStatusChange.bind(this)).trigger();
	            this._entry.load();
	            yield this._entry.watcher.waitForAllDependencies();
	        });
	    }
	    onDependencyGraphStatusChange(newValue, oldValue) {
	        if (newValue.type === common_1.Status.ERROR || newValue.type === common_1.Status.LOADING) {
	            this.status = newValue;
	        }
	        else if (newValue.type === common_1.Status.COMPLETED) {
	            this.reset();
	        }
	    }
	    evaluate(dependency) {
	        const hash = dependency.hash;
	        if (this._modules[dependency.hash]) {
	            return this._modules[dependency.hash].exports;
	        }
	        if (dependency.status.type !== common_1.Status.COMPLETED) {
	            throw new Error(`Attempting to evaluate dependency ${hash} that is not loaded yet.`);
	        }
	        const module = this._modules[hash] = new SandboxModule(this, dependency);
	        // TODO - cache evaluator here
	        const evaluatorFactoryDepedency = providers_1.SandboxModuleEvaluatorFactoryProvider.find(dependency.type, this._injector);
	        if (!evaluatorFactoryDepedency) {
	            throw new Error(`Cannot evaluate ${dependency.filePath}:${dependency.type} in sandbox.`);
	        }
	        this.logger.debug(`Evaluating`, dependency.filePath);
	        try {
	            evaluatorFactoryDepedency.create().evaluate(module);
	        }
	        catch (e) {
	            this.status = new common_1.Status(common_1.Status.ERROR, e);
	            throw e;
	        }
	        return this.evaluate(dependency);
	    }
	    reset() {
	        this._resetting = false;
	        try {
	            const logTimer = this.logger.startTimer();
	            this._shouldEvaluate = false;
	            const exports = this._exports;
	            const global = this._global;
	            // global may have some clean up to do (timers, open connections),
	            // so call dispose if the method is available.
	            if (global && global.dispose)
	                global.dispose();
	            this._global = this.createGlobal() || {};
	            this._context = vm.createContext(this._global);
	            this.notify(new common_1.PropertyMutation(common_1.PropertyMutation.PROPERTY_CHANGE, this, "global", this._global, global).toEvent());
	            this._modules = {};
	            this._exports = this.evaluate(this._entry);
	            logTimer.stop(`Evaluated ${this._entry.filePath}`);
	            this.notify(new common_1.PropertyMutation(common_1.PropertyMutation.PROPERTY_CHANGE, this, "exports", this._exports, exports).toEvent());
	        }
	        catch (e) {
	            this._resetting = false;
	            this.status = new common_1.Status(common_1.Status.ERROR, e);
	            throw e;
	        }
	        this._resetting = false;
	        this.status = new common_1.Status(common_1.Status.COMPLETED);
	    }
	};
	__decorate([
	    common_1.bindable(true)
	], Sandbox.prototype, "status", void 0);
	Sandbox = __decorate([
	    common_1.loggable()
	], Sandbox);
	exports.Sandbox = Sandbox;
	__export(__webpack_require__(203));
	__export(__webpack_require__(204));


/***/ },
/* 202 */
/***/ function(module, exports) {

	module.exports = require("vm");

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	class SandboxModuleEvaluatorFactoryProvider extends common_1.ClassFactoryProvider {
	    constructor(mimeType, clazz) {
	        super(SandboxModuleEvaluatorFactoryProvider.getNamespace(mimeType), clazz);
	        this.mimeType = mimeType;
	    }
	    clone() {
	        return new SandboxModuleEvaluatorFactoryProvider(this.mimeType, this.value);
	    }
	    static getNamespace(mimeType) {
	        return [this.ID, mimeType].join("/");
	    }
	    create() {
	        return super.create();
	    }
	    static find(mimeType, injector) {
	        return injector.query(this.getNamespace(mimeType));
	    }
	}
	SandboxModuleEvaluatorFactoryProvider.ID = "sandboxModuleEvaluator";
	exports.SandboxModuleEvaluatorFactoryProvider = SandboxModuleEvaluatorFactoryProvider;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const vm = __webpack_require__(202);
	let _cache = {};
	function compileSandboxScript(filePath, hash, createSource) {
	    // Using string concatenation here to preserve line numbers.
	    return _cache[hash] || (_cache[hash] = new vm.Script(createSource(), {
	        filename: filePath,
	        displayErrors: true
	    }));
	}
	// Ugly, but native constructors can only be used from the global object if they are
	// defined within a VM context.
	const GLOBAL_FIX_SHIM = "var __global = typeof window === 'undefined' ? global : window; if (!__global.Object)" +
	    "Object.assign(__global, { Object, Array, String, Math, Number , Boolean, Date, Function, RegExp, TypeError }); ";
	setInterval(() => {
	    _cache = {};
	}, 1000 * 60);
	function compileModuleSandboxScript(filePath, hash, content) {
	    // Using string concatenation here to preserve line numbers.
	    return compileSandboxScript(filePath, hash + content, () => "with($$contexts['" + hash + "']) {" +
	        GLOBAL_FIX_SHIM +
	        // guard from global context values from being overwritten.
	        "(function(){" +
	        // new line in case there's comment
	        content + "\n" +
	        "})();" +
	        "}");
	}
	exports.compileModuleSandboxScript = compileModuleSandboxScript;
	function runModuleSandboxScript(script, hash, { global, vmContext }, context) {
	    if (!global.$$contexts)
	        global.$$contexts = {};
	    global.$$contexts[hash] = context;
	    script.runInContext(vmContext);
	}
	exports.runModuleSandboxScript = runModuleSandboxScript;
	function runGlobalSandboxScript(script, { global, vmContext }) {
	    script.runInContext(vmContext);
	}
	exports.runGlobalSandboxScript = runGlobalSandboxScript;
	function compileGlobalSandboxScript(filePath, hash, content) {
	    return compileSandboxScript(filePath, hash + content, () => GLOBAL_FIX_SHIM + content);
	}
	exports.compileGlobalSandboxScript = compileGlobalSandboxScript;


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const mesh_1 = __webpack_require__(13);
	const providers_1 = __webpack_require__(168);
	const synthetic_1 = __webpack_require__(170);
	const common_1 = __webpack_require__(46);
	let BaseContentEditor = class BaseContentEditor {
	    constructor(fileName, content) {
	        this.fileName = fileName;
	        this.content = content;
	    }
	    $didInject() {
	        this._rootASTNode = this.parseContent(this.content);
	    }
	    // add filePath and content in constructor here instead
	    applyMutations(mutations) {
	        for (const mutation of mutations) {
	            const method = this[mutation.type];
	            if (method) {
	                const targetASTNode = this.findTargetASTNode(this._rootASTNode, mutation.target);
	                if (targetASTNode) {
	                    method.call(this, targetASTNode, mutation);
	                }
	                else {
	                    this.logger.error(`Cannot apply edit ${mutation.type} on ${this.fileName}: AST node for synthetic object not found.`);
	                }
	            }
	            else {
	                this.logger.warn(`Cannot apply edit ${mutation.type} on ${this.fileName}.`);
	            }
	        }
	        return this.getFormattedContent(this._rootASTNode);
	    }
	};
	BaseContentEditor = __decorate([
	    common_1.loggable()
	], BaseContentEditor);
	exports.BaseContentEditor = BaseContentEditor;
	class BaseContentEdit {
	    constructor(target) {
	        this.target = target;
	        this._mutations = [];
	    }
	    /**
	     * Lock the edit from any new modifications
	     */
	    lock() {
	        this._locked = true;
	        return this;
	    }
	    get locked() {
	        return this._locked;
	    }
	    get mutations() {
	        return this._mutations;
	    }
	    /**
	     * Applies all edit.changes against the target synthetic object.
	     *
	     * @param {(T & IEditable)} target the target to apply the edits to
	     */
	    applyMutationsTo(target, each) {
	        // need to setup an editor here since some events may be intented for
	        // children of the target object
	        const editor = new SyntheticObjectTreeEditor(target, each);
	        editor.applyMutations(this.mutations);
	    }
	    /**
	     * creates a new diff edit -- note that diff edits can only contain diff
	     * events since any other event may foo with the diffing.
	     *
	     * @param {T} newSynthetic
	     * @returns
	     */
	    fromDiff(newSynthetic) {
	        const ctor = this.constructor;
	        // TODO - shouldn't be instantiating the constructor property (it may require more params). Use clone method
	        // instead.
	        const clone = new ctor(this.target);
	        return clone.addDiff(newSynthetic).lock();
	    }
	    addChange(mutation) {
	        // locked to prevent other events busting this edit.
	        if (this._locked) {
	            throw new Error(`Cannot modify a locked edit.`);
	        }
	        this._mutations.push(mutation);
	        // return the event so that it can be edited
	        return mutation;
	    }
	    addChildEdit(edit) {
	        this._mutations.push(...edit.mutations);
	        return this;
	    }
	}
	exports.BaseContentEdit = BaseContentEdit;
	let FileEditor = class FileEditor {
	    applyMutations(mutations) {
	        if (this._mutations == null) {
	            this._shouldEditAgain = true;
	            this._mutations = [];
	        }
	        this._mutations.push(...mutations);
	        return this._promise || (this._promise = new Promise((resolve, reject) => {
	            setImmediate(() => {
	                let done = () => this._promise = undefined;
	                this.run().then(resolve, reject).then(done, done);
	            });
	        }));
	    }
	    run() {
	        return __awaiter(this, void 0, void 0, function* () {
	            this._shouldEditAgain = false;
	            const changes = this._mutations;
	            this._mutations = undefined;
	            const mutationsByFilePath = {};
	            // find all events that are part of the same file and
	            // batch them together. Important to ensure that we do not trigger multiple
	            // unecessary updates to any file listeners.
	            for (const mutation of changes) {
	                const target = mutation.target;
	                // This may happen if edits are being applied to synthetic objects that
	                // do not have the proper mappings
	                if (!target.source || !target.source.filePath) {
	                    this.logger.error(`Cannot edit file, source property is mising from ${target.clone(false).toString()}.`);
	                    continue;
	                }
	                const targetSource = target.source;
	                const targetFilePath = yield providers_1.ProtocolURLResolverProvider.resolve(targetSource.filePath, this._injector);
	                const filePathMutations = mutationsByFilePath[targetFilePath] || (mutationsByFilePath[targetFilePath] = []);
	                filePathMutations.push(mutation);
	            }
	            const promises = [];
	            for (const filePath in mutationsByFilePath) {
	                const contentEditorFactoryProvider = providers_1.ContentEditorFactoryProvider.find(common_1.MimeTypeProvider.lookup(filePath, this._injector), this._injector);
	                if (!contentEditorFactoryProvider) {
	                    this.logger.error(`No synthetic edit consumer exists for ${filePath}.`);
	                    continue;
	                }
	                const autoSave = contentEditorFactoryProvider.autoSave;
	                const fileCache = yield providers_1.FileCacheProvider.getInstance(this._injector).item(filePath);
	                const oldContent = String(yield fileCache.read());
	                // error may be thrown if the content is invalid
	                try {
	                    const contentEditor = contentEditorFactoryProvider.create(filePath, oldContent);
	                    const changes = mutationsByFilePath[filePath];
	                    this.logger.info(`Applying file edit.changes ${filePath}: >>`, changes.map(event => event.type).join(" "));
	                    const newContent = contentEditor.applyMutations(changes);
	                    // This may trigger if the editor does special formatting to the content with no
	                    // actual edits. May need to have a result come from the content editors themselves to check if anything's changed.
	                    // Note that checking WS changes won't cut it since formatters may swap certain characters. E.g: HTML may change single quotes
	                    // to double quotes for attributes.
	                    if (oldContent !== newContent) {
	                        fileCache.setDataUrlContent(newContent);
	                        promises.push(fileCache.save());
	                        if (autoSave) {
	                            promises.push(this._fileSystem.writeFile(fileCache.filePath, newContent));
	                        }
	                    }
	                    else {
	                        this.logger.debug(`No changes to ${filePath}`);
	                    }
	                }
	                catch (e) {
	                    this.logger.error(`Error trying to apply ${changes.map(event => event.type).join(", ")} file edit to ${filePath}: ${e.stack}`);
	                }
	            }
	            yield Promise.all(promises);
	            // edits happened during getEditedContent call
	            if (this._shouldEditAgain) {
	                this.run();
	            }
	        });
	    }
	};
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], FileEditor.prototype, "_injector", void 0);
	__decorate([
	    common_1.inject(providers_1.FileSystemProvider.ID)
	], FileEditor.prototype, "_fileSystem", void 0);
	FileEditor = __decorate([
	    common_1.loggable()
	], FileEditor);
	exports.FileEditor = FileEditor;
	class BaseEditor {
	    constructor(target) {
	        this.target = target;
	    }
	    applyMutations(mutations) {
	        if (mutations.length === 1) {
	            this.applySingleMutation(mutations[0]);
	        }
	        else {
	            for (let i = 0, n = mutations.length; i < n; i++) {
	                this.applySingleMutation(mutations[i]);
	            }
	        }
	    }
	    applySingleMutation(mutation) {
	    }
	}
	exports.BaseEditor = BaseEditor;
	class GroupEditor {
	    constructor(...editors) {
	        this.editors = editors;
	    }
	    applyMutations(mutations) {
	        for (let i = 0, n = this.editors.length; i < n; i++) {
	            this.editors[i].applyMutations(mutations);
	        }
	    }
	}
	exports.GroupEditor = GroupEditor;
	class SyntheticObjectTreeEditor {
	    constructor(root, _each) {
	        this.root = root;
	        this._each = _each;
	    }
	    applyMutations(mutations) {
	        const allSyntheticObjects = {};
	        common_1.flattenTree(this.root).forEach((child) => {
	            allSyntheticObjects[child.uid] = child;
	        });
	        for (let i = 0, n = mutations.length; i < n; i++) {
	            const mutation = mutations[i];
	            // Assuming that all edit.changes being applied to synthetics are editable. Otherwise
	            // they shouldn't be dispatched.
	            const target = allSyntheticObjects[mutation.target.uid];
	            if (!target) {
	                console.error(new Error(`Edit change ${mutation.type} target ${mutation.target.uid} not found.`));
	                continue;
	            }
	            try {
	                target.createEditor().applyMutations([mutation]);
	                // each is useful particularly for debugging diff algorithms. See tests.
	                if (this._each)
	                    this._each(target, mutation);
	            }
	            catch (e) {
	                throw new Error(`Error trying to apply edit ${mutation.type} to ${mutation.target.toString()}: ${e.stack}`);
	            }
	        }
	    }
	}
	exports.SyntheticObjectTreeEditor = SyntheticObjectTreeEditor;
	/**
	 * Watches synthetic objects, and emits changes over time.
	 */
	class SyntheticObjectChangeWatcher {
	    constructor(onChange, onClone, filterMessage) {
	        this.onChange = onChange;
	        this.onClone = onClone;
	        this.filterMessage = filterMessage;
	        this._targetObserver = new mesh_1.CallbackDispatcher(this.onTargetEvent.bind(this));
	        if (!this.filterMessage) {
	            this.filterMessage = (event) => !!event.mutation;
	        }
	    }
	    get target() {
	        return this._target;
	    }
	    set target(value) {
	        this.dispose();
	        this._target = value;
	        if (!this._clone) {
	            this._clone = value.clone(true);
	            this.onClone(this._clone);
	        }
	        else {
	            this.diff();
	        }
	        if (this._target) {
	            this._target.observe(this._targetObserver);
	        }
	    }
	    dispose() {
	        if (this._target) {
	            this._target.unobserve(this._targetObserver);
	        }
	    }
	    onTargetEvent(event) {
	        if (!this.filterMessage || this.filterMessage(event)) {
	            // debounce to batch multiple operations together
	            this.requestDiff();
	        }
	    }
	    requestDiff() {
	        if (this._ticking)
	            return;
	        this._ticking = true;
	        setImmediate(this.diff.bind(this));
	    }
	    diff() {
	        return __awaiter(this, void 0, void 0, function* () {
	            this._ticking = false;
	            if (this._diffing) {
	                this._shouldDiffAgain = true;
	                return;
	            }
	            this._diffing = true;
	            const edit = this._clone.createEdit().fromDiff(this._target);
	            if (edit.mutations.length) {
	                try {
	                    yield this.onChange(edit.mutations);
	                }
	                catch (e) {
	                    this._diffing = false;
	                    throw e;
	                }
	                edit.applyMutationsTo(this._clone);
	            }
	            this._diffing = false;
	            if (this._shouldDiffAgain) {
	                this._shouldDiffAgain = false;
	                this.diff();
	            }
	        });
	    }
	}
	exports.SyntheticObjectChangeWatcher = SyntheticObjectChangeWatcher;
	var SyntheticObjectChangeTypes;
	(function (SyntheticObjectChangeTypes) {
	    SyntheticObjectChangeTypes.SET_SYNTHETIC_SOURCE_EDIT = "setSyntheticSourceEdit";
	})(SyntheticObjectChangeTypes = exports.SyntheticObjectChangeTypes || (exports.SyntheticObjectChangeTypes = {}));
	class SyntheticObjectEditor extends BaseEditor {
	    applySingleMutation(mutation) {
	        if (mutation.type === SyntheticObjectChangeTypes.SET_SYNTHETIC_SOURCE_EDIT) {
	            this.target.$source = mutation.newValue;
	        }
	    }
	}
	exports.SyntheticObjectEditor = SyntheticObjectEditor;
	class SyntheticObjectEdit extends BaseContentEdit {
	    setSource(source) {
	        this.addChange(new common_1.PropertyMutation(SyntheticObjectChangeTypes.SET_SYNTHETIC_SOURCE_EDIT, this.target, "$source", source));
	    }
	    addDiff(from) {
	        if (!synthetic_1.syntheticSourceInfoEquals(this.target.$source, from.$source)) {
	            this.setSource(from.$source);
	        }
	        return this;
	    }
	}
	exports.SyntheticObjectEdit = SyntheticObjectEdit;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const dependency_graph_1 = __webpack_require__(181);
	const file_cache_1 = __webpack_require__(197);
	const edit_1 = __webpack_require__(205);
	const common_1 = __webpack_require__(46);
	const file_system_1 = __webpack_require__(171);
	const resolver_1 = __webpack_require__(176);
	const dependency_graph_2 = __webpack_require__(181);
	const providers_1 = __webpack_require__(168);
	function createSandboxProviders(fileSystemClass, fileResoverClass) {
	    return [
	        new providers_1.FileSystemProvider(fileSystemClass || (common_1.ENV_IS_NODE ? file_system_1.LocalFileSystem : file_system_1.RemoteFileSystem)),
	        new providers_1.FileResolverProvider(fileResoverClass || (common_1.ENV_IS_NODE ? resolver_1.LocalFileResolver : resolver_1.RemoteFileResolver)),
	        new providers_1.FileCacheProvider(file_cache_1.FileCache),
	        new providers_1.FileEditorProvider(edit_1.FileEditor),
	        new dependency_graph_2.DependencyGraphProvider(dependency_graph_1.DependencyGraph)
	    ];
	}
	exports.createSandboxProviders = createSandboxProviders;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const common_1 = __webpack_require__(46);
	const providers_1 = __webpack_require__(166);
	/**
	 * Application services create the combined functionality of the
	 * entiry application.
	 */
	class BaseApplicationService {
	    dispatch(message) {
	        const method = this[message.type];
	        if (method) {
	            if (this.logger) {
	                this.logger.debug(`${message.type}()`);
	            }
	            return method.call(this, message);
	        }
	    }
	    $didInject() {
	        this.bus.register(this);
	        const acceptedMessageTypes = [];
	        for (const property of Object.getOwnPropertyNames(this.constructor.prototype)) {
	            const value = this[property];
	            if (typeof value === "function" && !/^([$_]|constructor)/.test(property.charAt(0))) {
	                acceptedMessageTypes.push(property);
	            }
	        }
	        this._acceptedMessageTypes = acceptedMessageTypes;
	    }
	    testMessage(message) {
	        return this._acceptedMessageTypes.length === 0 || this._acceptedMessageTypes.indexOf(message.type) !== -1;
	    }
	}
	__decorate([
	    common_1.inject(common_1.PrivateBusProvider.ID)
	], BaseApplicationService.prototype, "bus", void 0);
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], BaseApplicationService.prototype, "injector", void 0);
	exports.BaseApplicationService = BaseApplicationService;
	/**
	 * Core service required for the app to run
	 */
	class CoreApplicationService extends BaseApplicationService {
	}
	__decorate([
	    common_1.inject(providers_1.ApplicationConfigurationProvider.ID)
	], CoreApplicationService.prototype, "config", void 0);
	exports.CoreApplicationService = CoreApplicationService;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const chalk = __webpack_require__(209);
	const core_1 = __webpack_require__(165);
	const ansi_up_1 = __webpack_require__(210);
	// beat TS type checking
	chalk["" + "enabled"] = true;
	const common_1 = __webpack_require__(46);
	class ConsoleLogServiceAction extends common_1.CoreEvent {
	    constructor(type, match) {
	        super(type);
	        this.match = match;
	    }
	}
	ConsoleLogServiceAction.HIGHLIGHT_LOG = "hlog"; // abbreviated to make
	exports.ConsoleLogServiceAction = ConsoleLogServiceAction;
	function createLogColorizer(tester, replaceValue) {
	    return function (input) {
	        if (!tester.test(input))
	            return input;
	        return input.replace(tester, replaceValue);
	    };
	}
	const cwd = process.cwd();
	const highlighters = [
	    createLogColorizer(/^INF/, (match) => chalk.bgCyan(match)),
	    createLogColorizer(/^ERR/, (match) => chalk.bgRed(match)),
	    createLogColorizer(/^DBG/, (match) => chalk.grey.bgBlack(match)),
	    createLogColorizer(/^WRN/, (match) => chalk.bgYellow(match)),
	    // timestamp
	    createLogColorizer(/\[\d+\.\d+\.\d+\]/, (match, inner) => `[${chalk.grey(inner)}]`),
	    // URL
	    createLogColorizer(/((\w{3,}\:\/\/)|([^\/\s\("':]+)?\/)([^\/\)\s"':]+\/?)+/g, (match) => {
	        return chalk.yellow(/\w+:\/\//.test(match) ? match : match.replace(cwd + "/", ""));
	    }),
	    // duration
	    createLogColorizer(/\s\d+(\.\d+)?(s|ms|m|h|d)(\s|$)/g, (match) => chalk.bold.cyan(match)),
	    // numbers
	    createLogColorizer(/\b\d+(\.\d+)?\b/g, (match, inner) => `${chalk.cyan(match)}`),
	    // strings
	    createLogColorizer(/"(.*?)"/g, (match, inner) => `"${chalk.blue(inner)}"`),
	    // tokens
	    createLogColorizer(/([\:\{\}",\(\)]|->|null|undefined|Infinity)/g, (match) => chalk.grey(match)),
	    // <<output - green (from audio again)
	    createLogColorizer(/<<(.*)/g, (match, word) => chalk.green(word)),
	    // >>input - magenta (from audio)
	    createLogColorizer(/>>(.*)/g, (match, word) => chalk.magenta(word)),
	    // **BIG EMPHASIS**
	    createLogColorizer(/\*\*(.*?)\*\*/, (match, word) => chalk.bgBlue(word)),
	    // *emphasis*
	    createLogColorizer(/\*(.*?)\*/g, (match, word) => chalk.bold(word)),
	    // ___underline___
	    createLogColorizer(/___(.*?)___/g, (match, word) => chalk.underline(word)),
	    // ~de emphasis~
	    createLogColorizer(/~(.*?)~/g, (match, word) => chalk.grey(word)),
	];
	function colorize(input) {
	    let output = input;
	    for (let i = 0, n = highlighters.length; i < n; i++)
	        output = highlighters[i](output);
	    return output;
	}
	// I'm against abbreviations, but it's happening here
	// since all of these are the same length -- saves space in stdout, and makes
	// logs easier to read.
	const PREFIXES = {
	    [common_1.LogLevel.DEBUG]: "DBG ",
	    [common_1.LogLevel.INFO]: "INF ",
	    [common_1.LogLevel.WARNING]: "WRN ",
	    [common_1.LogLevel.ERROR]: "ERR ",
	};
	class ConsoleLogService extends core_1.CoreApplicationService {
	    [common_1.LogAction.LOG]({ level, text, filterable }) {
	        const logOptions = this.config.log || {};
	        const logLevel = logOptions.level == null ? common_1.LogLevel.ALL : logOptions.level;
	        const logPrefix = logOptions.prefix || "";
	        if (!(level & logLevel) && filterable !== false)
	            return;
	        // highlight log function from argv -- --hlog="something to highlight"
	        const hlog = String(this.config && this.config.argv && this.config.argv.hlog || "");
	        const log = {
	            [common_1.LogLevel.DEBUG]: console.log.bind(console),
	            [common_1.LogLevel.LOG]: console.log.bind(console),
	            [common_1.LogLevel.INFO]: console.info.bind(console),
	            [common_1.LogLevel.WARNING]: console.warn.bind(console),
	            [common_1.LogLevel.ERROR]: console.error.bind(console)
	        }[level];
	        text = PREFIXES[level] + logPrefix + text;
	        if (!this.config.argv || this.config.argv.color !== false) {
	            text = colorize(text);
	        }
	        if (typeof window !== "undefined") {
	            return styledConsoleLog(ansi_up_1.ansi_to_html(text));
	        }
	        if (hlog) {
	            if (text.toLowerCase().indexOf(hlog.toLowerCase()) !== -1) {
	                text = text.replace(new RegExp(hlog, "ig"), match => chalk.bold.bgMagenta(match));
	            }
	        }
	        log(text);
	    }
	}
	exports.ConsoleLogService = ConsoleLogService;
	function styledConsoleLog(...args) {
	    var argArray = [];
	    if (args.length) {
	        var startTagRe = /<span\s+style=(['"])([^'"]*)\1\s*>/gi;
	        var endTagRe = /<\/span>/gi;
	        var reResultArray;
	        argArray.push(arguments[0].replace(startTagRe, '%c').replace(endTagRe, '%c'));
	        while (reResultArray = startTagRe.exec(arguments[0])) {
	            argArray.push(reResultArray[2]);
	            argArray.push('');
	        }
	        // pass through subsequent args since chrome dev tools does not (yet) support console.log styling of the following form: console.log('%cBlue!', 'color: blue;', '%cRed!', 'color: red;');
	        for (var j = 1; j < arguments.length; j++) {
	            argArray.push(arguments[j]);
	        }
	    }
	    console.log.apply(console, argArray);
	}


/***/ },
/* 209 */
/***/ function(module, exports) {

	module.exports = require("chalk");

/***/ },
/* 210 */
/***/ function(module, exports) {

	module.exports = require("ansi_up");

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const common_1 = __webpack_require__(46);
	const core_1 = __webpack_require__(165);
	const mesh_1 = __webpack_require__(13);
	// Command pattern receiver
	class ReceiverService extends core_1.BaseApplicationService {
	    dispatch(action) {
	        const commands = common_1.CommandFactoryProvider.findAllByAction(action, this._injector).map((dep) => {
	            return new mesh_1.CallbackDispatcher((message) => {
	                return dep.create().execute(message);
	            });
	        });
	        return new mesh_1.SequenceBus(commands).dispatch(action);
	    }
	    testMessage(message) {
	        // TODO - probably shouldn't do this -- slight optimization since
	        // there are currently no commands that handle logs
	        return message.type !== common_1.LogAction.LOG;
	    }
	}
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], ReceiverService.prototype, "_injector", void 0);
	exports.ReceiverService = ReceiverService;


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(213));


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const path = __webpack_require__(6);
	const sandbox_1 = __webpack_require__(167);
	const common_1 = __webpack_require__(46);
	const mesh_1 = __webpack_require__(13);
	class BaseFSModel extends common_1.TreeNode {
	    constructor(path) {
	        super();
	        this.path = path;
	    }
	    get name() {
	        return path.basename(this.path);
	    }
	    onChildAdded(child, index) {
	        super.onChildAdded(child, index);
	        if (this._injector)
	            this._injector.inject(child);
	        child.observe(new common_1.BubbleDispatcher(this));
	    }
	}
	__decorate([
	    common_1.inject(sandbox_1.FileSystemProvider.ID)
	], BaseFSModel.prototype, "_fileSystem", void 0);
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], BaseFSModel.prototype, "_injector", void 0);
	exports.BaseFSModel = BaseFSModel;
	class FileModel extends BaseFSModel {
	}
	exports.FileModel = FileModel;
	class DirectoryModel extends BaseFSModel {
	    load() {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.removeAllChildren();
	            this._fileSystem.readDirectory(this.path).pipeTo(new mesh_1.WritableStream({
	                write: ({ name, isDirectory }) => {
	                    if (name.charAt(0) === ".")
	                        return;
	                    const filePath = path.join(this.path, name);
	                    this.appendChild(isDirectory ? new DirectoryModel(filePath) : new FileModel(filePath));
	                }
	            }));
	        });
	    }
	}
	exports.DirectoryModel = DirectoryModel;


/***/ },
/* 214 */
/***/ function(module, exports) {

	"use strict";


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const common_1 = __webpack_require__(46);
	const sandbox_1 = __webpack_require__(167);
	const mesh_1 = __webpack_require__(13);
	var EditorFamilyType;
	(function (EditorFamilyType) {
	    /**
	     * Peer (client) application such as an extension
	     */
	    EditorFamilyType.TEXT_EDITOR = "textEditor";
	    /**
	     * editor app
	     */
	    EditorFamilyType.BROWSER = "browser";
	    /**
	     * Heavy lifter - may be a web worker, node worker, or live in a remote location
	     */
	    EditorFamilyType.WORKER = "worker";
	    /**
	     * Main app all others talk to
	     */
	    EditorFamilyType.MASTER = "master";
	})(EditorFamilyType = exports.EditorFamilyType || (exports.EditorFamilyType = {}));
	mesh_1.setMessageTarget(EditorFamilyType.WORKER)(sandbox_1.WatchFileRequest);
	mesh_1.setMessageTarget(EditorFamilyType.WORKER)(sandbox_1.ReadFileRequest);
	mesh_1.setMessageTarget(EditorFamilyType.WORKER)(sandbox_1.ReadDirectoryRequest);
	mesh_1.setMessageTarget(EditorFamilyType.WORKER)(sandbox_1.ResolveFileRequest);
	mesh_1.setMessageTarget(EditorFamilyType.WORKER)(sandbox_1.ApplyFileEditRequest);
	mesh_1.setMessageTarget(EditorFamilyType.WORKER)(mesh_1.DSFindRequest);
	mesh_1.setMessageTarget(EditorFamilyType.WORKER)(common_1.DSUpsertRequest);
	mesh_1.setMessageTarget(EditorFamilyType.WORKER)(mesh_1.DSInsertRequest);
	mesh_1.setMessageTarget(EditorFamilyType.WORKER)(mesh_1.DSRemoveRequest);
	mesh_1.setMessageTarget(EditorFamilyType.WORKER)(mesh_1.DSUpdateRequest);
	mesh_1.setMessageTarget(EditorFamilyType.WORKER)(mesh_1.DSFindAllRequest);
	mesh_1.addMessageVisitor(EditorFamilyType.MASTER, EditorFamilyType.WORKER, EditorFamilyType.TEXT_EDITOR)(common_1.PostDSMessage);
	let OpenFileRequest_1 = class OpenFileRequest extends common_1.CoreEvent {
	    constructor(filePath, selection) {
	        super(OpenFileRequest_1.OPEN_FILE);
	        this.filePath = filePath;
	        this.selection = selection;
	    }
	    static dispatch(filePath, selection, bus) {
	        // TODO - RESOLVE HERE
	        return bus.dispatch(new OpenFileRequest_1(filePath, selection));
	    }
	};
	let OpenFileRequest = OpenFileRequest_1;
	OpenFileRequest.OPEN_FILE = "openSourceFile";
	OpenFileRequest = OpenFileRequest_1 = __decorate([
	    mesh_1.addMessageVisitor(EditorFamilyType.BROWSER),
	    mesh_1.addMessageVisitor(EditorFamilyType.WORKER),
	    mesh_1.setMessageTarget(EditorFamilyType.MASTER),
	    common_1.serializable({
	        serialize({ filePath, selection }) {
	            return { filePath, selection };
	        },
	        deserialize({ filePath, selection }, injector) {
	            return new OpenFileRequest(filePath, selection);
	        }
	    })
	], OpenFileRequest);
	exports.OpenFileRequest = OpenFileRequest;
	let SetCurrentFileRequest_1 = class SetCurrentFileRequest extends common_1.CoreEvent {
	    constructor(filePath, selection) {
	        super(SetCurrentFileRequest_1.SET_CURRENT_FILE);
	        this.filePath = filePath;
	        this.selection = selection;
	    }
	    static dispatch(filePath, selection, bus) {
	        return bus.dispatch(new SetCurrentFileRequest_1(filePath, selection));
	    }
	};
	let SetCurrentFileRequest = SetCurrentFileRequest_1;
	SetCurrentFileRequest.SET_CURRENT_FILE = "setCurrentFile";
	SetCurrentFileRequest = SetCurrentFileRequest_1 = __decorate([
	    mesh_1.addMessageVisitor(EditorFamilyType.WORKER),
	    mesh_1.addMessageVisitor(EditorFamilyType.MASTER),
	    mesh_1.setMessageTarget(EditorFamilyType.TEXT_EDITOR),
	    common_1.serializable({
	        serialize({ filePath, selection }) {
	            return { filePath, selection };
	        },
	        deserialize({ filePath, selection }, injector) {
	            return new SetCurrentFileRequest(filePath, selection);
	        }
	    })
	], SetCurrentFileRequest);
	exports.SetCurrentFileRequest = SetCurrentFileRequest;
	// opens the given workspace in this session
	let OpenWorkspaceRequest_1 = class OpenWorkspaceRequest extends common_1.CoreEvent {
	    constructor(filePath) {
	        super(OpenWorkspaceRequest_1.OPEN_WORKSPACE);
	        this.filePath = filePath;
	    }
	    static dispatch(filePath, bus) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return (yield mesh_1.readOneChunk(bus.dispatch(new OpenWorkspaceRequest_1(filePath)))).value;
	        });
	    }
	};
	let OpenWorkspaceRequest = OpenWorkspaceRequest_1;
	OpenWorkspaceRequest.OPEN_WORKSPACE = "openWorkspace";
	OpenWorkspaceRequest = OpenWorkspaceRequest_1 = __decorate([
	    mesh_1.setMessageTarget(EditorFamilyType.BROWSER)
	], OpenWorkspaceRequest);
	exports.OpenWorkspaceRequest = OpenWorkspaceRequest;
	let ImportFileRequest_1 = class ImportFileRequest extends common_1.CoreEvent {
	    constructor(filePath, bounds, targetObject) {
	        super(ImportFileRequest_1.IMPORT_FILE);
	        this.bounds = bounds;
	        this.targetObject = targetObject;
	        this.filePath = decodeURIComponent(filePath);
	    }
	};
	let ImportFileRequest = ImportFileRequest_1;
	ImportFileRequest.IMPORT_FILE = "importFile";
	ImportFileRequest = ImportFileRequest_1 = __decorate([
	    mesh_1.addMessageVisitor(EditorFamilyType.BROWSER),
	    mesh_1.addMessageVisitor(EditorFamilyType.MASTER),
	    mesh_1.setMessageTarget(EditorFamilyType.WORKER),
	    common_1.serializable({
	        serialize({ filePath, bounds, targetObject }) {
	            return [filePath, bounds, common_1.serialize(targetObject && targetObject.clone(false))];
	        },
	        deserialize([filePath, bounds, targetObject], injector) {
	            return new ImportFileRequest(filePath, bounds, common_1.deserialize(targetObject, injector));
	        }
	    })
	], ImportFileRequest);
	exports.ImportFileRequest = ImportFileRequest;
	let SelectSourceRequest_1 = class SelectSourceRequest extends common_1.CoreEvent {
	    constructor(filePath, ranges) {
	        super(SelectSourceRequest_1.SELECT_SOURCE);
	        this.filePath = filePath;
	        this.ranges = ranges;
	    }
	};
	let SelectSourceRequest = SelectSourceRequest_1;
	SelectSourceRequest.SELECT_SOURCE = "selectSource";
	SelectSourceRequest = SelectSourceRequest_1 = __decorate([
	    mesh_1.setMessageTarget(EditorFamilyType.BROWSER),
	    common_1.serializable({
	        serialize({ filePath, ranges }) {
	            return {
	                filePath: filePath,
	                ranges: ranges
	            };
	        },
	        deserialize({ filePath, ranges }) {
	            return new SelectSourceRequest(filePath, ranges);
	        }
	    })
	], SelectSourceRequest);
	exports.SelectSourceRequest = SelectSourceRequest;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const remote_browser_1 = __webpack_require__(217);
	const core_1 = __webpack_require__(165);
	function createSyntheticBrowserWorkerProviders() {
	    return [
	        new core_1.ApplicationServiceProvider("remoteBrowserRenderer", remote_browser_1.RemoteBrowserService)
	    ];
	}
	exports.createSyntheticBrowserWorkerProviders = createSyntheticBrowserWorkerProviders;
	__export(__webpack_require__(223));
	__export(__webpack_require__(290));
	__export(__webpack_require__(219));
	__export(__webpack_require__(291));
	__export(__webpack_require__(292));
	__export(__webpack_require__(228));
	__export(__webpack_require__(218));
	__export(__webpack_require__(217));


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const messages_1 = __webpack_require__(218);
	const renderers_1 = __webpack_require__(219);
	const browser_1 = __webpack_require__(290);
	const mesh_1 = __webpack_require__(13);
	const common_1 = __webpack_require__(46);
	const services_1 = __webpack_require__(207);
	const dom_1 = __webpack_require__(223);
	const sandbox_1 = __webpack_require__(167);
	let RemoteBrowserDocumentMessage_1 = class RemoteBrowserDocumentMessage extends common_1.CoreEvent {
	    constructor(type, data) {
	        super(type);
	        this.data = data;
	    }
	};
	let RemoteBrowserDocumentMessage = RemoteBrowserDocumentMessage_1;
	RemoteBrowserDocumentMessage.NEW_DOCUMENT = "newDocument";
	RemoteBrowserDocumentMessage.DOCUMENT_DIFF = "documentDiff";
	RemoteBrowserDocumentMessage.STATUS_CHANGE = "statusChange";
	RemoteBrowserDocumentMessage = RemoteBrowserDocumentMessage_1 = __decorate([
	    common_1.serializable({
	        serialize({ type, data }) {
	            return {
	                type: type,
	                data: common_1.serialize(data)
	            };
	        },
	        deserialize({ type, data }, injector) {
	            return new RemoteBrowserDocumentMessage(type, common_1.deserialize(data, injector));
	        }
	    })
	], RemoteBrowserDocumentMessage);
	exports.RemoteBrowserDocumentMessage = RemoteBrowserDocumentMessage;
	let RemoteSyntheticBrowser = class RemoteSyntheticBrowser extends browser_1.BaseSyntheticBrowser {
	    constructor(injector, renderer, parent) {
	        super(injector, renderer, parent);
	        this.status = new common_1.Status(common_1.Status.IDLE);
	        this._bus = common_1.PrivateBusProvider.getInstance(injector);
	    }
	    open2(options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.status = new common_1.Status(common_1.Status.LOADING);
	            if (this._remoteStreamReader)
	                this._remoteStreamReader.cancel("Re-opened");
	            const remoteBrowserStream = this._bus.dispatch(new messages_1.OpenRemoteBrowserRequest(options));
	            const reader = this._remoteStreamReader = remoteBrowserStream.readable.getReader();
	            let value, done;
	            mesh_1.pump(reader, event => this.onRemoteBrowserEvent(event));
	        });
	    }
	    onRemoteBrowserEvent({ payload }) {
	        const event = common_1.deserialize(payload, this.injector);
	        this.logger.debug(`Received event: ${event.type}`);
	        if (event.type === RemoteBrowserDocumentMessage.STATUS_CHANGE) {
	            this.status = event.data;
	        }
	        if (event.type === RemoteBrowserDocumentMessage.NEW_DOCUMENT) {
	            const { data } = event;
	            this.logger.debug("Received new document");
	            const previousDocument = this.window && this.window.document;
	            const newDocument = data;
	            this._documentEditor = new sandbox_1.SyntheticObjectTreeEditor(newDocument);
	            const window = new dom_1.SyntheticWindow(this.location, this, newDocument);
	            this.setWindow(window);
	            this.status = new common_1.Status(common_1.Status.COMPLETED);
	        }
	        else if (event.type === RemoteBrowserDocumentMessage.DOCUMENT_DIFF) {
	            const { data } = event;
	            const mutations = data;
	            this.logger.debug("Received document diffs: >>", mutations.map(event => event.type).join(", "));
	            try {
	                this._documentEditor.applyMutations(mutations);
	            }
	            catch (e) {
	                console.error(e.stack);
	            }
	            this.status = new common_1.Status(common_1.Status.COMPLETED);
	        }
	        this.notify(event);
	        // explicitly request an update since some synthetic objects may not emit
	        // a render event in some cases.
	        this.renderer.requestRender();
	    }
	};
	__decorate([
	    common_1.bindable(true)
	], RemoteSyntheticBrowser.prototype, "status", void 0);
	RemoteSyntheticBrowser = __decorate([
	    common_1.loggable()
	], RemoteSyntheticBrowser);
	exports.RemoteSyntheticBrowser = RemoteSyntheticBrowser;
	let RemoteBrowserService = class RemoteBrowserService extends services_1.BaseApplicationService {
	    $didInject() {
	        super.$didInject();
	        this._openBrowsers = {};
	    }
	    [messages_1.OpenRemoteBrowserRequest.OPEN_REMOTE_BROWSER](event) {
	        // TODO - move this to its own class
	        return new mesh_1.DuplexStream((input, output) => {
	            const writer = output.getWriter();
	            const id = JSON.stringify(event.options);
	            // TODO - memoize opened browser if same session is up
	            const browser = this._openBrowsers[id] || (this._openBrowsers[id] = new browser_1.SyntheticBrowser(this.injector, new renderers_1.NoopRenderer()));
	            let currentDocument;
	            const logger = this.logger.createChild(`${event.options.url} `);
	            const changeWatcher = new sandbox_1.SyntheticObjectChangeWatcher((mutations) => __awaiter(this, void 0, void 0, function* () {
	                logger.info("Sending diffs: <<", mutations.map(event => event.type).join(", "));
	                yield writer.write({ payload: common_1.serialize(new RemoteBrowserDocumentMessage(RemoteBrowserDocumentMessage.DOCUMENT_DIFF, mutations)) });
	            }), (clone) => {
	                logger.info("Sending <<new document");
	                writer.write({ payload: common_1.serialize(new RemoteBrowserDocumentMessage(RemoteBrowserDocumentMessage.NEW_DOCUMENT, clone)) });
	            });
	            if (browser.document) {
	                changeWatcher.target = browser.document;
	            }
	            const onStatusChange = (status) => {
	                if (status) {
	                    if (status.type === common_1.Status.COMPLETED) {
	                        changeWatcher.target = browser.document;
	                    }
	                    else if (status.type === common_1.Status.ERROR) {
	                        this.logger.error("Sending error status: ", status.data);
	                    }
	                }
	                writer.write({ payload: common_1.serialize(new RemoteBrowserDocumentMessage(RemoteBrowserDocumentMessage.STATUS_CHANGE, status)) });
	            };
	            const watcher = common_1.watchProperty(browser, "status", onStatusChange);
	            onStatusChange(browser.sandbox.status);
	            browser.open(event.options);
	            return {
	                close() {
	                    // TODO - possibly shutdown here -- need to have increment counter.
	                    watcher.dispose();
	                    changeWatcher.dispose();
	                }
	            };
	        });
	    }
	};
	RemoteBrowserService = __decorate([
	    common_1.loggable()
	], RemoteBrowserService);
	exports.RemoteBrowserService = RemoteBrowserService;


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	class DOMNodeEvent extends common_1.CoreEvent {
	}
	DOMNodeEvent.DOM_NODE_LOADED = "domNodeLoaded";
	exports.DOMNodeEvent = DOMNodeEvent;
	class SyntheticRendererEvent extends common_1.CoreEvent {
	}
	SyntheticRendererEvent.UPDATE_RECTANGLES = "updateRectangles";
	exports.SyntheticRendererEvent = SyntheticRendererEvent;
	class OpenRemoteBrowserRequest extends common_1.CoreEvent {
	    constructor(options) {
	        super(OpenRemoteBrowserRequest.OPEN_REMOTE_BROWSER);
	        this.options = options;
	    }
	}
	OpenRemoteBrowserRequest.OPEN_REMOTE_BROWSER = "openRemoteBrowser";
	exports.OpenRemoteBrowserRequest = OpenRemoteBrowserRequest;


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(220));
	__export(__webpack_require__(221));


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const lodash_1 = __webpack_require__(56);
	const common_1 = __webpack_require__(46);
	const mesh_1 = __webpack_require__(13);
	const messages_1 = __webpack_require__(218);
	const common_2 = __webpack_require__(46);
	// render timeout -- this should be a low number
	const REQUEST_UPDATE_TIMEOUT = 5;
	let BaseRenderer = class BaseRenderer extends common_2.Observable {
	    constructor(nodeFactory) {
	        super();
	        this.nodeFactory = nodeFactory || (typeof document !== "undefined" ? document : undefined);
	        this._running = false;
	        this._computedStyles = {};
	        this.rectsWatcher = new common_2.PropertyWatcher(this, "rects");
	        // may be running in a worker. Do not create an element if that's the case.
	        if (this.nodeFactory) {
	            this.element = this.createElement();
	        }
	        this._targetObserver = new mesh_1.CallbackDispatcher(this.onDocumentEvent.bind(this));
	    }
	    get rects() {
	        return this.$rects;
	    }
	    get document() {
	        return this._document;
	    }
	    set document(value) {
	        if (this._document === value) {
	            this.requestRender();
	            return;
	        }
	        if (this._document) {
	            this._document.unobserve(this._targetObserver);
	        }
	        this.reset();
	        this._document = value;
	        if (!this._document)
	            return;
	        this._document.observe(this._targetObserver);
	        this.requestRender();
	    }
	    getAllBoundingRects() {
	        return lodash_1.values(this.$rects);
	    }
	    whenRunning() {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (!this._running)
	                yield common_2.waitForPropertyChange(this, "_running", value => !!value);
	        });
	    }
	    whenRendered() {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (!this._rendered)
	                yield common_2.waitForPropertyChange(this, "_rendered", value => !!value);
	        });
	    }
	    start() {
	        if (this._running)
	            return;
	        this._running = true;
	        this.requestRender();
	    }
	    stop() {
	        this._running = false;
	    }
	    getComputedStyle(uid) {
	        return this._computedStyles[uid];
	    }
	    getBoundingRect(uid) {
	        return (this.$rects && this.$rects[uid]) || new common_2.BoundingRect(0, 0, 0, 0);
	    }
	    reset() {
	    }
	    createElement() {
	        return this.nodeFactory.createElement("div");
	    }
	    setRects(rects, styles) {
	        const oldRects = this.$rects;
	        this.$rects = rects;
	        this._computedStyles = styles;
	        this._rendered = true;
	        this.notify(new common_2.PropertyMutation(common_2.PropertyMutation.PROPERTY_CHANGE, this, "rects", rects, oldRects).toEvent());
	        // DEPRECATED
	        this.notify(new messages_1.SyntheticRendererEvent(messages_1.SyntheticRendererEvent.UPDATE_RECTANGLES));
	    }
	    onDocumentEvent(event) {
	        if (this.element && (event.type === common_1.MutationEvent.MUTATION)) {
	            this.onDocumentMutationEvent(event);
	        }
	    }
	    onDocumentMutationEvent(event) {
	        this.requestRender();
	    }
	    requestRender() {
	        if (!this._document)
	            return;
	        if (this._currentRenderPromise) {
	            this._shouldRenderAgain = true;
	        }
	        return this._currentRenderPromise || (this._currentRenderPromise = new Promise((resolve, reject) => {
	            const done = () => {
	                this._currentRenderPromise = undefined;
	            };
	            // renderer here doesn't need to be particularly fast since the user
	            // doesn't get to interact with visual content. Provide a slowish
	            // timeout to ensure that we don't kill CPU from unecessary renders.
	            const render = () => __awaiter(this, void 0, void 0, function* () {
	                if (!this._document)
	                    return;
	                yield this.whenRunning();
	                this._shouldRenderAgain = false;
	                this.logger.debug("Rendering synthetic document");
	                yield this.render();
	                if (this._shouldRenderAgain) {
	                    this._shouldRenderAgain = false;
	                    yield render();
	                }
	            });
	            setTimeout(() => {
	                render().then(resolve, reject).then(done, done);
	            }, this.getRequestUpdateTimeout());
	        }));
	    }
	    getRequestUpdateTimeout() {
	        // OVERRIDE ME - used for dynamic render throttling
	        return REQUEST_UPDATE_TIMEOUT;
	    }
	};
	__decorate([
	    common_2.bindable()
	], BaseRenderer.prototype, "_rendered", void 0);
	__decorate([
	    common_2.bindable()
	], BaseRenderer.prototype, "_running", void 0);
	BaseRenderer = __decorate([
	    common_2.loggable()
	], BaseRenderer);
	exports.BaseRenderer = BaseRenderer;
	class BaseDecoratorRenderer extends common_2.Observable {
	    constructor(_renderer) {
	        super();
	        this._renderer = _renderer;
	        _renderer.observe(new mesh_1.CallbackDispatcher(this.onTargetRendererEvent.bind(this)));
	    }
	    get rects() {
	        return this._renderer.rects;
	    }
	    get rectsWatcher() {
	        return this._renderer.rectsWatcher;
	    }
	    getComputedStyle(uid) {
	        return this._renderer.getComputedStyle(uid);
	    }
	    getBoundingRect(uid) {
	        return this._renderer.getBoundingRect(uid);
	    }
	    getAllBoundingRects() {
	        return this._renderer.getAllBoundingRects();
	    }
	    whenRunning() {
	        return this._renderer.whenRunning();
	    }
	    start() {
	        this._renderer.start();
	    }
	    stop() {
	        this._renderer.stop();
	    }
	    get element() {
	        return this._renderer.element;
	    }
	    get document() {
	        return this._renderer.document;
	    }
	    set document(value) {
	        this._renderer.document = value;
	    }
	    requestRender() {
	        return this._renderer.requestRender();
	    }
	    onTargetRendererEvent(action) {
	        if (action.type === messages_1.SyntheticRendererEvent.UPDATE_RECTANGLES) {
	            this.onTargetRendererSetRectangles();
	        }
	        // bubble up
	        this.notify(action);
	    }
	    onTargetRendererSetRectangles() {
	    }
	}
	exports.BaseDecoratorRenderer = BaseDecoratorRenderer;
	class NoopRenderer extends BaseRenderer {
	    getBoundingRect() {
	        return common_2.BoundingRect.zeros();
	    }
	    get rects() {
	        return {};
	    }
	    getEagerComputedStyle() {
	        return null;
	    }
	    getAllBoundingRects() {
	        return [];
	    }
	    whenRunning() {
	        return Promise.resolve();
	    }
	    start() { }
	    stop() { }
	    getComputedStyle() {
	        return null;
	    }
	    hasLoadedComputedStyle() {
	        return false;
	    }
	    render() { }
	    createElement() { return undefined; }
	}
	exports.NoopRenderer = NoopRenderer;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const ent_1 = __webpack_require__(222);
	const base_1 = __webpack_require__(220);
	const dom_1 = __webpack_require__(223);
	const common_1 = __webpack_require__(46);
	const dom_2 = __webpack_require__(223);
	const ss = null;
	function getHostStylesheets(node) {
	    let p = node.parentNode;
	    while (p.parentNode)
	        p = p.parentNode;
	    return p.styleSheets || [];
	}
	function filterInvalidMediaRules(rules) {
	}
	class SyntheticDOMRenderer extends base_1.BaseRenderer {
	    constructor(nodeFactory, getComputedStyle) {
	        super(nodeFactory);
	        this._getComputedStyle = getComputedStyle || (typeof window !== "undefined" ? window.getComputedStyle.bind(window) : () => { });
	    }
	    createElement() {
	        const element = this.nodeFactory.createElement("div");
	        element.innerHTML = this.createElementInnerHTML();
	        return element;
	    }
	    createElementInnerHTML() {
	        return "<span></span><div></div>";
	    }
	    onDocumentMutationEvent({ mutation }) {
	        super.onDocumentMutationEvent(arguments[0]);
	        if (dom_2.isDOMNodeMutation(mutation)) {
	            const [nativeNode, syntheticNode] = this.getElementDictItem(mutation.target);
	            const insertChild = (syntheticNode) => {
	                return renderHTMLNode(this.nodeFactory, syntheticNode, this._elementDictionary);
	            };
	            if (nativeNode) {
	                if (dom_2.isDOMElementMutation(mutation)) {
	                    new dom_2.DOMElementEditor(nativeNode, insertChild).applyMutations([mutation]);
	                }
	                else if (dom_2.isDOMContainerMutation(mutation)) {
	                    new dom_2.DOMContainerEditor(nativeNode, insertChild).applyMutations([mutation]);
	                }
	                else if (dom_2.isDOMValueNodeMutation(mutation)) {
	                    new dom_2.DOMValueNodeEditor(nativeNode).applyMutations([mutation]);
	                }
	            }
	            if (dom_2.isDOMDocumentMutation(mutation)) {
	                if (mutation.type === dom_2.SyntheticDocumentMutationTypes.REMOVE_DOCUMENT_STYLE_SHEET_EDIT) {
	                    this.removeCSSRules(mutation.child);
	                }
	                else if (mutation.type === dom_2.SyntheticDocumentMutationTypes.MOVE_DOCUMENT_STYLE_SHEET_EDIT) {
	                    const moveMutation = mutation;
	                }
	                else if (mutation.type === dom_2.SyntheticDocumentMutationTypes.ADD_DOCUMENT_STYLE_SHEET_EDIT) {
	                    const insertMutation = mutation;
	                    this._registerStyleSheet(insertMutation.child, insertMutation.index);
	                }
	            }
	        }
	        if (dom_2.isCSSMutation(mutation)) {
	            const styleSheet = mutation.target instanceof dom_2.SyntheticCSSStyleSheet ? mutation.target : mutation.target.parentStyleSheet;
	            const [nativeRule, syntheticRule] = this.getCSSDictItem(styleSheet);
	            // MUST replace the entire CSS text here since vendor prefixes get stripped out
	            // depending on the browser. This is the simplest method for syncing changes.
	            if (nativeRule) {
	                this.updateCSSRules(nativeRule, styleSheet);
	            }
	            else {
	            }
	        }
	    }
	    updateCSSRules(staleStyleSheet, syntheticStyleSheet) {
	        while (staleStyleSheet.rules.length) {
	            staleStyleSheet.deleteRule(0);
	        }
	        for (const rule of syntheticStyleSheet.cssRules) {
	            try {
	                staleStyleSheet.insertRule(rule.cssText, staleStyleSheet.cssRules.length);
	            }
	            catch (e) {
	            }
	        }
	    }
	    removeCSSRules(syntheticStyleSheet) {
	        const [nativeRule, syntheticRule] = this.getCSSDictItem(syntheticStyleSheet);
	        if (!nativeRule)
	            return;
	        nativeRule.ownerNode.parentNode.removeChild(nativeRule.ownerNode);
	        this._cssRuleDictionary[syntheticStyleSheet.uid] = undefined;
	    }
	    getSyntheticStyleSheetIndex(styleSheet) {
	        return this.document.styleSheets.findIndex(ss => ss.uid === styleSheet.uid);
	    }
	    getSyntheticStyleSheet(styleSheet) {
	        return this.document.styleSheets[this.getSyntheticStyleSheetIndex(styleSheet)];
	    }
	    getNativeRuleIndex(index) {
	        this.document.styleSheets.slice(index + 1).forEach((ss) => {
	            index += ss.rules.length;
	        });
	        return index;
	    }
	    getElementDictItem(synthetic) {
	        return this._elementDictionary && this._elementDictionary[synthetic.uid] || [undefined, undefined];
	    }
	    _registerStyleSheet(syntheticStyleSheet, index = Number.MAX_SAFE_INTEGER) {
	        const styleElement = this.nodeFactory.createElement("style");
	        styleElement.setAttribute("type", "text/css");
	        styleElement.textContent = syntheticStyleSheet.cssText;
	        const styleContainer = this.element.firstChild;
	        if (index > styleContainer.childNodes.length) {
	            styleContainer.appendChild(styleElement);
	        }
	        else {
	            styleContainer.insertBefore(styleElement, styleContainer.childNodes[index]);
	        }
	        return new Promise((resolve) => {
	            const tryRegistering = () => {
	                this.tryRegisteringStyleSheet(styleElement, syntheticStyleSheet).then(() => resolve(styleElement), () => {
	                    setTimeout(tryRegistering, 20);
	                });
	            };
	            setImmediate(tryRegistering);
	        });
	    }
	    render() {
	        return __awaiter(this, void 0, void 0, function* () {
	            const { document, element } = this;
	            if (!this._documentElement) {
	                yield Promise.all(document.styleSheets.map((styleSheet) => {
	                    return this._registerStyleSheet(styleSheet);
	                }).concat((new Promise(resolve => {
	                    this._documentElement = renderHTMLNode(this.nodeFactory, document, this._elementDictionary = {});
	                    element.lastChild.appendChild(this._documentElement);
	                    resolve();
	                }))));
	            }
	            this.updateRects();
	        });
	    }
	    getCSSDictItem(target) {
	        return (this._cssRuleDictionary && this._cssRuleDictionary[target.uid]) || [undefined, undefined];
	    }
	    tryRegisteringStyleSheet(styleElement, styleSheet) {
	        const nativeStyleSheet = Array.prototype.slice.call(getHostStylesheets(styleElement)).find((styleSheet) => {
	            return styleSheet.ownerNode === styleElement;
	        });
	        if (!nativeStyleSheet) {
	            return Promise.reject(new Error(`Cannot find native style sheet generated by DOM renderer.`));
	        }
	        this._cssRuleDictionary[styleSheet.uid] = [nativeStyleSheet, styleSheet];
	        return Promise.resolve();
	    }
	    reset() {
	        this._documentElement = undefined;
	        this._cssRuleDictionary = {};
	        this._elementDictionary = {};
	        if (this.element)
	            this.element.innerHTML = this.createElementInnerHTML();
	    }
	    updateRects() {
	        const syntheticDOMNodesByUID = {};
	        const rects = {};
	        const styles = {};
	        for (let uid in this._elementDictionary) {
	            const [native, synthetic] = this._elementDictionary[uid] || [undefined, undefined];
	            const syntheticNode = synthetic;
	            if (syntheticNode && syntheticNode.nodeType === dom_2.DOMNodeType.ELEMENT) {
	                const rect = common_1.BoundingRect.fromClientRect(native.getBoundingClientRect());
	                if (rect.width || rect.height || rect.left || rect.top) {
	                    rects[uid] = rect;
	                }
	                const nativeStyle = this._getComputedStyle(native);
	                // just attach whatever's returned by the DOM -- don't wrap this in a synthetic, or else
	                // there'll be massive performance penalties.
	                styles[uid] = nativeStyle;
	                syntheticNode.attachNative(native);
	            }
	        }
	        this.setRects(rects, styles);
	    }
	}
	exports.SyntheticDOMRenderer = SyntheticDOMRenderer;
	function renderHTMLNode(nodeFactory, syntheticNode, dict) {
	    switch (syntheticNode.nodeType) {
	        case dom_2.DOMNodeType.TEXT:
	            const textNode = nodeFactory.createTextNode(ent_1.decode(String(syntheticNode.textContent)));
	            dict[syntheticNode.uid] = [textNode, syntheticNode];
	            return textNode;
	        case dom_2.DOMNodeType.COMMENT:
	            const comment = nodeFactory.createComment(syntheticNode.nodeValue);
	            return comment;
	        case dom_2.DOMNodeType.ELEMENT:
	            const syntheticElement = syntheticNode;
	            // add a placeholder for these blacklisted elements so that diffing & patching work properly
	            if (/^(style|link|script)$/.test(syntheticElement.nodeName))
	                return nodeFactory.createTextNode("");
	            const element = renderHTMLElement(nodeFactory, syntheticElement.nodeName, syntheticElement, dict);
	            for (let i = 0, n = syntheticElement.attributes.length; i < n; i++) {
	                const syntheticAttribute = syntheticElement.attributes[i];
	                if (syntheticAttribute.name === "class") {
	                    element.className = syntheticAttribute.value;
	                }
	                else {
	                    element.setAttribute(syntheticAttribute.name, syntheticAttribute.value);
	                }
	            }
	            return appendChildNodes(nodeFactory, element, syntheticElement.childNodes, dict);
	        case dom_2.DOMNodeType.DOCUMENT:
	        case dom_2.DOMNodeType.DOCUMENT_FRAGMENT:
	            const syntheticContainer = syntheticNode;
	            const containerElement = renderHTMLElement(nodeFactory, "span", syntheticContainer, dict);
	            return appendChildNodes(nodeFactory, containerElement, syntheticContainer.childNodes, dict);
	    }
	}
	function renderHTMLElement(nodeFactory, tagName, source, dict) {
	    if (/html|body|head/.test(tagName))
	        tagName = "div";
	    const element = nodeFactory.createElementNS(source.namespaceURI === dom_1.SVG_XMLNS ? dom_1.SVG_XMLNS : dom_1.HTML_XMLNS, tagName);
	    dict[source.uid] = [element, source];
	    return element;
	}
	function appendChildNodes(nodeFactory, container, syntheticChildNodes, dict) {
	    for (let i = 0, n = syntheticChildNodes.length; i < n; i++) {
	        const childNode = renderHTMLNode(nodeFactory, syntheticChildNodes[i], dict);
	        // ignored
	        if (childNode == null)
	            continue;
	        container.appendChild(childNode);
	    }
	    return container;
	}


/***/ },
/* 222 */
/***/ function(module, exports) {

	module.exports = require("ent");

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(224));
	__export(__webpack_require__(230));
	__export(__webpack_require__(231));
	__export(__webpack_require__(258));
	__export(__webpack_require__(256));
	__export(__webpack_require__(225));
	__export(__webpack_require__(236));
	__export(__webpack_require__(285));


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const decorators_1 = __webpack_require__(69);
	const constants_1 = __webpack_require__(225);
	const location_1 = __webpack_require__(228);
	const document_1 = __webpack_require__(230);
	const common_1 = __webpack_require__(46);
	const html_1 = __webpack_require__(256);
	const local_storage_1 = __webpack_require__(280);
	const markup_1 = __webpack_require__(231);
	const timers_1 = __webpack_require__(281);
	const mesh_1 = __webpack_require__(13);
	const css_1 = __webpack_require__(258);
	const blob_1 = __webpack_require__(282);
	const url_1 = __webpack_require__(283);
	const abab_1 = __webpack_require__(272);
	const utils_1 = __webpack_require__(284);
	const xhr_1 = __webpack_require__(285);
	const events_1 = __webpack_require__(288);
	class SyntheticNavigator {
	    constructor() {
	        this.appCodeName = "Tandem";
	        this.platform = "synthetic";
	        this.userAgent = "none";
	    }
	}
	exports.SyntheticNavigator = SyntheticNavigator;
	class SyntheticConsole {
	    constructor(_logger) {
	        this._logger = _logger;
	        // Ensure that when the logs get dispatched that they are displayed.
	        this._logger.filterable = false;
	    }
	    log(text, ...rest) {
	        this._logger.debug(text, ...rest);
	    }
	    info(text, ...rest) {
	        this._logger.info(text, ...rest);
	    }
	    warn(text, ...rest) {
	        this._logger.warn(text, ...rest);
	    }
	    error(text, ...rest) {
	        this._logger.error(text, ...rest);
	    }
	}
	exports.SyntheticConsole = SyntheticConsole;
	// TODO - register element types from injector
	class SyntheticDOMImplementation {
	    constructor(_window) {
	        this._window = _window;
	    }
	    hasFeature(value) {
	        return false;
	    }
	    createHTMLDocument(title) {
	        const document = new document_1.SyntheticDocument(constants_1.HTML_XMLNS, this);
	        document.registerElementNS(constants_1.HTML_XMLNS, "default", html_1.SyntheticHTMLElement);
	        const documentElement = document.createElement("html");
	        // head
	        documentElement.appendChild(document.createElement("head"));
	        // body
	        documentElement.appendChild(document.createElement("body"));
	        document.appendChild(documentElement);
	        return document;
	    }
	}
	exports.SyntheticDOMImplementation = SyntheticDOMImplementation;
	class SyntheticWindow extends common_1.Observable {
	    constructor(location, browser, document) {
	        super();
	        this.browser = browser;
	        this.navigator = new SyntheticNavigator();
	        this.Blob = blob_1.Blob;
	        this.URL = url_1.URL;
	        this.btoa = abab_1.btoa;
	        const injector = browser && browser.injector;
	        const bus = injector && common_1.PrivateBusProvider.getInstance(injector) || mesh_1.noopDispatcherInstance;
	        // in case proto gets set - don't want the original to get fudged
	        // but doesn't work -- element instanceof HTMLElement 
	        this.HTMLElement = html_1.SyntheticHTMLElement;
	        this.Element = markup_1.SyntheticDOMElement;
	        const xhrServer = this._server = new xhr_1.XHRServer(this);
	        if (injector)
	            injector.inject(xhrServer);
	        this.XMLHttpRequest = class extends xhr_1.SyntheticXMLHttpRequest {
	            constructor() {
	                super(xhrServer);
	            }
	        }
	        ;
	        this.self = this;
	        this._implementation = new SyntheticDOMImplementation(this);
	        this._eventListeners = new events_1.DOMEventDispatcherMap(this);
	        this.localStorage = new local_storage_1.SyntheticLocalStorage();
	        this.document = document || this._implementation.createHTMLDocument();
	        this.document.$window = this;
	        this.location = location || new location_1.SyntheticLocation("");
	        this.window = this;
	        this.console = new SyntheticConsole(new common_1.Logger(bus, "**VM** "));
	        const windowTimers = this._windowTimers = new timers_1.SyntheticWindowTimers();
	        this.setTimeout = windowTimers.setTimeout.bind(windowTimers);
	        this.setInterval = windowTimers.setInterval.bind(windowTimers);
	        this.setImmediate = windowTimers.setImmediate.bind(windowTimers);
	        this.clearTimeout = windowTimers.clearTimeout.bind(windowTimers);
	        this.clearInterval = windowTimers.clearInterval.bind(windowTimers);
	        this.clearImmediate = windowTimers.clearImmediate.bind(windowTimers);
	        utils_1.bindDOMNodeEventMethods(this);
	    }
	    get sandbox() {
	        return this.browser && this.browser.sandbox;
	    }
	    getComputedStyle() {
	        return new css_1.SyntheticCSSStyle();
	    }
	    addEventListener(type, listener) {
	        this._eventListeners.add(type, listener);
	    }
	    removeEventListener(type, listener) {
	        this._eventListeners.remove(type, listener);
	    }
	    get depth() {
	        let i = 0;
	        let c = this;
	        while (c) {
	            i++;
	            c = c.parent;
	        }
	        return i;
	    }
	    dispose() {
	        this._windowTimers.dispose();
	    }
	    get parent() {
	        return this.browser.parent && this.browser.parent.window && this.browser.parent.window;
	    }
	    // ugly method invoked by browser to fire load events
	    $doneLoading() {
	        // always comes before load event since DOM_CONTENT_LOADED assumes that assets
	        // such as stylesheets have not yet been loaded in
	        this.notify(new events_1.SyntheticDOMEvent(events_1.DOMEventTypes.DOM_CONTENT_LOADED));
	        // sandbox has already mapped & loaded external dependencies, so go ahead and fire
	        // the DOM events
	        this.notify(new events_1.SyntheticDOMEvent(events_1.DOMEventTypes.LOAD));
	    }
	}
	__decorate([
	    decorators_1.bindable()
	], SyntheticWindow.prototype, "location", void 0);
	__decorate([
	    decorators_1.bindable()
	], SyntheticWindow.prototype, "onload", void 0);
	exports.SyntheticWindow = SyntheticWindow;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	exports.HTML_XMLNS = "http://www.w3.org/1999/xhtml";
	exports.SVG_XMLNS = "http://www.w3.org/2000/svg";
	__export(__webpack_require__(226));
	__export(__webpack_require__(227));


/***/ },
/* 226 */
/***/ function(module, exports) {

	/*

	From http://www.w3schools.com/tags/

	execute the following script in console debugger if any elements change:

	JSON.stringify(
	  Array.prototype.filter.call(document.querySelectorAll('a'), function(element) {
	    return /^tag_/.test(element.getAttribute('href'));
	  }).map(function(element) {
	    return element.innerText.replace(/>|</g, '');
	  }).filter(function(tagName) { return /^\w+$/.test(tagName); })
	, null, 2);
	*/
	"use strict";
	exports.HTML_TAG_NAMES = [
	    "a",
	    "abbr",
	    "acronym",
	    "address",
	    "applet",
	    "area",
	    "article",
	    "aside",
	    "audio",
	    "b",
	    "base",
	    "basefont",
	    "bdi",
	    "bdo",
	    "big",
	    "blockquote",
	    "body",
	    "br",
	    "button",
	    "canvas",
	    "caption",
	    "center",
	    "cite",
	    "code",
	    "col",
	    "colgroup",
	    "datalist",
	    "dd",
	    "del",
	    "details",
	    "dfn",
	    "dialog",
	    "dir",
	    "div",
	    "dl",
	    "dt",
	    "em",
	    "embed",
	    "fieldset",
	    "figcaption",
	    "figure",
	    "font",
	    "footer",
	    "form",
	    "frame",
	    "frameset",
	    "head",
	    "header",
	    "hr",
	    "html",
	    "i",
	    // "iframe",
	    "img",
	    "input",
	    "ins",
	    "kbd",
	    "keygen",
	    "label",
	    "legend",
	    "li",
	    "link",
	    "main",
	    "map",
	    "mark",
	    "menu",
	    "WebMenuItem",
	    "meta",
	    "meter",
	    "nav",
	    "noframes",
	    "noscript",
	    "object",
	    "ol",
	    "optgroup",
	    "option",
	    "output",
	    "p",
	    "param",
	    "pre",
	    "progress",
	    "q",
	    "rp",
	    "rt",
	    "ruby",
	    "s",
	    "samp",
	    "script",
	    "section",
	    "select",
	    "small",
	    "source",
	    "span",
	    "strike",
	    "strong",
	    "style",
	    "sub",
	    "summary",
	    "sup",
	    "table",
	    "tbody",
	    "td",
	    "textarea",
	    "tfoot",
	    "th",
	    "thead",
	    "time",
	    "title",
	    "tr",
	    "track",
	    "tt",
	    "u",
	    "ul",
	    "var",
	    "video",
	    "wbr",
	    "a",
	    "abbr",
	    "acronym",
	    "address",
	    "applet",
	    "area",
	    "article",
	    "aside",
	    "audio",
	    "b",
	    "base",
	    "basefont",
	    "bdi",
	    "bdo",
	    "big",
	    "blockquote",
	    "body",
	    "br",
	    "button",
	    "canvas",
	    "caption",
	    "center",
	    "cite",
	    "code",
	    "col",
	    "colgroup",
	    "datalist",
	    "dd",
	    "del",
	    "details",
	    "dfn",
	    "dialog",
	    "dir",
	    "div",
	    "dl",
	    "dt",
	    "em",
	    "embed",
	    "fieldset",
	    "figcaption",
	    "figure",
	    "font",
	    "footer",
	    "form",
	    "frame",
	    "frameset",
	    "head",
	    "header",
	    "hr",
	    "html",
	    "i",
	    "iframe",
	    "img",
	    "input",
	    "ins",
	    "kbd",
	    "keygen",
	    "label",
	    "legend",
	    "li",
	    "link",
	    "main",
	    "map",
	    "mark",
	    "menu",
	    "WebMenuItem",
	    "meta",
	    "meter",
	    "nav",
	    "noframes",
	    "noscript",
	    "object",
	    "ol",
	    "optgroup",
	    "option",
	    "output",
	    "p",
	    "param",
	    "pre",
	    "progress",
	    "q",
	    "rp",
	    "rt",
	    "ruby",
	    "s",
	    "samp",
	    "script",
	    "section",
	    "select",
	    "small",
	    "source",
	    "span",
	    "strike",
	    "strong",
	    "style",
	    "sub",
	    "summary",
	    "sup",
	    "table",
	    "tbody",
	    "td",
	    "textarea",
	    "tfoot",
	    "th",
	    "thead",
	    "time",
	    "title",
	    "tr",
	    "track",
	    "tt",
	    "u",
	    "ul",
	    "var",
	    "video",
	    "wbr"
	];
	exports.SVG_TAG_NAMES = [
	    "a",
	    "altGlyph",
	    "altGlyphDef",
	    "altGlyphItem",
	    "animate",
	    "animateColor",
	    "animateMotion",
	    "animateTransform",
	    "animation",
	    "audio",
	    "canvas",
	    "circle",
	    "clipPath",
	    "color-profile",
	    "cursor",
	    "defs",
	    "desc",
	    "discard",
	    "ellipse",
	    "feBlend",
	    "feColorMatrix",
	    "feComponentTransfer",
	    "feComposite",
	    "feConvolveMatrix",
	    "feDiffuseLighting",
	    "feDisplacementMap",
	    "feDistantLight",
	    "feDropShadow",
	    "feFlood",
	    "feFuncA",
	    "feFuncB",
	    "feFuncG",
	    "feFuncR",
	    "feGaussianBlur",
	    "feImage",
	    "feMerge",
	    "feMergeNode",
	    "feMorphology",
	    "feOffset",
	    "fePointLight",
	    "feSpecularLighting",
	    "feSpotLight",
	    "feTile",
	    "feTurbulence",
	    "filter",
	    "font",
	    "font-face",
	    "font-face-format",
	    "font-face-name",
	    "font-face-src",
	    "font-face-uri",
	    "foreignObject",
	    "g",
	    "glyph",
	    "glyphRef",
	    "handler",
	    "hatch",
	    "hatchpath",
	    "hkern",
	    "iframe",
	    "image",
	    "line",
	    "linearGradient",
	    "listener",
	    "marker",
	    "mask",
	    "mesh",
	    "meshpatch",
	    "meshrow",
	    "metadata",
	    "missing-glyph",
	    "mpath",
	    "path",
	    "pattern",
	    "polygon",
	    "polyline",
	    "prefetch",
	    "radialGradient",
	    "rect",
	    "script",
	    "set",
	    "solidColor",
	    "solidcolor",
	    "stop",
	    "style",
	    "svg",
	    "switch",
	    "symbol",
	    "tbreak",
	    "text",
	    "textArea",
	    "textPath",
	    "title",
	    "tref",
	    "tspan",
	    "unknown",
	    "use",
	    "video",
	    "view",
	    "vkern"
	];


/***/ },
/* 227 */
/***/ function(module, exports) {

	"use strict";
	exports.HTML_VOID_ELEMENTS = ["area",
	    "base",
	    "basefont",
	    "bgsound",
	    "br",
	    "col",
	    "command",
	    "embed",
	    "frame",
	    "hr",
	    "image",
	    "img",
	    "input",
	    "isindex",
	    "keygen",
	    "link",
	    "WebMenuItem",
	    "meta",
	    "nextid",
	    "param",
	    "source",
	    "track",
	    "wbr"
	];


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const observable_1 = __webpack_require__(91);
	const decorators_1 = __webpack_require__(69);
	const Url = __webpack_require__(229);
	class SyntheticLocation extends observable_1.Observable {
	    constructor(urlStr) {
	        super();
	        this.href = "";
	        this.hash = "";
	        this.search = "";
	        this.pathname = "";
	        this.port = "";
	        this.hostname = "";
	        this.protocol = "";
	        this.host = "";
	        const parts = Url.parse(urlStr);
	        for (const part in parts) {
	            const value = parts[part];
	            if (value)
	                this[part] = value;
	        }
	        ;
	    }
	    toString() {
	        return (this.protocol ? this.protocol + "//" : "") +
	            (this.host || "") +
	            this.pathname;
	    }
	}
	__decorate([
	    decorators_1.bindable()
	], SyntheticLocation.prototype, "href", void 0);
	__decorate([
	    decorators_1.bindable()
	], SyntheticLocation.prototype, "hash", void 0);
	__decorate([
	    decorators_1.bindable()
	], SyntheticLocation.prototype, "search", void 0);
	__decorate([
	    decorators_1.bindable()
	], SyntheticLocation.prototype, "pathname", void 0);
	__decorate([
	    decorators_1.bindable()
	], SyntheticLocation.prototype, "port", void 0);
	__decorate([
	    decorators_1.bindable()
	], SyntheticLocation.prototype, "hostname", void 0);
	__decorate([
	    decorators_1.bindable()
	], SyntheticLocation.prototype, "protocol", void 0);
	__decorate([
	    decorators_1.bindable()
	], SyntheticLocation.prototype, "host", void 0);
	exports.SyntheticLocation = SyntheticLocation;


/***/ },
/* 229 */
/***/ function(module, exports) {

	module.exports = require("url");

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const mesh_1 = __webpack_require__(13);
	const markup_1 = __webpack_require__(231);
	const common_1 = __webpack_require__(46);
	class SyntheticDocumentSerializer {
	    serialize(document) {
	        return {
	            // need to cast style sheet to vanilla array before mapping
	            styleSheets: [].concat(document.styleSheets).map(common_1.serialize),
	            defaultNamespaceURI: document.defaultNamespaceURI,
	            childNodes: document.childNodes.map(common_1.serialize),
	        };
	    }
	    deserialize(value, injector) {
	        const document = new SyntheticDocument(value.defaultNamespaceURI);
	        document.styleSheets.push(...value.styleSheets.map(raw => common_1.deserialize(raw, injector)));
	        for (let i = 0, n = value.childNodes.length; i < n; i++) {
	            document.appendChild(common_1.deserialize(value.childNodes[i], injector));
	        }
	        return document;
	    }
	}
	var SyntheticDocumentMutationTypes;
	(function (SyntheticDocumentMutationTypes) {
	    SyntheticDocumentMutationTypes.ADD_DOCUMENT_STYLE_SHEET_EDIT = "addDocumentStyleSheetEdit";
	    SyntheticDocumentMutationTypes.REMOVE_DOCUMENT_STYLE_SHEET_EDIT = "removeDocumentStyleSheetEdit";
	    SyntheticDocumentMutationTypes.MOVE_DOCUMENT_STYLE_SHEET_EDIT = "moveDocumentStyleSheetEdit";
	    ;
	})(SyntheticDocumentMutationTypes = exports.SyntheticDocumentMutationTypes || (exports.SyntheticDocumentMutationTypes = {}));
	// TODO - this shouldn't be here
	let SyntheticDocumentEdit = class SyntheticDocumentEdit extends markup_1.SyntheticDOMContainerEdit {
	    addStyleSheet(stylesheet) {
	        return this.addChange(new common_1.InsertChildMutation(SyntheticDocumentMutationTypes.ADD_DOCUMENT_STYLE_SHEET_EDIT, this.target, stylesheet));
	    }
	    removeStyleSheet(stylesheet) {
	        return this.addChange(new common_1.RemoveChildMutation(SyntheticDocumentMutationTypes.REMOVE_DOCUMENT_STYLE_SHEET_EDIT, this.target, stylesheet, this.target.styleSheets.indexOf(stylesheet)));
	    }
	    moveStyleSheet(stylesheet, index) {
	        return this.addChange(new common_1.MoveChildMutation(SyntheticDocumentMutationTypes.MOVE_DOCUMENT_STYLE_SHEET_EDIT, this.target, stylesheet, this.target.styleSheets.indexOf(stylesheet), index));
	    }
	    addDiff(newDocument) {
	        common_1.diffArray(this.target.styleSheets, newDocument.styleSheets, (oldStyleSheet, newStyleSheet) => {
	            if (oldStyleSheet.source && newStyleSheet.source) {
	                return oldStyleSheet.source.filePath === newStyleSheet.source.filePath ? 0 : -1;
	            }
	            // simple distance function
	            return Math.abs(oldStyleSheet.cssText.length - newStyleSheet.cssText.length);
	        }).accept({
	            visitInsert: ({ index, value }) => {
	                this.addStyleSheet(value);
	            },
	            visitRemove: ({ index }) => {
	                // console.log(this.target.styleSheets.map(ss => ss.cssText));
	                // console.log("REMOVING", index, this.target.styleSheets[index].cssText);
	                this.removeStyleSheet(this.target.styleSheets[index]);
	            },
	            visitUpdate: ({ originalOldIndex, patchedOldIndex, newValue, index }) => {
	                if (patchedOldIndex !== index) {
	                    this.moveStyleSheet(this.target.styleSheets[originalOldIndex], index);
	                }
	                this.addChildEdit(this.target.styleSheets[originalOldIndex].createEdit().fromDiff(newValue));
	            }
	        });
	        return super.addDiff(newDocument);
	    }
	};
	SyntheticDocumentEdit = __decorate([
	    common_1.serializable({
	        serialize({ mutations }) {
	            return {
	                mutations: mutations.map(common_1.serialize)
	            };
	        },
	        deserialize({ mutations }, injector, ctor) {
	            const edit = new ctor();
	            edit.mutations.push(...mutations.map(mutation => common_1.deserialize(mutation, injector)));
	            return edit;
	        }
	    })
	], SyntheticDocumentEdit);
	exports.SyntheticDocumentEdit = SyntheticDocumentEdit;
	class SyntheticDocumentEditor extends markup_1.SyntheticDOMContainerEditor {
	    applySingleMutation(mutation) {
	        super.applySingleMutation(mutation);
	        const target = this.target;
	        if (mutation.type === SyntheticDocumentMutationTypes.REMOVE_DOCUMENT_STYLE_SHEET_EDIT) {
	            target.styleSheets.splice(mutation.index, 1);
	        }
	        else if (mutation.type === SyntheticDocumentMutationTypes.ADD_DOCUMENT_STYLE_SHEET_EDIT) {
	            target.styleSheets.splice(mutation.index, 0, mutation.child.clone(true));
	        }
	        else if (mutation.type === SyntheticDocumentMutationTypes.MOVE_DOCUMENT_STYLE_SHEET_EDIT) {
	            const oldIndex = mutation.oldIndex;
	            target.styleSheets.splice(oldIndex, 1);
	            target.styleSheets.splice(mutation.index, 0);
	        }
	    }
	}
	exports.SyntheticDocumentEditor = SyntheticDocumentEditor;
	function isDOMDocumentMutation(mutation) {
	    return !!{
	        [SyntheticDocumentMutationTypes.REMOVE_DOCUMENT_STYLE_SHEET_EDIT]: true,
	        [SyntheticDocumentMutationTypes.ADD_DOCUMENT_STYLE_SHEET_EDIT]: true,
	        [SyntheticDocumentMutationTypes.MOVE_DOCUMENT_STYLE_SHEET_EDIT]: true
	    }[mutation.type];
	}
	exports.isDOMDocumentMutation = isDOMDocumentMutation;
	let SyntheticDocument_1 = class SyntheticDocument extends markup_1.SyntheticDOMContainer {
	    // namespaceURI here is non-standard, but that's
	    constructor(defaultNamespaceURI, implementation) {
	        super("#document");
	        this.defaultNamespaceURI = defaultNamespaceURI;
	        this.nodeType = markup_1.DOMNodeType.DOCUMENT;
	        this.$implementation = implementation;
	        this.styleSheets = new common_1.ObservableCollection();
	        this.styleSheets.observe(new mesh_1.CallbackDispatcher(this.onStyleSheetsEvent.bind(this)));
	        this.$registeredElements = {};
	    }
	    get implementation() {
	        return this.$implementation;
	    }
	    get sandbox() {
	        return this.defaultView.sandbox;
	    }
	    get scripts() {
	        return this.getElementsByTagName("script");
	    }
	    get browser() {
	        return this.$window.browser;
	    }
	    get ownerNode() {
	        return this.$ownerNode;
	    }
	    get defaultView() {
	        return this.$window;
	    }
	    get documentElement() {
	        return this.childNodes[0];
	    }
	    get head() {
	        return this.documentElement.childNodes[0];
	    }
	    get body() {
	        return this.documentElement.childNodes[1];
	    }
	    get location() {
	        return this.$window.location;
	    }
	    set location(value) {
	        this.$window.location = value;
	    }
	    open() {
	    }
	    close() {
	    }
	    accept(visitor) {
	        return visitor.visitDocument(this);
	    }
	    getElementById(id) {
	        return this.querySelector("#" + id);
	    }
	    createElementNS(ns, tagName) {
	        const nsElements = this.$registeredElements[ns] || {};
	        const elementClass = this.$getElementClassNS(ns, tagName);
	        const element = this.own(new elementClass(ns, tagName));
	        element.$createdCallback();
	        return element;
	    }
	    $getElementClassNS(ns, tagName) {
	        const nsElements = this.$registeredElements[ns] || {};
	        const elementClass = nsElements[tagName.toLowerCase()] || nsElements.default || markup_1.SyntheticDOMElement;
	        return elementClass;
	    }
	    createEdit() {
	        return new SyntheticDocumentEdit(this);
	    }
	    createElement(tagName) {
	        return this.own(this.createElementNS(this.defaultNamespaceURI, tagName));
	    }
	    registerElement(tagName, options) {
	        return this.registerElementNS(this.defaultNamespaceURI, tagName, options);
	    }
	    registerElementNS(ns, tagName, ctor) {
	        if (!this.$registeredElements[ns]) {
	            this.$registeredElements[ns] = {};
	        }
	        return this.$registeredElements[ns][tagName.toLowerCase()] = ctor;
	    }
	    createComment(nodeValue) {
	        return this.own(new markup_1.SyntheticDOMComment(nodeValue));
	    }
	    createTextNode(nodeValue) {
	        return this.own(new markup_1.SyntheticDOMText(nodeValue));
	    }
	    createDocumentFragment() {
	        return this.own(new markup_1.SyntheticDocumentFragment());
	    }
	    visitWalker(walker) {
	        this.styleSheets.forEach(styleSheet => walker.accept(styleSheet));
	        super.visitWalker(walker);
	    }
	    onChildAdded(child, index) {
	        super.onChildAdded(child, index);
	        child.$attach(this);
	    }
	    cloneShallow() {
	        return new SyntheticDocument_1(this.defaultNamespaceURI, this.implementation);
	    }
	    $linkClone(clone) {
	        clone.$window = this.defaultView;
	        clone.$implementation = clone.implementation;
	        return super.$linkClone(clone);
	    }
	    own(node) {
	        node.$setOwnerDocument(this);
	        return node;
	    }
	    createEditor() {
	        return new SyntheticDocumentEditor(this);
	    }
	    write(content) {
	        throw new Error(`document.write is not currently supported`);
	    }
	    onStyleSheetsEvent({ mutation }) {
	        if (!mutation)
	            return;
	        if (mutation.type === common_1.ArrayMutation.ARRAY_DIFF) {
	            mutation.accept({
	                visitUpdate: ({ newValue, index, patchedOldIndex }) => {
	                    if (index !== patchedOldIndex) {
	                        this.notify(new common_1.MoveChildMutation(SyntheticDocumentMutationTypes.MOVE_DOCUMENT_STYLE_SHEET_EDIT, this, newValue, patchedOldIndex, index).toEvent());
	                    }
	                },
	                visitInsert: ({ value, index }) => {
	                    if (!value.$ownerNode) {
	                        value.$ownerNode = this;
	                    }
	                    this.notify(new common_1.RemoveChildMutation(SyntheticDocumentMutationTypes.ADD_DOCUMENT_STYLE_SHEET_EDIT, this, value, index).toEvent());
	                },
	                visitRemove: ({ value, index }) => {
	                    value.$ownerNode = undefined;
	                    this.notify(new common_1.RemoveChildMutation(SyntheticDocumentMutationTypes.REMOVE_DOCUMENT_STYLE_SHEET_EDIT, this, value, index).toEvent());
	                }
	            });
	        }
	    }
	};
	let SyntheticDocument = SyntheticDocument_1;
	SyntheticDocument = SyntheticDocument_1 = __decorate([
	    common_1.serializable(new markup_1.SyntheticDOMNodeSerializer(new SyntheticDocumentSerializer()))
	], SyntheticDocument);
	exports.SyntheticDocument = SyntheticDocument;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(232));
	__export(__webpack_require__(242));
	__export(__webpack_require__(244));
	__export(__webpack_require__(246));
	__export(__webpack_require__(243));
	__export(__webpack_require__(234));
	__export(__webpack_require__(233));
	__export(__webpack_require__(247));
	__export(__webpack_require__(248));
	__export(__webpack_require__(249));
	__export(__webpack_require__(252));
	__export(__webpack_require__(251));
	__export(__webpack_require__(253));
	__export(__webpack_require__(245));
	__export(__webpack_require__(254));
	__export(__webpack_require__(255));


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const node_types_1 = __webpack_require__(233);
	const node_1 = __webpack_require__(234);
	const common_1 = __webpack_require__(46);
	const collections_1 = __webpack_require__(235);
	const selector_1 = __webpack_require__(236);
	const sandbox_1 = __webpack_require__(167);
	var SyntheticDOMContainerMutationTypes;
	(function (SyntheticDOMContainerMutationTypes) {
	    SyntheticDOMContainerMutationTypes.INSERT_CHILD_NODE_EDIT = common_1.TreeNodeMutationTypes.NODE_ADDED;
	    SyntheticDOMContainerMutationTypes.REMOVE_CHILD_NODE_EDIT = common_1.TreeNodeMutationTypes.NODE_REMOVED;
	    SyntheticDOMContainerMutationTypes.MOVE_CHILD_NODE_EDIT = "moveChildNodeEdit";
	})(SyntheticDOMContainerMutationTypes = exports.SyntheticDOMContainerMutationTypes || (exports.SyntheticDOMContainerMutationTypes = {}));
	function isDOMContainerMutation(mutation) {
	    return !!{
	        [SyntheticDOMContainerMutationTypes.MOVE_CHILD_NODE_EDIT]: true,
	        [SyntheticDOMContainerMutationTypes.INSERT_CHILD_NODE_EDIT]: true,
	        [SyntheticDOMContainerMutationTypes.REMOVE_CHILD_NODE_EDIT]: true
	    }[mutation.type];
	}
	exports.isDOMContainerMutation = isDOMContainerMutation;
	class SyntheticDOMContainerEdit extends node_1.SyntheticDOMNodeEdit {
	    insertChild(newChild, index) {
	        // Clone child here to freeze it from any changes. It WILL be cloned again, but that's also important to ensure
	        // that this edit can be applied to multiple targets.
	        return this.addChange(new common_1.InsertChildMutation(SyntheticDOMContainerMutationTypes.INSERT_CHILD_NODE_EDIT, this.target, newChild.cloneNode(true), index));
	    }
	    removeChild(child) {
	        return this.addChange(new common_1.RemoveChildMutation(SyntheticDOMContainerMutationTypes.REMOVE_CHILD_NODE_EDIT, this.target, child, this.target.childNodes.indexOf(child)));
	    }
	    moveChild(child, index, patchedOldIndex) {
	        return this.addChange(new common_1.MoveChildMutation(SyntheticDOMContainerMutationTypes.MOVE_CHILD_NODE_EDIT, this.target, child, patchedOldIndex || this.target.childNodes.indexOf(child), index));
	    }
	    appendChild(newChild) {
	        return this.insertChild(newChild, Number.MAX_SAFE_INTEGER);
	    }
	    remove() {
	        return this.addChange(new common_1.RemoveMutation(this.target));
	    }
	    addDiff(newContainer) {
	        common_1.diffArray(this.target.childNodes, newContainer.childNodes, (oldNode, newNode) => {
	            if (oldNode.nodeName !== newNode.nodeName || oldNode.namespaceURI !== newNode.namespaceURI)
	                return -1;
	            return 0;
	        }).accept({
	            visitInsert: ({ index, value }) => {
	                this.insertChild(value, index);
	            },
	            visitRemove: ({ index }) => {
	                this.removeChild(this.target.childNodes[index]);
	            },
	            visitUpdate: ({ originalOldIndex, patchedOldIndex, newValue, index }) => {
	                if (patchedOldIndex !== index) {
	                    this.moveChild(this.target.childNodes[originalOldIndex], index, patchedOldIndex);
	                }
	                const oldValue = this.target.childNodes[originalOldIndex];
	                this.addChildEdit(oldValue.createEdit().fromDiff(newValue));
	            }
	        });
	        return super.addDiff(newContainer);
	    }
	}
	exports.SyntheticDOMContainerEdit = SyntheticDOMContainerEdit;
	class DOMContainerEditor extends sandbox_1.BaseEditor {
	    constructor(target, createNode = (source) => source.cloneNode(true)) {
	        super(target);
	        this.target = target;
	        this.createNode = createNode;
	    }
	    applySingleMutation(mutation) {
	        if (mutation.type === SyntheticDOMContainerMutationTypes.REMOVE_CHILD_NODE_EDIT) {
	            const { child, index } = mutation;
	            this.target.removeChild(this.target.childNodes[index]);
	        }
	        if (mutation.type === SyntheticDOMContainerMutationTypes.MOVE_CHILD_NODE_EDIT) {
	            const moveMutation = mutation;
	            this._insertChildAt(this.target.childNodes[moveMutation.oldIndex], moveMutation.index);
	        }
	        else if (mutation.type === SyntheticDOMContainerMutationTypes.INSERT_CHILD_NODE_EDIT) {
	            const insertMutation = mutation;
	            const newChild = this.createNode(insertMutation.child);
	            this._insertChildAt(newChild, insertMutation.index);
	        }
	    }
	    _insertChildAt(child, index) {
	        if (child.parentNode) {
	            child.parentNode.removeChild(child);
	        }
	        if (index === this.target.childNodes.length) {
	            this.target.appendChild(child);
	        }
	        else {
	            const existingChild = this.target.childNodes[index];
	            this.target.insertBefore(child, existingChild);
	        }
	    }
	}
	exports.DOMContainerEditor = DOMContainerEditor;
	class SyntheticDOMContainerEditor extends sandbox_1.BaseEditor {
	    constructor(target) {
	        super(target);
	        this._domContainerEditor = this.createDOMEditor(target);
	        this._nodeEditor = new node_1.SyntheticDOMNodeEditor(target);
	    }
	    createDOMEditor(target) {
	        return new DOMContainerEditor(target);
	    }
	    applyMutations(mutations) {
	        super.applyMutations(mutations);
	        this._domContainerEditor.applyMutations(mutations);
	        this._nodeEditor.applyMutations(mutations);
	    }
	}
	exports.SyntheticDOMContainerEditor = SyntheticDOMContainerEditor;
	class SyntheticDOMContainer extends node_1.SyntheticDOMNode {
	    createEdit() {
	        return new SyntheticDOMContainerEdit(this);
	    }
	    getChildSyntheticByUID(uid) {
	        return common_1.findTreeNode(this, child => child.uid === uid);
	    }
	    // TODO - insertBefore here
	    appendChild(child) {
	        if (child.nodeType === node_types_1.DOMNodeType.DOCUMENT_FRAGMENT) {
	            child.children.concat().forEach((child) => this.appendChild(child));
	            return child;
	        }
	        return super.appendChild(child);
	    }
	    get textContent() {
	        return this.childNodes.map(child => child.textContent).join("");
	    }
	    set textContent(value) {
	        this.removeAllChildren();
	        this.appendChild(this.ownerDocument.createTextNode(value));
	    }
	    toString() {
	        return this.childNodes.map(child => child.toString()).join("");
	    }
	    querySelector(selector) {
	        return selector_1.querySelector(this, selector);
	    }
	    querySelectorAll(selector) {
	        return selector_1.querySelectorAll(this, selector);
	    }
	    getElementsByTagName(selector) {
	        return new collections_1.SyntheticHTMLCollection(...this.querySelectorAll(selector));
	    }
	    getElementsByClassName(className) {
	        return new collections_1.SyntheticHTMLCollection(...this.querySelectorAll("." + className));
	    }
	    createEditor() {
	        return new SyntheticDOMContainerEditor(this);
	    }
	    visitWalker(walker) {
	        this.childNodes.forEach(child => walker.accept(child));
	    }
	}
	exports.SyntheticDOMContainer = SyntheticDOMContainer;
	function isShadowRootOrDocument(node) {
	    return (node.nodeType === node_types_1.DOMNodeType.DOCUMENT_FRAGMENT || node.nodeType === node_types_1.DOMNodeType.DOCUMENT);
	}


/***/ },
/* 233 */
/***/ function(module, exports) {

	"use strict";
	(function (DOMNodeType) {
	    DOMNodeType[DOMNodeType["ELEMENT"] = 1] = "ELEMENT";
	    DOMNodeType[DOMNodeType["TEXT"] = 3] = "TEXT";
	    DOMNodeType[DOMNodeType["COMMENT"] = 8] = "COMMENT";
	    DOMNodeType[DOMNodeType["DOCUMENT"] = 9] = "DOCUMENT";
	    DOMNodeType[DOMNodeType["DOCUMENT_FRAGMENT"] = 11] = "DOCUMENT_FRAGMENT";
	})(exports.DOMNodeType || (exports.DOMNodeType = {}));
	var DOMNodeType = exports.DOMNodeType;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const node_types_1 = __webpack_require__(233);
	const sandbox_1 = __webpack_require__(167);
	const common_1 = __webpack_require__(46);
	exports.SyntheticDOMNodeSerializer = sandbox_1.SyntheticObjectSerializer;
	class SyntheticDOMNodeEdit extends sandbox_1.SyntheticObjectEdit {
	}
	exports.SyntheticDOMNodeEdit = SyntheticDOMNodeEdit;
	class SyntheticDOMNodeEditor extends sandbox_1.SyntheticObjectEditor {
	}
	exports.SyntheticDOMNodeEditor = SyntheticDOMNodeEditor;
	// TODO - possibly have metadata here since it's generic and can be used with any synthetic
	class SyntheticDOMNode extends common_1.TreeNode {
	    constructor(nodeName) {
	        super();
	        this.nodeName = nodeName;
	        this.$uid = sandbox_1.generateSyntheticUID();
	        this.metadata = new common_1.Metadata(this.getInitialMetadata());
	        this.metadata.observe(new common_1.BubbleDispatcher(this));
	    }
	    get uid() {
	        return this.$uid;
	    }
	    get ownerDocument() {
	        return this._ownerDocument;
	    }
	    get source() {
	        return this.$source;
	    }
	    get browser() {
	        return this.ownerDocument.defaultView.browser;
	    }
	    get module() {
	        return this.$module;
	    }
	    get childNodes() {
	        return this.children;
	    }
	    get parentElement() {
	        const parent = this.parentNode;
	        if (!parent || parent.nodeType !== node_types_1.DOMNodeType.ELEMENT) {
	            // NULL is standard here, otherwise undefined would be a better option.
	            return null;
	        }
	        return parent;
	    }
	    get parentNode() {
	        return this.parent;
	    }
	    addEventListener(type) {
	        // TODO
	    }
	    contains(node) {
	        return !!common_1.findTreeNode(this, child => child === node);
	    }
	    /**
	     * TODO - change this method name to something such as computeDifference
	     *
	     * @param {SyntheticDOMNode<any>} source
	     * @returns
	     */
	    compare(source) {
	        return Number(source.constructor === this.constructor && this.nodeName === source.nodeName);
	    }
	    removeEventListener() {
	        // TODO
	    }
	    isEqualNode(node) {
	        return !!this.compare(node);
	    }
	    getInitialMetadata() {
	        return {};
	    }
	    isSameNode(node) {
	        return this === node;
	    }
	    /**
	     * Attaches a native DOM node. TODO - possibly
	     * change this to addProduct since the renderer can attach anything
	     * that it wants -- even non-native elements that share an identical
	     * API.
	     *
	     * @param {Node} node
	     */
	    attachNative(node) {
	        this._native = node;
	    }
	    get mountedToNative() {
	        return this._native;
	    }
	    hasChildNodes() {
	        return this.childNodes.length !== 0;
	    }
	    onChildAdded(child, index) {
	        super.onChildAdded(child, index);
	        if (this.ownerDocument) {
	            child.$setOwnerDocument(this.ownerDocument);
	            if (this._attached) {
	                child.$attach(this.ownerDocument);
	            }
	            else if (child._attached) {
	                child.$detach();
	            }
	        }
	    }
	    onChildRemoved(child, index) {
	        super.onChildRemoved(child, index);
	        if (this._attached) {
	            child.$detach();
	        }
	    }
	    $setOwnerDocument(document) {
	        this._ownerDocument = document;
	        for (let i = 0, n = this.childNodes.length; i < n; i++) {
	            this.childNodes[i].$setOwnerDocument(document);
	        }
	    }
	    $createdCallback() {
	        if (this._createdCallbackCalled) {
	            throw new Error(`createdCallback() has already been called.`);
	        }
	        this._createdCallbackCalled = true;
	        this.createdCallback();
	        if (this._attachedBeforeCreatedCallback) {
	            this.$attachedCallback();
	        }
	    }
	    createdCallback() {
	    }
	    $attach(document) {
	        if (this._attached && this._ownerDocument === document) {
	            return console.warn("Trying to attach an already attached node");
	        }
	        this._attached = true;
	        this._ownerDocument = document;
	        this.$attachedCallback();
	        for (let i = 0, n = this.childNodes.length; i < n; i++) {
	            this.childNodes[i].$attach(document);
	        }
	    }
	    $attachedCallback() {
	        // this will happen during the loading phase of the document
	        if (!this._createdCallbackCalled) {
	            this._attachedBeforeCreatedCallback = true;
	            return;
	        }
	        this.attachedCallback();
	    }
	    $detach() {
	        if (!this._attached)
	            return;
	        this._attached = false;
	        this.detachedCallback();
	        for (let i = 0, n = this.childNodes.length; i < n; i++) {
	            this.childNodes[i].$detach();
	        }
	    }
	    $linkClone(clone) {
	        clone.$source = this.$source;
	        clone.$module = this.$module;
	        clone.$uid = this.uid;
	        clone.$setOwnerDocument(this.ownerDocument);
	        return clone;
	    }
	    attachedCallback() { }
	    detachedCallback() { }
	    /**
	     * Clone alias for standard DOM API. Note that there's a slight difference
	     * with how these work -- cloneNode for the DOM calls createdCallback on elements. Whereas
	     * cloneNode in this context doesn't. Instead cloneNode here serializes & deserializes the node -- reloading
	     * the exact state of the object
	     *
	     * @param {boolean} [deep]
	     * @returns
	     */
	    cloneNode(deep) {
	        return this.clone(deep);
	    }
	    clone(deep) {
	        if (deep)
	            return common_1.deserialize(common_1.serialize(this), undefined);
	        return this.$linkClone(this.cloneShallow());
	    }
	    createEditor() {
	        return new SyntheticDOMNodeEditor(this);
	    }
	}
	exports.SyntheticDOMNode = SyntheticDOMNode;


/***/ },
/* 235 */
/***/ function(module, exports) {

	"use strict";
	// https://developer.mozilla.org/en-US/docs/Web/API/HTMLCollection
	class SyntheticHTMLCollection extends Array {
	    constructor(...nodes) {
	        super(...nodes);
	    }
	    item(index) {
	        return this[index];
	    }
	}
	exports.SyntheticHTMLCollection = SyntheticHTMLCollection;


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(237));
	__export(__webpack_require__(239));
	__export(__webpack_require__(238));


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const lodash_1 = __webpack_require__(56);
	const tester_1 = __webpack_require__(238);
	const markup_1 = __webpack_require__(231);
	const common_1 = __webpack_require__(46);
	const mesh_1 = __webpack_require__(13);
	function isDocumentOrShadow(node) {
	    return node.nodeType === markup_1.DOMNodeType.DOCUMENT || node.nodeType === markup_1.DOMNodeType.DOCUMENT_FRAGMENT;
	}
	function createSyntheticDOMWalker(each, deep = true) {
	    const walker = {
	        stop() {
	            this._stopped = true;
	        },
	        accept(node) {
	            if (!this._stopped && (node.nodeType === markup_1.DOMNodeType.ELEMENT || (deep && isDocumentOrShadow(node)))) {
	                each(node, this);
	                if (!this._stopped) {
	                    node.visitWalker(this);
	                }
	            }
	        }
	    };
	    return walker;
	}
	exports.createSyntheticDOMWalker = createSyntheticDOMWalker;
	function querySelector(node, selectorSource) {
	    let found;
	    const tester = tester_1.getSelectorTester(selectorSource);
	    const walker = createSyntheticDOMWalker(node => {
	        if (tester.test(node)) {
	            found = node;
	            walker.stop();
	        }
	    });
	    walker.accept(node);
	    return found;
	}
	exports.querySelector = querySelector;
	function querySelectorAll(node, selectorSource) {
	    let found = [];
	    const tester = tester_1.getSelectorTester(selectorSource);
	    const walker = createSyntheticDOMWalker(node => {
	        if (tester.test(node)) {
	            found.push(node);
	        }
	    });
	    walker.accept(node);
	    return found;
	}
	exports.querySelectorAll = querySelectorAll;
	function selectorMatchesElement(selector, element) {
	    const tester = tester_1.getSelectorTester(selector);
	    return tester.test(element);
	}
	exports.selectorMatchesElement = selectorMatchesElement;
	const ELEMENT_QUERY_TIMEOUT = 10;
	/**
	 * Speedier version of querySelector with a few additional features
	 *
	 * @export
	 * @abstract
	 * @class BaseElementQuerier
	 * @extends {Observable}
	 * @implements {IElementQuerier<T>}
	 * @template T
	 */
	class BaseElementQuerier extends common_1.Observable {
	    constructor(target, selector, filter) {
	        super();
	        this.debounceReset = lodash_1.throttle(() => {
	            if (this._disposed)
	                return;
	            this.reset();
	        }, ELEMENT_QUERY_TIMEOUT);
	        this.target = target;
	        this.selector = selector;
	        this.filter = filter;
	        this._queriedElements = [];
	        this.targetWatcher = new common_1.PropertyWatcher(this, "target");
	        this.filterWatcher = new common_1.PropertyWatcher(this, "target");
	        this.selectorWatcher = new common_1.PropertyWatcher(this, "target");
	        this.queriedElementsWatcher = new common_1.PropertyWatcher(this, "queriedElements");
	        // all of this stuff may be set at the same time, so add a debounce. Besides, ElementQuerier
	        // is intended to be asyncronous
	        this.targetWatcher.connect(this.debounceReset);
	        this.filterWatcher.connect(this.debounceReset);
	        this.selectorWatcher.connect(this.debounceReset);
	        this.reset();
	    }
	    get queriedElements() {
	        return this._queriedElements;
	    }
	    setQueriedElements(newQueriedElements) {
	        const oldQueriedElements = this._queriedElements;
	        this.notify(new common_1.PropertyMutation(common_1.PropertyMutation.PROPERTY_CHANGE, this, "queriedElements", this._queriedElements = newQueriedElements, oldQueriedElements).toEvent());
	    }
	    dispose() {
	        this._disposed = true;
	        // this.watcher.dispose(); TODO
	    }
	}
	__decorate([
	    common_1.bindable()
	], BaseElementQuerier.prototype, "target", void 0);
	__decorate([
	    common_1.bindable()
	], BaseElementQuerier.prototype, "filter", void 0);
	__decorate([
	    common_1.bindable()
	], BaseElementQuerier.prototype, "selector", void 0);
	exports.BaseElementQuerier = BaseElementQuerier;
	class SyntheticElementQuerier extends BaseElementQuerier {
	    constructor(target, selector = "*", filter) {
	        super(target, selector, filter);
	        this._rootObserver = new mesh_1.CallbackDispatcher(this.onRootEvent.bind(this));
	    }
	    reset() {
	        this.cleanup();
	        if (!this.target)
	            return this.setQueriedElements([]);
	        this.target.observe(this._rootObserver);
	        const found = [];
	        const filter = this.filter || (() => true);
	        const tester = tester_1.getSelectorTester(this.selector);
	        let i = 0;
	        createSyntheticDOMWalker(node => {
	            i++;
	            if (tester.test(node) && filter(node))
	                found.push(node);
	        }).accept(this.target);
	        this.setQueriedElements(found);
	    }
	    createChildQuerier(selector = "*", filter) {
	        return new ChildElementQuerier(this, selector, filter);
	    }
	    onRootEvent(action) {
	        // reset on ALL actions -- there are cases where Nodes may contain state that
	        // parts of the app using this querier needs to access (metadata for example). Debounce so
	        // the app doesn't get clobbered with expensive querySelectorAll requests.
	        this.debounceReset();
	    }
	    dispose() {
	        super.dispose();
	        this.cleanup();
	    }
	    cleanup() {
	        if (this.target) {
	            this.target.unobserve(this._rootObserver);
	        }
	    }
	}
	exports.SyntheticElementQuerier = SyntheticElementQuerier;
	class ChildElementQuerier extends BaseElementQuerier {
	    constructor(parent, selector = "*", filter) {
	        super(parent && parent.target, selector, filter);
	        this.parentWatcher = new common_1.PropertyWatcher(this, "parent");
	        this.parentWatcher.connect((parent) => {
	            if (this._parentWatchers)
	                this._parentWatchers.dispose();
	            const { targetWatcher, queriedElementsWatcher } = parent;
	            parent.targetWatcher;
	            this._parentWatchers = new common_1.DisposableCollection(targetWatcher.connect(target => this.target = target).trigger(), queriedElementsWatcher.connect(this.reset.bind(this)));
	        });
	    }
	    reset() {
	        if (!this.parent)
	            return this.setQueriedElements([]);
	        const filter = this.filter || (() => true);
	        const tester = tester_1.getSelectorTester(this.selector);
	        this.setQueriedElements(this.parent.queriedElements.filter(element => tester.test(element) && filter(element)));
	    }
	    dispose() {
	        super.dispose();
	        if (this._parentWatchers)
	            this._parentWatchers.dispose();
	    }
	}
	__decorate([
	    common_1.bindable()
	], ChildElementQuerier.prototype, "parent", void 0);
	exports.ChildElementQuerier = ChildElementQuerier;


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const parser_1 = __webpack_require__(239);
	const common_1 = __webpack_require__(46);
	const markup_1 = __webpack_require__(231);
	const _testers = {};
	function getSelectorTester(selectorSource) {
	    if (_testers[selectorSource])
	        return _testers[selectorSource];
	    // check for all - short optimization to avoid AST traversing.
	    if (selectorSource === "*") {
	        return {
	            source: selectorSource,
	            test(node) {
	                return node && (node.nodeType === markup_1.DOMNodeType.ELEMENT);
	            }
	        };
	    }
	    // if selectorSource is undefined or false, then return a tester
	    // that also always returns
	    if (!selectorSource) {
	        return {
	            source: selectorSource,
	            test: () => false
	        };
	    }
	    const ast = parser_1.parseSelector(selectorSource);
	    function test(ast, node) {
	        if (!node || node.nodeType !== markup_1.DOMNodeType.ELEMENT)
	            return false;
	        return ast.accept({
	            visitClassNameSelector({ className }) {
	                return node.classList && node.classList.indexOf(className) !== -1;
	            },
	            visitIDSelector({ id }) {
	                return node.getAttribute("id") === id;
	            },
	            visitAllSelector(expression) {
	                return true;
	            },
	            visitTagNameSelector({ tagName }) {
	                return tagName.toLowerCase() === node.tagName.toLowerCase();
	            },
	            visitListSelector({ selectors }) {
	                return !!selectors.find((selector) => test(selector, node));
	            },
	            visitDescendentSelector({ targetSelector, ancestorSelector }) {
	                return test(targetSelector, node) && !!common_1.getTreeAncestors(node).find((ancestor) => test(ancestorSelector, ancestor));
	            },
	            visitChildSelector({ targetSelector, parentSelector }) {
	                return test(targetSelector, node) && node.parent && test(parentSelector, node.parent);
	            },
	            visitLiteral({ value }) {
	                return {
	                    "number": Number,
	                    "string": String,
	                    "boolean": Boolean,
	                    "object": Object
	                }[typeof value](value);
	            },
	            visitAdjacentSiblingSelector({ startSelector, targetSelector }) {
	                return test(targetSelector, node) && test(startSelector, node.previousSibling);
	            },
	            visitProceedingSiblingSelector({ startSelector, targetSelector }) {
	                return test(targetSelector, node) && common_1.getPreviousTreeSiblings(node).filter((previousSibling) => test(startSelector, previousSibling));
	            },
	            visitAttributeSelector({ name, operator, value }) {
	                if (!node.hasAttribute(name))
	                    return false;
	                const nodeValue = String(node.getAttribute(name));
	                switch (operator) {
	                    case "=": return value === nodeValue;
	                    case "~=": return nodeValue.indexOf(value) !== -1;
	                    case "^=": return nodeValue.indexOf(value) === 0;
	                    case "|=": return nodeValue.indexOf(value) === 0;
	                    case "$=": return nodeValue.indexOf(value) + value.length === nodeValue.length;
	                    case "*=": return nodeValue.indexOf(value) !== -1;
	                    default: return true;
	                }
	            },
	            visitPseudoClassSelector({ name, parameter }) {
	                if (name === "not") {
	                    return !test(parameter, node);
	                }
	                else if (name === "nth-child") {
	                    if (node.parentNode.childNodes.indexOf(node) === parameter.accept(this) - 1) {
	                        return true;
	                    }
	                }
	                else if (name === "nth-last-child") {
	                    if (node.parentNode.childNodes.indexOf(node) === node.parentNode.childNodes.length - parameter.accept(this)) {
	                        return true;
	                    }
	                }
	                return false;
	            },
	            visitPseudoElement({ name }) {
	                return true;
	            },
	            visitNestedSelector({ parent, child }) {
	                return test(parent, node) && test(child, node);
	            }
	        });
	    }
	    return _testers[selectorSource] = {
	        source: selectorSource,
	        test: test.bind(this, ast)
	    };
	}
	exports.getSelectorTester = getSelectorTester;


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const parser = __webpack_require__(240);
	const _cache = {};
	function parseSelector(selectorSource) {
	    return _cache[selectorSource] || (_cache[selectorSource] = parser.parse(selectorSource));
	}
	exports.parseSelector = parseSelector;


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = /*
	 * Generated by PEG.js 0.10.0.
	 *
	 * http://pegjs.org/
	 */
	(function() {
	  "use strict";

	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }

	  function peg$SyntaxError(message, expected, found, location) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.location = location;
	    this.name     = "SyntaxError";

	    if (typeof Error.captureStackTrace === "function") {
	      Error.captureStackTrace(this, peg$SyntaxError);
	    }
	  }

	  peg$subclass(peg$SyntaxError, Error);

	  peg$SyntaxError.buildMessage = function(expected, found) {
	    var DESCRIBE_EXPECTATION_FNS = {
	          literal: function(expectation) {
	            return "\"" + literalEscape(expectation.text) + "\"";
	          },

	          "class": function(expectation) {
	            var escapedParts = "",
	                i;

	            for (i = 0; i < expectation.parts.length; i++) {
	              escapedParts += expectation.parts[i] instanceof Array
	                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
	                : classEscape(expectation.parts[i]);
	            }

	            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
	          },

	          any: function(expectation) {
	            return "any character";
	          },

	          end: function(expectation) {
	            return "end of input";
	          },

	          other: function(expectation) {
	            return expectation.description;
	          }
	        };

	    function hex(ch) {
	      return ch.charCodeAt(0).toString(16).toUpperCase();
	    }

	    function literalEscape(s) {
	      return s
	        .replace(/\\/g, '\\\\')
	        .replace(/"/g,  '\\"')
	        .replace(/\0/g, '\\0')
	        .replace(/\t/g, '\\t')
	        .replace(/\n/g, '\\n')
	        .replace(/\r/g, '\\r')
	        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
	        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
	    }

	    function classEscape(s) {
	      return s
	        .replace(/\\/g, '\\\\')
	        .replace(/\]/g, '\\]')
	        .replace(/\^/g, '\\^')
	        .replace(/-/g,  '\\-')
	        .replace(/\0/g, '\\0')
	        .replace(/\t/g, '\\t')
	        .replace(/\n/g, '\\n')
	        .replace(/\r/g, '\\r')
	        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
	        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
	    }

	    function describeExpectation(expectation) {
	      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
	    }

	    function describeExpected(expected) {
	      var descriptions = new Array(expected.length),
	          i, j;

	      for (i = 0; i < expected.length; i++) {
	        descriptions[i] = describeExpectation(expected[i]);
	      }

	      descriptions.sort();

	      if (descriptions.length > 0) {
	        for (i = 1, j = 1; i < descriptions.length; i++) {
	          if (descriptions[i - 1] !== descriptions[i]) {
	            descriptions[j] = descriptions[i];
	            j++;
	          }
	        }
	        descriptions.length = j;
	      }

	      switch (descriptions.length) {
	        case 1:
	          return descriptions[0];

	        case 2:
	          return descriptions[0] + " or " + descriptions[1];

	        default:
	          return descriptions.slice(0, -1).join(", ")
	            + ", or "
	            + descriptions[descriptions.length - 1];
	      }
	    }

	    function describeFound(found) {
	      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
	    }

	    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
	  };

	  function peg$parse(input, options) {
	    options = options !== void 0 ? options : {};

	    var peg$FAILED = {},

	        peg$startRuleFunctions = { Start: peg$parseStart },
	        peg$startRuleFunction  = peg$parseStart,

	        peg$c0 = function(first, rest) {
	          return rest.length ? new ListSelectorExpression([first].concat(rest), location()) : first;
	        },
	        peg$c1 = ",",
	        peg$c2 = peg$literalExpectation(",", false),
	        peg$c3 = function(selector) { return selector },
	        peg$c4 = function(parent, child) {
	          return child ? new NestedSelectorExpression(parent, child) : parent;
	        },
	        peg$c5 = ".",
	        peg$c6 = peg$literalExpectation(".", false),
	        peg$c7 = function(className) {
	          return new ClassNameSelectorExpression(className, location());
	        },
	        peg$c8 = "#",
	        peg$c9 = peg$literalExpectation("#", false),
	        peg$c10 = function(id) {
	          return new IDSelectorExpression(id, location());
	        },
	        peg$c11 = function(tagName) {
	          return new TagNameSelectorExpression(tagName, location());
	        },
	        peg$c12 = "*",
	        peg$c13 = peg$literalExpectation("*", false),
	        peg$c14 = function() {
	          return new AllSelectorExpression(location());
	        },
	        peg$c15 = " ",
	        peg$c16 = peg$literalExpectation(" ", false),
	        peg$c17 = function(parent, descendent) {
	          return new DescendentSelectorExpression(parent, descendent, location());
	        },
	        peg$c18 = ">",
	        peg$c19 = peg$literalExpectation(">", false),
	        peg$c20 = function(parent, descendent) {
	          return new ChildSelectorExpression(parent, descendent, location());
	        },
	        peg$c21 = "+",
	        peg$c22 = peg$literalExpectation("+", false),
	        peg$c23 = function(parent, descendent) {
	          return new AdjacentSiblingSelectorExpression(parent, descendent, location());
	        },
	        peg$c24 = "~",
	        peg$c25 = peg$literalExpectation("~", false),
	        peg$c26 = function(parent, descendent) {
	          return new ProceedingSiblingSelectorExpression(parent, descendent, location());
	        },
	        peg$c27 = ":",
	        peg$c28 = peg$literalExpectation(":", false),
	        peg$c29 = function(name, parameter) {
	          return new PseudoClassSelectorExpression(name, parameter, location());
	        },
	        peg$c30 = function(name) {
	          return new PseudoElementExpression(name, null, location());
	        },
	        peg$c31 = "(",
	        peg$c32 = peg$literalExpectation("(", false),
	        peg$c33 = ")",
	        peg$c34 = peg$literalExpectation(")", false),
	        peg$c35 = function(parameter) {
	          return parameter;
	        },
	        peg$c36 = "::",
	        peg$c37 = peg$literalExpectation("::", false),
	        peg$c38 = function(name) { return name; },
	        peg$c39 = "before",
	        peg$c40 = peg$literalExpectation("before", false),
	        peg$c41 = "after",
	        peg$c42 = peg$literalExpectation("after", false),
	        peg$c43 = "first-line",
	        peg$c44 = peg$literalExpectation("first-line", false),
	        peg$c45 = "first-letter",
	        peg$c46 = peg$literalExpectation("first-letter", false),
	        peg$c47 = "selection",
	        peg$c48 = peg$literalExpectation("selection", false),
	        peg$c49 = "[",
	        peg$c50 = peg$literalExpectation("[", false),
	        peg$c51 = "]",
	        peg$c52 = peg$literalExpectation("]", false),
	        peg$c53 = function(selector) {
	          return selector;
	        },
	        peg$c54 = function(name) {
	          return new AttributeSelectorExpression(name, undefined, undefined, location());
	        },
	        peg$c55 = "=",
	        peg$c56 = peg$literalExpectation("=", false),
	        peg$c57 = "~=",
	        peg$c58 = peg$literalExpectation("~=", false),
	        peg$c59 = "|=",
	        peg$c60 = peg$literalExpectation("|=", false),
	        peg$c61 = "^=",
	        peg$c62 = peg$literalExpectation("^=", false),
	        peg$c63 = "$=",
	        peg$c64 = peg$literalExpectation("$=", false),
	        peg$c65 = "*=",
	        peg$c66 = peg$literalExpectation("*=", false),
	        peg$c67 = function(name, operator, value) {
	          return new AttributeSelectorExpression(name, operator, value, location());
	        },
	        peg$c68 = /^[a-zA-Z0-9_\-]/,
	        peg$c69 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "-"], false, false),
	        peg$c70 = function() { return text(); },
	        peg$c71 = /^[a-zA-Z0-9_$\-]/,
	        peg$c72 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", "$", "-"], false, false),
	        peg$c73 = function(value) {
	            return new SelectorLiteralExpression(value, location());
	          },
	        peg$c74 = "\"",
	        peg$c75 = peg$literalExpectation("\"", false),
	        peg$c76 = function(characters) { return characters.join(""); },
	        peg$c77 = "'",
	        peg$c78 = peg$literalExpectation("'", false),
	        peg$c79 = /^[0-9]/,
	        peg$c80 = peg$classExpectation([["0", "9"]], false, false),
	        peg$c81 = "\\",
	        peg$c82 = peg$literalExpectation("\\", false),
	        peg$c83 = peg$anyExpectation(),
	        peg$c84 = "\\\"",
	        peg$c85 = peg$literalExpectation("\\\"", false),
	        peg$c86 = "\\'",
	        peg$c87 = peg$literalExpectation("\\'", false),
	        peg$c88 = /^[ \n\r\t]/,
	        peg$c89 = peg$classExpectation([" ", "\n", "\r", "\t"], false, false),

	        peg$currPos          = 0,
	        peg$savedPos         = 0,
	        peg$posDetailsCache  = [{ line: 1, column: 1 }],
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$silentFails      = 0,

	        peg$result;

	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleFunctions)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }

	      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	    }

	    function text() {
	      return input.substring(peg$savedPos, peg$currPos);
	    }

	    function location() {
	      return peg$computeLocation(peg$savedPos, peg$currPos);
	    }

	    function expected(description, location) {
	      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

	      throw peg$buildStructuredError(
	        [peg$otherExpectation(description)],
	        input.substring(peg$savedPos, peg$currPos),
	        location
	      );
	    }

	    function error(message, location) {
	      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

	      throw peg$buildSimpleError(message, location);
	    }

	    function peg$literalExpectation(text, ignoreCase) {
	      return { type: "literal", text: text, ignoreCase: ignoreCase };
	    }

	    function peg$classExpectation(parts, inverted, ignoreCase) {
	      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
	    }

	    function peg$anyExpectation() {
	      return { type: "any" };
	    }

	    function peg$endExpectation() {
	      return { type: "end" };
	    }

	    function peg$otherExpectation(description) {
	      return { type: "other", description: description };
	    }

	    function peg$computePosDetails(pos) {
	      var details = peg$posDetailsCache[pos], p;

	      if (details) {
	        return details;
	      } else {
	        p = pos - 1;
	        while (!peg$posDetailsCache[p]) {
	          p--;
	        }

	        details = peg$posDetailsCache[p];
	        details = {
	          line:   details.line,
	          column: details.column
	        };

	        while (p < pos) {
	          if (input.charCodeAt(p) === 10) {
	            details.line++;
	            details.column = 1;
	          } else {
	            details.column++;
	          }

	          p++;
	        }

	        peg$posDetailsCache[pos] = details;
	        return details;
	      }
	    }

	    function peg$computeLocation(startPos, endPos) {
	      var startPosDetails = peg$computePosDetails(startPos),
	          endPosDetails   = peg$computePosDetails(endPos);

	      return {
	        start: {
	          offset: startPos,
	          line:   startPosDetails.line,
	          column: startPosDetails.column
	        },
	        end: {
	          offset: endPos,
	          line:   endPosDetails.line,
	          column: endPosDetails.column
	        }
	      };
	    }

	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }

	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }

	      peg$maxFailExpected.push(expected);
	    }

	    function peg$buildSimpleError(message, location) {
	      return new peg$SyntaxError(message, null, null, location);
	    }

	    function peg$buildStructuredError(expected, found, location) {
	      return new peg$SyntaxError(
	        peg$SyntaxError.buildMessage(expected, found),
	        expected,
	        found,
	        location
	      );
	    }

	    function peg$parseStart() {
	      var s0;

	      s0 = peg$parseListSelector();

	      return s0;
	    }

	    function peg$parseListSelector() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseCombinatorSelector();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parseListSelectorRest();
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$parseListSelectorRest();
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c0(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseListSelectorRest() {
	      var s0, s1, s2, s3, s4;

	      s0 = peg$currPos;
	      s1 = peg$parse_();
	      if (s1 !== peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 44) {
	          s2 = peg$c1;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c2); }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseCombinatorSelector();
	            if (s4 !== peg$FAILED) {
	              peg$savedPos = s0;
	              s1 = peg$c3(s4);
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseCombinatorSelector() {
	      var s0;

	      s0 = peg$parseDescendentSelector();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseChildSelector();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseAdjacentSiblingSelector();
	          if (s0 === peg$FAILED) {
	            s0 = peg$parseProceedingSiblingSelector();
	            if (s0 === peg$FAILED) {
	              s0 = peg$parseNestedSelector();
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseNestedSelector() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$parseAllSelector();
	      if (s1 === peg$FAILED) {
	        s1 = peg$parseElementSelector();
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseNestedSelector();
	        if (s2 === peg$FAILED) {
	          s2 = null;
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c4(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseElementSelector() {
	      var s0;

	      s0 = peg$parsePseudoElementSelector();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parsePseudoClassSelector();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseAttributeSelector();
	          if (s0 === peg$FAILED) {
	            s0 = peg$parseClassNameSelector();
	            if (s0 === peg$FAILED) {
	              s0 = peg$parseIDSelector();
	              if (s0 === peg$FAILED) {
	                s0 = peg$parseTagNameSelector();
	              }
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseClassNameSelector() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 46) {
	        s1 = peg$c5;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c6); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseWord();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c7(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseIDSelector() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c8;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c9); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseWord();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c10(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseTagNameSelector() {
	      var s0, s1;

	      s0 = peg$currPos;
	      s1 = peg$parseWord();
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c11(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseAllSelector() {
	      var s0, s1;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 42) {
	        s1 = peg$c12;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c13); }
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c14();
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseDescendentSelector() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseNestedSelector();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        if (input.charCodeAt(peg$currPos) === 32) {
	          s3 = peg$c15;
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c16); }
	        }
	        if (s3 !== peg$FAILED) {
	          while (s3 !== peg$FAILED) {
	            s2.push(s3);
	            if (input.charCodeAt(peg$currPos) === 32) {
	              s3 = peg$c15;
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c16); }
	            }
	          }
	        } else {
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseCombinatorSelector();
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c17(s1, s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseChildSelector() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      s1 = peg$parseNestedSelector();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 62) {
	            s3 = peg$c18;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c19); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseCombinatorSelector();
	              if (s5 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c20(s1, s5);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseAdjacentSiblingSelector() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      s1 = peg$parseNestedSelector();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 43) {
	            s3 = peg$c21;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c22); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseCombinatorSelector();
	              if (s5 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c23(s1, s5);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseProceedingSiblingSelector() {
	      var s0, s1, s2, s3, s4, s5;

	      s0 = peg$currPos;
	      s1 = peg$parseNestedSelector();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 126) {
	            s3 = peg$c24;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c25); }
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parseCombinatorSelector();
	              if (s5 !== peg$FAILED) {
	                peg$savedPos = s0;
	                s1 = peg$c26(s1, s5);
	                s0 = s1;
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parsePseudoClassSelector() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 58) {
	        s1 = peg$c27;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c28); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseWord();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseSelectorParameter();
	          if (s3 === peg$FAILED) {
	            s3 = null;
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c29(s2, s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parsePseudoElementSelector() {
	      var s0, s1;

	      s0 = peg$currPos;
	      s1 = peg$parsePseudoElementName();
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c30(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseSelectorParameter() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 40) {
	        s1 = peg$c31;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c32); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseLiteralExpression();
	        if (s2 === peg$FAILED) {
	          s2 = peg$parseCombinatorSelector();
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 41) {
	            s3 = peg$c33;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c34); }
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c35(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parsePseudoElementName() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c36) {
	        s1 = peg$c36;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c37); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseWord();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c38(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 58) {
	          s1 = peg$c27;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c28); }
	        }
	        if (s1 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 6) === peg$c39) {
	            s2 = peg$c39;
	            peg$currPos += 6;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c40); }
	          }
	          if (s2 === peg$FAILED) {
	            if (input.substr(peg$currPos, 5) === peg$c41) {
	              s2 = peg$c41;
	              peg$currPos += 5;
	            } else {
	              s2 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c42); }
	            }
	            if (s2 === peg$FAILED) {
	              if (input.substr(peg$currPos, 10) === peg$c43) {
	                s2 = peg$c43;
	                peg$currPos += 10;
	              } else {
	                s2 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c44); }
	              }
	              if (s2 === peg$FAILED) {
	                if (input.substr(peg$currPos, 12) === peg$c45) {
	                  s2 = peg$c45;
	                  peg$currPos += 12;
	                } else {
	                  s2 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c46); }
	                }
	                if (s2 === peg$FAILED) {
	                  if (input.substr(peg$currPos, 9) === peg$c47) {
	                    s2 = peg$c47;
	                    peg$currPos += 9;
	                  } else {
	                    s2 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c48); }
	                  }
	                }
	              }
	            }
	          }
	          if (s2 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c38(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }

	      return s0;
	    }

	    function peg$parseAttributeSelector() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 91) {
	        s1 = peg$c49;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c50); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseAttributeSelectorWithValue();
	        if (s2 === peg$FAILED) {
	          s2 = peg$parseAttributeSelectorWithoutValue();
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 93) {
	            s3 = peg$c51;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c52); }
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c53(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseAttributeSelectorWithoutValue() {
	      var s0, s1;

	      s0 = peg$currPos;
	      s1 = peg$parseAttributeName();
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c54(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseAttributeSelectorWithValue() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseAttributeName();
	      if (s1 !== peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 61) {
	          s2 = peg$c55;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c56); }
	        }
	        if (s2 === peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c57) {
	            s2 = peg$c57;
	            peg$currPos += 2;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c58); }
	          }
	          if (s2 === peg$FAILED) {
	            if (input.substr(peg$currPos, 2) === peg$c59) {
	              s2 = peg$c59;
	              peg$currPos += 2;
	            } else {
	              s2 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c60); }
	            }
	            if (s2 === peg$FAILED) {
	              if (input.substr(peg$currPos, 2) === peg$c61) {
	                s2 = peg$c61;
	                peg$currPos += 2;
	              } else {
	                s2 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c62); }
	              }
	              if (s2 === peg$FAILED) {
	                if (input.substr(peg$currPos, 2) === peg$c63) {
	                  s2 = peg$c63;
	                  peg$currPos += 2;
	                } else {
	                  s2 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c64); }
	                }
	                if (s2 === peg$FAILED) {
	                  if (input.substr(peg$currPos, 2) === peg$c65) {
	                    s2 = peg$c65;
	                    peg$currPos += 2;
	                  } else {
	                    s2 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c66); }
	                  }
	                }
	              }
	            }
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseWord();
	          if (s3 === peg$FAILED) {
	            s3 = peg$parseString();
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c67(s1, s2, s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseAttributeName() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      if (peg$c68.test(input.charAt(peg$currPos))) {
	        s2 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c69); }
	      }
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          if (peg$c68.test(input.charAt(peg$currPos))) {
	            s2 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c69); }
	          }
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c70();
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseWord() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      if (peg$c71.test(input.charAt(peg$currPos))) {
	        s2 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c72); }
	      }
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          if (peg$c71.test(input.charAt(peg$currPos))) {
	            s2 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c72); }
	          }
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c70();
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseLiteralExpression() {
	      var s0, s1;

	      s0 = peg$currPos;
	      s1 = peg$parseNumber();
	      if (s1 === peg$FAILED) {
	        s1 = peg$parseString();
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c73(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseString() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 34) {
	        s1 = peg$c74;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c75); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parseDoubleStringCharacter();
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$parseDoubleStringCharacter();
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 34) {
	            s3 = peg$c74;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c75); }
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c76(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 39) {
	          s1 = peg$c77;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c78); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = [];
	          s3 = peg$parseSingleStringCharacter();
	          while (s3 !== peg$FAILED) {
	            s2.push(s3);
	            s3 = peg$parseSingleStringCharacter();
	          }
	          if (s2 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 39) {
	              s3 = peg$c77;
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c78); }
	            }
	            if (s3 !== peg$FAILED) {
	              peg$savedPos = s0;
	              s1 = peg$c76(s2);
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }

	      return s0;
	    }

	    function peg$parseNumber() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      if (peg$c79.test(input.charAt(peg$currPos))) {
	        s2 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c80); }
	      }
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          if (peg$c79.test(input.charAt(peg$currPos))) {
	            s2 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c80); }
	          }
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c70();
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseDoubleStringCharacter() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 34) {
	        s2 = peg$c74;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c75); }
	      }
	      if (s2 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s2 = peg$c81;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c82); }
	        }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        if (input.length > peg$currPos) {
	          s2 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c83); }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c70();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c84) {
	          s0 = peg$c84;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c85); }
	        }
	      }

	      return s0;
	    }

	    function peg$parseSingleStringCharacter() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 39) {
	        s2 = peg$c77;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c78); }
	      }
	      if (s2 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s2 = peg$c81;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c82); }
	        }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        if (input.length > peg$currPos) {
	          s2 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c83); }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c70();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c86) {
	          s0 = peg$c86;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c87); }
	        }
	      }

	      return s0;
	    }

	    function peg$parse_() {
	      var s0, s1;

	      s0 = [];
	      if (peg$c88.test(input.charAt(peg$currPos))) {
	        s1 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c89); }
	      }
	      while (s1 !== peg$FAILED) {
	        s0.push(s1);
	        if (peg$c88.test(input.charAt(peg$currPos))) {
	          s1 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c89); }
	        }
	      }

	      return s0;
	    }



	      // http://www.w3schools.com/cssref/css_selectors.asp

	      const {
	        IDSelectorExpression,
	        SelectorLiteralExpression,
	        AllSelectorExpression,
	        ListSelectorExpression,
	        ChildSelectorExpression,
	        PseudoElementExpression,
	        PseudoClassSelectorExpression,
	        TagNameSelectorExpression,
	        NestedSelectorExpression,
	        AttributeSelectorExpression,
	        ClassNameSelectorExpression,
	        DescendentSelectorExpression,
	        AdjacentSiblingSelectorExpression,
	        ProceedingSiblingSelectorExpression,
	      } = __webpack_require__(241);


	    peg$result = peg$startRuleFunction();

	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail(peg$endExpectation());
	      }

	      throw peg$buildStructuredError(
	        peg$maxFailExpected,
	        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
	        peg$maxFailPos < input.length
	          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
	          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
	      );
	    }
	  }

	  return {
	    SyntaxError: peg$SyntaxError,
	    parse:       peg$parse
	  };
	})();

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	(function (SelectorKind) {
	    SelectorKind[SelectorKind["CLASS_NAME"] = 1] = "CLASS_NAME";
	    SelectorKind[SelectorKind["ID_SELECTOR"] = 2] = "ID_SELECTOR";
	    SelectorKind[SelectorKind["TAG_NAME"] = 3] = "TAG_NAME";
	    SelectorKind[SelectorKind["LIST"] = 4] = "LIST";
	    SelectorKind[SelectorKind["ALL"] = 5] = "ALL";
	    SelectorKind[SelectorKind["DESCENDENT"] = 6] = "DESCENDENT";
	    SelectorKind[SelectorKind["CHILD"] = 7] = "CHILD";
	    SelectorKind[SelectorKind["ADJACENT"] = 8] = "ADJACENT";
	    SelectorKind[SelectorKind["PROCEEDING"] = 9] = "PROCEEDING";
	    SelectorKind[SelectorKind["ATTRIBUTE"] = 10] = "ATTRIBUTE";
	    SelectorKind[SelectorKind["PSEUDO_CLASS"] = 11] = "PSEUDO_CLASS";
	    SelectorKind[SelectorKind["NESTED"] = 12] = "NESTED";
	    SelectorKind[SelectorKind["PSEUDO_ELEMENT"] = 13] = "PSEUDO_ELEMENT";
	    SelectorKind[SelectorKind["LITERAL"] = 14] = "LITERAL";
	})(exports.SelectorKind || (exports.SelectorKind = {}));
	var SelectorKind = exports.SelectorKind;
	class SelectorExpression extends common_1.BaseExpression {
	}
	exports.SelectorExpression = SelectorExpression;
	class SelectorLiteralExpression extends SelectorExpression {
	    constructor(value, location) {
	        super(location);
	        this.value = value;
	        this.kind = SelectorKind.LITERAL;
	    }
	    accept(visitor) {
	        return visitor.visitLiteral(this);
	    }
	}
	exports.SelectorLiteralExpression = SelectorLiteralExpression;
	// .item { }
	class ClassNameSelectorExpression extends SelectorExpression {
	    constructor(className, location) {
	        super(location);
	        this.className = className;
	        this.kind = SelectorKind.CLASS_NAME;
	    }
	    accept(visitor) {
	        return visitor.visitClassNameSelector(this);
	    }
	}
	exports.ClassNameSelectorExpression = ClassNameSelectorExpression;
	// #item { }
	class IDSelectorExpression extends SelectorExpression {
	    constructor(id, location) {
	        super(location);
	        this.id = id;
	        this.kind = SelectorKind.ID_SELECTOR;
	    }
	    accept(visitor) {
	        return visitor.visitIDSelector(this);
	    }
	}
	exports.IDSelectorExpression = IDSelectorExpression;
	// div { }
	class TagNameSelectorExpression extends SelectorExpression {
	    constructor(tagName, location) {
	        super(location);
	        this.tagName = tagName;
	        this.kind = SelectorKind.TAG_NAME;
	    }
	    accept(visitor) {
	        return visitor.visitTagNameSelector(this);
	    }
	}
	exports.TagNameSelectorExpression = TagNameSelectorExpression;
	// div, span { }
	class ListSelectorExpression extends SelectorExpression {
	    constructor(selectors, location) {
	        super(location);
	        this.selectors = selectors;
	        this.kind = SelectorKind.LIST;
	    }
	    accept(visitor) {
	        return visitor.visitListSelector(this);
	    }
	}
	exports.ListSelectorExpression = ListSelectorExpression;
	// * { }
	class AllSelectorExpression extends SelectorExpression {
	    constructor() {
	        super(...arguments);
	        this.kind = SelectorKind.ALL;
	    }
	    accept(visitor) {
	        return visitor.visitAllSelector(this);
	    }
	}
	exports.AllSelectorExpression = AllSelectorExpression;
	// div span { }
	class DescendentSelectorExpression extends SelectorExpression {
	    constructor(ancestorSelector, targetSelector, location) {
	        super(location);
	        this.ancestorSelector = ancestorSelector;
	        this.targetSelector = targetSelector;
	        this.kind = SelectorKind.DESCENDENT;
	    }
	    accept(visitor) {
	        return visitor.visitDescendentSelector(this);
	    }
	}
	exports.DescendentSelectorExpression = DescendentSelectorExpression;
	// div > span { }
	class ChildSelectorExpression extends SelectorExpression {
	    constructor(parentSelector, targetSelector, location) {
	        super(location);
	        this.parentSelector = parentSelector;
	        this.targetSelector = targetSelector;
	        this.kind = SelectorKind.CHILD;
	    }
	    accept(visitor) {
	        return visitor.visitChildSelector(this);
	    }
	}
	exports.ChildSelectorExpression = ChildSelectorExpression;
	// div + span { }
	class AdjacentSiblingSelectorExpression extends SelectorExpression {
	    constructor(startSelector, targetSelector, location) {
	        super(location);
	        this.startSelector = startSelector;
	        this.targetSelector = targetSelector;
	        this.kind = SelectorKind.ADJACENT;
	    }
	    accept(visitor) {
	        return visitor.visitAdjacentSiblingSelector(this);
	    }
	}
	exports.AdjacentSiblingSelectorExpression = AdjacentSiblingSelectorExpression;
	// div ~ span { }
	class ProceedingSiblingSelectorExpression extends SelectorExpression {
	    constructor(startSelector, targetSelector, location) {
	        super(location);
	        this.startSelector = startSelector;
	        this.targetSelector = targetSelector;
	        this.kind = SelectorKind.PROCEEDING;
	    }
	    accept(visitor) {
	        return visitor.visitProceedingSiblingSelector(this);
	    }
	}
	exports.ProceedingSiblingSelectorExpression = ProceedingSiblingSelectorExpression;
	// [attribute]
	// [attribute~=value]
	// [attribute^=value]
	// [attribute$=value]
	// [attribute*=value]
	class AttributeSelectorExpression extends SelectorExpression {
	    constructor(name, operator, value, location) {
	        super(location);
	        this.name = name;
	        this.operator = operator;
	        this.value = value;
	        this.kind = SelectorKind.ATTRIBUTE;
	    }
	    accept(visitor) {
	        return visitor.visitAttributeSelector(this);
	    }
	}
	exports.AttributeSelectorExpression = AttributeSelectorExpression;
	class PseudoSelectorExpression extends SelectorExpression {
	    constructor(name, parameter, location) {
	        super(location);
	        this.name = name;
	        this.parameter = parameter;
	    }
	}
	exports.PseudoSelectorExpression = PseudoSelectorExpression;
	class PseudoClassSelectorExpression extends PseudoSelectorExpression {
	    constructor() {
	        super(...arguments);
	        this.kind = SelectorKind.PSEUDO_CLASS;
	    }
	    accept(visitor) {
	        return visitor.visitPseudoClassSelector(this);
	    }
	}
	exports.PseudoClassSelectorExpression = PseudoClassSelectorExpression;
	class PseudoElementExpression extends PseudoSelectorExpression {
	    constructor() {
	        super(...arguments);
	        this.kind = SelectorKind.PSEUDO_ELEMENT;
	    }
	    accept(visitor) {
	        return visitor.visitPseudoElement(this);
	    }
	}
	exports.PseudoElementExpression = PseudoElementExpression;
	class NestedSelectorExpression extends SelectorExpression {
	    constructor(parent, child, location) {
	        super(location);
	        this.parent = parent;
	        this.child = child;
	        this.kind = SelectorKind.NESTED;
	    }
	    accept(visitor) {
	        return visitor.visitNestedSelector(this);
	    }
	}
	exports.NestedSelectorExpression = NestedSelectorExpression;


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const decorators_1 = __webpack_require__(69);
	const lodash_1 = __webpack_require__(56);
	const node_types_1 = __webpack_require__(233);
	const selector_1 = __webpack_require__(236);
	const document_fragment_1 = __webpack_require__(243);
	const mesh_1 = __webpack_require__(13);
	const node_1 = __webpack_require__(234);
	const container_1 = __webpack_require__(232);
	const common_1 = __webpack_require__(46);
	var SyntheticDOMElementMutationTypes;
	(function (SyntheticDOMElementMutationTypes) {
	    SyntheticDOMElementMutationTypes.SET_ELEMENT_ATTRIBUTE_EDIT = "setElementAttributeEdit";
	    SyntheticDOMElementMutationTypes.ATTACH_SHADOW_ROOT_EDIT = "attachShadowRootEdit";
	})(SyntheticDOMElementMutationTypes = exports.SyntheticDOMElementMutationTypes || (exports.SyntheticDOMElementMutationTypes = {}));
	function isDOMElementMutation(mutation) {
	    return (mutation.target.nodeType === node_types_1.DOMNodeType.ELEMENT) && (!!{
	        [SyntheticDOMElementMutationTypes.SET_ELEMENT_ATTRIBUTE_EDIT]: true,
	        [SyntheticDOMElementMutationTypes.ATTACH_SHADOW_ROOT_EDIT]: true
	    }[mutation.type] || container_1.isDOMContainerMutation(mutation));
	}
	exports.isDOMElementMutation = isDOMElementMutation;
	class SyntheticDOMAttributeSerializer {
	    serialize({ name, value, readonly }) {
	        return { name, value, readonly };
	    }
	    deserialize({ name, value, readonly }) {
	        return new SyntheticDOMAttribute(name, value, readonly);
	    }
	}
	let SyntheticDOMAttribute_1 = class SyntheticDOMAttribute extends common_1.Observable {
	    constructor(name, value, readonly) {
	        super();
	        this.name = name;
	        this.readonly = readonly;
	        this.value = value;
	    }
	    get uid() {
	        return this.name;
	    }
	    toString() {
	        return `${this.name}="${this.value}"`;
	    }
	    clone() {
	        return new SyntheticDOMAttribute_1(this.name, this.value, this.readonly);
	    }
	};
	let SyntheticDOMAttribute = SyntheticDOMAttribute_1;
	__decorate([
	    decorators_1.bindable(true)
	], SyntheticDOMAttribute.prototype, "value", void 0);
	SyntheticDOMAttribute = SyntheticDOMAttribute_1 = __decorate([
	    common_1.serializable(new SyntheticDOMAttributeSerializer())
	], SyntheticDOMAttribute);
	exports.SyntheticDOMAttribute = SyntheticDOMAttribute;
	class SyntheticDOMAttributes extends common_1.ObservableCollection {
	    splice(start, deleteCount = 0, ...items) {
	        for (let i = start, n = Math.min(start + deleteCount, this.length); i < n; i++) {
	            const rmAttribute = this[i];
	            // delete the attribute to ensure that hasOwnProperty returns false
	            this[rmAttribute.name] = undefined;
	        }
	        for (let i = 0, n = items.length; i < n; i++) {
	            const newAttribute = items[i];
	            this[newAttribute.name] = newAttribute;
	        }
	        return super.splice(start, deleteCount, ...items);
	    }
	    toObject(...only) {
	        const ret = {};
	        for (let i = 0, n = this.length; i < n; i++) {
	            const attribute = this[i];
	            if (only.length !== 0 && only.indexOf(attribute.name) === -1) {
	                continue;
	            }
	            ret[attribute.name] = attribute.value;
	        }
	        return ret;
	    }
	    toString() {
	        return this.map((attribute) => {
	            return ` ${attribute}`;
	        }).join("");
	    }
	}
	exports.SyntheticDOMAttributes = SyntheticDOMAttributes;
	class SyntheticDOMElementSerializer {
	    serialize({ nodeName, namespaceURI, shadowRoot, attributes, childNodes }) {
	        return {
	            nodeName,
	            namespaceURI,
	            shadowRoot: common_1.serialize(shadowRoot),
	            attributes: [].concat(attributes).map(common_1.serialize),
	            childNodes: [].concat(childNodes).map(common_1.serialize)
	        };
	    }
	    deserialize({ nodeName, shadowRoot, namespaceURI, attributes, childNodes }, injector, ctor) {
	        const element = new ctor(namespaceURI, nodeName);
	        for (let i = 0, n = attributes.length; i < n; i++) {
	            element.attributes.push(common_1.deserialize(attributes[i], injector));
	        }
	        for (let i = 0, n = childNodes.length; i < n; i++) {
	            const child = common_1.deserialize(childNodes[i], injector);
	            element.appendChild(child);
	        }
	        const shadowRootFragment = common_1.deserialize(shadowRoot, injector);
	        if (shadowRootFragment) {
	            element.attachShadow({ mode: "open" }).appendChild(shadowRootFragment);
	        }
	        // NOTE - $createdCallback is not called here for a reason -- serialized
	        // must store the entire state of an object.
	        return element;
	    }
	}
	exports.SyntheticDOMElementSerializer = SyntheticDOMElementSerializer;
	class SyntheticDOMElementEdit extends container_1.SyntheticDOMContainerEdit {
	    setAttribute(name, value, oldName, index) {
	        return this.addChange(new common_1.PropertyMutation(SyntheticDOMElementMutationTypes.SET_ELEMENT_ATTRIBUTE_EDIT, this.target, name, value, undefined, oldName, index));
	    }
	    removeAttribute(name) {
	        return this.setAttribute(name, undefined);
	    }
	    attachShadowRoot(shadowRoot) {
	        this.addChange(new common_1.InsertChildMutation(SyntheticDOMElementMutationTypes.ATTACH_SHADOW_ROOT_EDIT, this.target, shadowRoot, Number.MAX_SAFE_INTEGER));
	    }
	    /**
	     * Adds diff actions from the new element
	     *
	     * @param {SyntheticDOMElement} newElement
	     */
	    addDiff(newElement) {
	        if (this.target.nodeName !== newElement.nodeName) {
	            throw new Error(`nodeName must match in order to diff`);
	        }
	        if (lodash_1.difference(this.target.readonlyAttributesNames, newElement.readonlyAttributesNames).length) {
	            this.setAttribute("data-td-readonly", JSON.stringify(newElement.readonlyAttributesNames));
	        }
	        common_1.diffArray(this.target.attributes, newElement.attributes, (a, b) => a.name === b.name ? 1 : -1).accept({
	            visitInsert: ({ index, value }) => {
	                this.setAttribute(value.name, value.value, undefined, index);
	            },
	            visitRemove: ({ index }) => {
	                this.removeAttribute(this.target.attributes[index].name);
	            },
	            visitUpdate: ({ originalOldIndex, patchedOldIndex, newValue, index }) => {
	                if (this.target.attributes[originalOldIndex].value !== newValue.value) {
	                    this.setAttribute(newValue.name, newValue.value, undefined, index);
	                }
	            }
	        });
	        if (newElement.shadowRoot) {
	            if (!this.target.shadowRoot) {
	                this.attachShadowRoot(newElement.shadowRoot);
	            }
	            else {
	                this.addChildEdit(this.target.shadowRoot.createEdit().fromDiff(newElement.shadowRoot));
	            }
	        }
	        return super.addDiff(newElement);
	    }
	}
	exports.SyntheticDOMElementEdit = SyntheticDOMElementEdit;
	class DOMElementEditor extends container_1.DOMContainerEditor {
	    constructor(target, createNode) {
	        super(target, createNode);
	    }
	    applySingleMutation(mutation) {
	        super.applySingleMutation(mutation);
	        if (mutation.type === SyntheticDOMElementMutationTypes.SET_ELEMENT_ATTRIBUTE_EDIT) {
	            const { name, oldName, newValue } = mutation;
	            // need to set the current value (property), and the default value (attribute)
	            // TODO - this may need to be separated later on.
	            if (this.target.constructor.prototype.hasOwnProperty(name)) {
	                this.target[name] = newValue == null ? "" : newValue;
	            }
	            if (newValue == null) {
	                this.target.removeAttribute(name);
	            }
	            else {
	                this.target.setAttribute(name, newValue);
	            }
	            if (oldName) {
	                if (this.target.hasOwnProperty(oldName)) {
	                    this.target[oldName] = undefined;
	                }
	                this.target.removeAttribute(oldName);
	            }
	        }
	    }
	}
	exports.DOMElementEditor = DOMElementEditor;
	class SyntheticDOMElementEditor extends container_1.SyntheticDOMContainerEditor {
	    constructor(target) {
	        super(target);
	    }
	    createDOMEditor(target) {
	        return new DOMElementEditor(target);
	    }
	    applySingleMutation(mutation) {
	        if (mutation.type === SyntheticDOMElementMutationTypes.ATTACH_SHADOW_ROOT_EDIT) {
	            const { child } = mutation;
	            const shadowRoot = child;
	            this.target.$setShadowRoot(shadowRoot.cloneNode(true));
	        }
	    }
	}
	exports.SyntheticDOMElementEditor = SyntheticDOMElementEditor;
	let SyntheticDOMElement = class SyntheticDOMElement extends container_1.SyntheticDOMContainer {
	    constructor(namespaceURI, tagName) {
	        super(tagName);
	        this.namespaceURI = namespaceURI;
	        this.tagName = tagName;
	        this.nodeType = node_types_1.DOMNodeType.ELEMENT;
	        this._readonlyAttributeNames = [];
	        this._shadowRootObserver = new common_1.BubbleDispatcher(this);
	        this.attributes = new SyntheticDOMAttributes();
	        this.attributes.observe(new mesh_1.CallbackDispatcher(this.onAttributesEvent.bind(this)));
	        // todo - proxy this
	        this.dataset = {};
	    }
	    createEdit() {
	        return new SyntheticDOMElementEdit(this);
	    }
	    createEditor() {
	        return new SyntheticDOMElementEditor(this);
	    }
	    visitWalker(walker) {
	        if (this.shadowRoot)
	            walker.accept(this.shadowRoot);
	        super.visitWalker(walker);
	    }
	    getAttribute(name) {
	        return this.hasAttribute(name) ? this.attributes[name].value : null;
	    }
	    hasAttribute(name) {
	        return this.attributes[name] != null;
	    }
	    accept(visitor) {
	        return visitor.visitElement(this);
	    }
	    get readonlyAttributesNames() {
	        return this._readonlyAttributeNames;
	    }
	    attachShadow({ mode }) {
	        if (this._shadowRoot)
	            return this._shadowRoot;
	        return this.$setShadowRoot(new document_fragment_1.SyntheticDocumentFragment());
	    }
	    $setShadowRoot(shadowRoot) {
	        if (this._shadowRoot) {
	            this._shadowRoot.unobserve(this._shadowRootObserver);
	        }
	        this._shadowRoot = shadowRoot;
	        this._shadowRoot.$setOwnerDocument(this.ownerDocument);
	        this._shadowRoot.observe(new common_1.BubbleDispatcher(this));
	        return this._shadowRoot;
	    }
	    get shadowRoot() {
	        return this._shadowRoot;
	    }
	    get id() {
	        return this.getAttribute("id");
	    }
	    set id(value) {
	        this.setAttribute("id", value);
	    }
	    matches(selector) {
	        return selector_1.selectorMatchesElement(selector, this);
	    }
	    setAttribute(name, value) {
	        // attributes that are not editable by the editor
	        if (name === "data-td-readonly") {
	            this._readonlyAttributeNames = JSON.parse(value);
	            return this._resetReadonlyAttributes();
	        }
	        // Reserved attribute to help map where this element came from. Defined
	        // by source transformers that scan for HTML elements.
	        if (name === "data-td-source") {
	            this.$source = JSON.parse(value);
	            return;
	        }
	        let oldValue;
	        const attribute = this.attributes[name];
	        if (attribute) {
	            attribute.value = value;
	        }
	        else {
	            this.attributes.push(new SyntheticDOMAttribute(name, value, this._readonlyAttributeNames.indexOf(name) !== -1));
	        }
	    }
	    _resetReadonlyAttributes() {
	        for (const attribute of this.attributes) {
	            attribute.readonly = false;
	        }
	        for (const attributeName of this._readonlyAttributeNames) {
	            const attribute = this.attributes[attributeName];
	            if (attribute)
	                attribute.readonly = true;
	        }
	    }
	    removeAttribute(name) {
	        if (this.hasAttribute(name)) {
	            const attribute = this.attributes[name];
	            this.attributes.splice(this.attributes.indexOf(attribute), 1);
	        }
	    }
	    toString() {
	        return [
	            "<",
	            this.nodeName,
	            this.attributes,
	            ">",
	            this.childNodes.map((child) => child.toString()).join(""),
	            "</",
	            this.nodeName,
	            ">"
	        ].join("");
	    }
	    onAttributesEvent({ mutation }) {
	        if (!mutation)
	            return;
	        if (mutation.type === common_1.ArrayMutation.ARRAY_DIFF) {
	            mutation.accept({
	                visitUpdate: () => { },
	                visitInsert: ({ value, index }) => {
	                    this.attributeChangedCallback(value.name, undefined, value.value);
	                },
	                visitRemove: ({ value, index }) => {
	                    this.attributeChangedCallback(value.name, value.value, undefined);
	                }
	            });
	        }
	        else if (mutation.type === common_1.PropertyMutation.PROPERTY_CHANGE && mutation.target instanceof SyntheticDOMAttribute) {
	            const changeMutation = mutation;
	            const attribute = mutation.target;
	            this.attributeChangedCallback(attribute.name, changeMutation.oldValue, changeMutation.newValue);
	        }
	    }
	    $setOwnerDocument(document) {
	        super.$setOwnerDocument(document);
	        if (this._shadowRoot) {
	            this._shadowRoot.$setOwnerDocument(document);
	        }
	    }
	    attributeChangedCallback(name, oldValue, newValue) {
	        this.notify(new common_1.PropertyMutation(SyntheticDOMElementMutationTypes.SET_ELEMENT_ATTRIBUTE_EDIT, this, name, newValue, oldValue).toEvent(true));
	    }
	    cloneShallow() {
	        const constructor = this.constructor;
	        const clone = new constructor(this.namespaceURI, this.tagName);
	        for (const attribute of this.attributes) {
	            clone.setAttribute(attribute.name, attribute.value);
	        }
	        return clone;
	    }
	};
	__decorate([
	    decorators_1.bindable()
	], SyntheticDOMElement.prototype, "onclick", void 0);
	SyntheticDOMElement = __decorate([
	    common_1.serializable(new node_1.SyntheticDOMNodeSerializer(new SyntheticDOMElementSerializer()))
	], SyntheticDOMElement);
	exports.SyntheticDOMElement = SyntheticDOMElement;


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const node_types_1 = __webpack_require__(233);
	const container_1 = __webpack_require__(232);
	const common_1 = __webpack_require__(46);
	class SyntheticDocumentFragmentSerializer {
	    serialize({ childNodes }) {
	        return {
	            childNodes: childNodes.map(common_1.serialize)
	        };
	    }
	    deserialize({ childNodes }, injector) {
	        const fragment = new SyntheticDocumentFragment();
	        for (let i = 0, n = childNodes.length; i < n; i++) {
	            fragment.appendChild(common_1.deserialize(childNodes[i], injector));
	        }
	        return fragment;
	    }
	}
	let SyntheticDocumentFragment_1 = class SyntheticDocumentFragment extends container_1.SyntheticDOMContainer {
	    constructor() {
	        super("#document-fragment");
	        this.nodeType = node_types_1.DOMNodeType.DOCUMENT_FRAGMENT;
	    }
	    accept(visitor) {
	        return visitor.visitDocumentFragment(this);
	    }
	    cloneShallow() {
	        return new SyntheticDocumentFragment_1();
	    }
	};
	let SyntheticDocumentFragment = SyntheticDocumentFragment_1;
	SyntheticDocumentFragment = SyntheticDocumentFragment_1 = __decorate([
	    common_1.serializable(new SyntheticDocumentFragmentSerializer())
	], SyntheticDocumentFragment);
	exports.SyntheticDocumentFragment = SyntheticDocumentFragment;


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const node_types_1 = __webpack_require__(233);
	const node_1 = __webpack_require__(234);
	const common_1 = __webpack_require__(46);
	const value_node_1 = __webpack_require__(245);
	let SyntheticDOMText_1 = class SyntheticDOMText extends value_node_1.SyntheticDOMValueNode {
	    constructor(nodeValue) {
	        super("#text", nodeValue);
	        this.nodeType = node_types_1.DOMNodeType.TEXT;
	    }
	    get textContent() {
	        return this.nodeValue;
	    }
	    set textContent(value) {
	        this.nodeValue = value;
	    }
	    toString() {
	        return this.nodeValue;
	    }
	    accept(visitor) {
	        return visitor.visitText(this);
	    }
	    cloneShallow() {
	        return new SyntheticDOMText_1(this.nodeValue);
	    }
	    visitWalker(walker) { }
	};
	let SyntheticDOMText = SyntheticDOMText_1;
	SyntheticDOMText = SyntheticDOMText_1 = __decorate([
	    common_1.serializable(new node_1.SyntheticDOMNodeSerializer(new value_node_1.SyntheticDOMValueNodeSerializer()))
	], SyntheticDOMText);
	exports.SyntheticDOMText = SyntheticDOMText;


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const ent_1 = __webpack_require__(222);
	const node_types_1 = __webpack_require__(233);
	const node_1 = __webpack_require__(234);
	const common_1 = __webpack_require__(46);
	const sandbox_1 = __webpack_require__(167);
	var SyntheticDOMValueNodeMutationTypes;
	(function (SyntheticDOMValueNodeMutationTypes) {
	    SyntheticDOMValueNodeMutationTypes.SET_VALUE_NODE_EDIT = "setValueNodeEdit";
	})(SyntheticDOMValueNodeMutationTypes = exports.SyntheticDOMValueNodeMutationTypes || (exports.SyntheticDOMValueNodeMutationTypes = {}));
	class SyntheticDOMValueNodeEdit extends node_1.SyntheticDOMNodeEdit {
	    setValueNode(nodeValue) {
	        return this.addChange(new common_1.SetValueMutation(SyntheticDOMValueNodeMutationTypes.SET_VALUE_NODE_EDIT, this.target, nodeValue));
	    }
	    addDiff(newValueNode) {
	        if (this.target.nodeValue !== newValueNode.nodeValue) {
	            this.setValueNode(newValueNode.nodeValue);
	        }
	        return super.addDiff(newValueNode);
	    }
	}
	exports.SyntheticDOMValueNodeEdit = SyntheticDOMValueNodeEdit;
	class DOMValueNodeEditor extends sandbox_1.BaseEditor {
	    applySingleMutation(mutation) {
	        if (mutation.type === SyntheticDOMValueNodeMutationTypes.SET_VALUE_NODE_EDIT) {
	            this.target.nodeValue = ent_1.decode(mutation.newValue);
	        }
	    }
	}
	exports.DOMValueNodeEditor = DOMValueNodeEditor;
	function isDOMValueNodeMutation(mutation) {
	    return (mutation.target.nodeType === node_types_1.DOMNodeType.COMMENT || mutation.target.nodeType === node_types_1.DOMNodeType.TEXT) && (!!{
	        [SyntheticDOMValueNodeMutationTypes.SET_VALUE_NODE_EDIT]: true
	    }[mutation.type]);
	}
	exports.isDOMValueNodeMutation = isDOMValueNodeMutation;
	class SyntheticDOMValueNodeSerializer {
	    serialize({ nodeValue }) {
	        return { nodeValue };
	    }
	    deserialize({ nodeValue }, injector, ctor) {
	        return new ctor(nodeValue);
	    }
	}
	exports.SyntheticDOMValueNodeSerializer = SyntheticDOMValueNodeSerializer;
	class SyntheticDOMValueNode extends node_1.SyntheticDOMNode {
	    constructor(nodeName, nodeValue) {
	        super(nodeName);
	        this.nodeValue = nodeValue;
	    }
	    get nodeValue() {
	        return this._nodeValue;
	    }
	    set nodeValue(value) {
	        this._nodeValue = String(value);
	        this.notify(new common_1.PropertyMutation(SyntheticDOMValueNodeMutationTypes.SET_VALUE_NODE_EDIT, this, "nodeValue", value).toEvent(true));
	    }
	    createEdit() {
	        return new SyntheticDOMValueNodeEdit(this);
	    }
	    createEditor() {
	        return new sandbox_1.GroupEditor(new DOMValueNodeEditor(this), super.createEditor());
	    }
	}
	exports.SyntheticDOMValueNode = SyntheticDOMValueNode;


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const node_types_1 = __webpack_require__(233);
	const common_1 = __webpack_require__(46);
	const node_1 = __webpack_require__(234);
	const value_node_1 = __webpack_require__(245);
	let SyntheticDOMComment_1 = class SyntheticDOMComment extends value_node_1.SyntheticDOMValueNode {
	    constructor(nodeValue) {
	        super("#comment", nodeValue);
	        this.nodeType = node_types_1.DOMNodeType.COMMENT;
	    }
	    toString() {
	        return `<!--${this.nodeValue}-->`;
	    }
	    get textContent() {
	        return "";
	    }
	    set textContent(value) {
	        this.nodeValue = value;
	    }
	    accept(visitor) {
	        return visitor.visitComment(this);
	    }
	    cloneShallow() {
	        return new SyntheticDOMComment_1(this.nodeValue);
	    }
	    visitWalker(walker) { }
	};
	let SyntheticDOMComment = SyntheticDOMComment_1;
	SyntheticDOMComment = SyntheticDOMComment_1 = __decorate([
	    common_1.serializable(new node_1.SyntheticDOMNodeSerializer(new value_node_1.SyntheticDOMValueNodeSerializer()))
	], SyntheticDOMComment);
	exports.SyntheticDOMComment = SyntheticDOMComment;


/***/ },
/* 247 */
/***/ function(module, exports) {

	"use strict";


/***/ },
/* 248 */
/***/ function(module, exports) {

	"use strict";


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const { parse } = __webpack_require__(250);
	const _cache = {};
	exports.parseMarkup = (source) => {
	    if (_cache[source])
	        return _cache[source].clone();
	    return (_cache[source] = parse(source)).clone();
	};


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = /*
	 * Generated by PEG.js 0.10.0.
	 *
	 * http://pegjs.org/
	 */
	(function() {
	  "use strict";

	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }

	  function peg$SyntaxError(message, expected, found, location) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.location = location;
	    this.name     = "SyntaxError";

	    if (typeof Error.captureStackTrace === "function") {
	      Error.captureStackTrace(this, peg$SyntaxError);
	    }
	  }

	  peg$subclass(peg$SyntaxError, Error);

	  peg$SyntaxError.buildMessage = function(expected, found) {
	    var DESCRIBE_EXPECTATION_FNS = {
	          literal: function(expectation) {
	            return "\"" + literalEscape(expectation.text) + "\"";
	          },

	          "class": function(expectation) {
	            var escapedParts = "",
	                i;

	            for (i = 0; i < expectation.parts.length; i++) {
	              escapedParts += expectation.parts[i] instanceof Array
	                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
	                : classEscape(expectation.parts[i]);
	            }

	            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
	          },

	          any: function(expectation) {
	            return "any character";
	          },

	          end: function(expectation) {
	            return "end of input";
	          },

	          other: function(expectation) {
	            return expectation.description;
	          }
	        };

	    function hex(ch) {
	      return ch.charCodeAt(0).toString(16).toUpperCase();
	    }

	    function literalEscape(s) {
	      return s
	        .replace(/\\/g, '\\\\')
	        .replace(/"/g,  '\\"')
	        .replace(/\0/g, '\\0')
	        .replace(/\t/g, '\\t')
	        .replace(/\n/g, '\\n')
	        .replace(/\r/g, '\\r')
	        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
	        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
	    }

	    function classEscape(s) {
	      return s
	        .replace(/\\/g, '\\\\')
	        .replace(/\]/g, '\\]')
	        .replace(/\^/g, '\\^')
	        .replace(/-/g,  '\\-')
	        .replace(/\0/g, '\\0')
	        .replace(/\t/g, '\\t')
	        .replace(/\n/g, '\\n')
	        .replace(/\r/g, '\\r')
	        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
	        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
	    }

	    function describeExpectation(expectation) {
	      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
	    }

	    function describeExpected(expected) {
	      var descriptions = new Array(expected.length),
	          i, j;

	      for (i = 0; i < expected.length; i++) {
	        descriptions[i] = describeExpectation(expected[i]);
	      }

	      descriptions.sort();

	      if (descriptions.length > 0) {
	        for (i = 1, j = 1; i < descriptions.length; i++) {
	          if (descriptions[i - 1] !== descriptions[i]) {
	            descriptions[j] = descriptions[i];
	            j++;
	          }
	        }
	        descriptions.length = j;
	      }

	      switch (descriptions.length) {
	        case 1:
	          return descriptions[0];

	        case 2:
	          return descriptions[0] + " or " + descriptions[1];

	        default:
	          return descriptions.slice(0, -1).join(", ")
	            + ", or "
	            + descriptions[descriptions.length - 1];
	      }
	    }

	    function describeFound(found) {
	      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
	    }

	    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
	  };

	  function peg$parse(input, options) {
	    options = options !== void 0 ? options : {};

	    var peg$FAILED = {},

	        peg$startRuleFunctions = { Start: peg$parseStart },
	        peg$startRuleFunction  = peg$parseStart,

	        peg$c0 = function(nodes) {
	            return new MarkupFragmentExpression(nodes.filter(function(node) {
	              return !!node;
	            }), location());
	          },
	        peg$c1 = function(node) { return node; },
	        peg$c2 = "<!--",
	        peg$c3 = peg$literalExpectation("<!--", false),
	        peg$c4 = "-->",
	        peg$c5 = peg$literalExpectation("-->", false),
	        peg$c6 = function(characters) { return new MarkupCommentExpression(characters.join(''), location()); },
	        peg$c7 = peg$anyExpectation(),
	        peg$c8 = function(character) { return character; },
	        peg$c9 = "<!",
	        peg$c10 = peg$literalExpectation("<!", false),
	        peg$c11 = ">",
	        peg$c12 = peg$literalExpectation(">", false),
	        peg$c13 = function(chars) { return null; },
	        peg$c14 = "<",
	        peg$c15 = peg$literalExpectation("<", false),
	        peg$c16 = "/>",
	        peg$c17 = peg$literalExpectation("/>", false),
	        peg$c18 = function(nodeName, attributes, endTag) {

	            if (endTag && nodeName != endTag.name) {
	              expected("</" + nodeName + ">");
	            }

	            return new MarkupElementExpression(nodeName, attributes, [], location());
	          },
	        peg$c19 = "</",
	        peg$c20 = peg$literalExpectation("</", false),
	        peg$c21 = function(name) {
	            return {
	              name: name
	            };
	          },
	        peg$c22 = "area",
	        peg$c23 = peg$literalExpectation("area", false),
	        peg$c24 = "base",
	        peg$c25 = peg$literalExpectation("base", false),
	        peg$c26 = "br",
	        peg$c27 = peg$literalExpectation("br", false),
	        peg$c28 = "col",
	        peg$c29 = peg$literalExpectation("col", false),
	        peg$c30 = "command",
	        peg$c31 = peg$literalExpectation("command", false),
	        peg$c32 = "embed",
	        peg$c33 = peg$literalExpectation("embed", false),
	        peg$c34 = "hr",
	        peg$c35 = peg$literalExpectation("hr", false),
	        peg$c36 = "img",
	        peg$c37 = peg$literalExpectation("img", false),
	        peg$c38 = "input",
	        peg$c39 = peg$literalExpectation("input", false),
	        peg$c40 = "keygen",
	        peg$c41 = peg$literalExpectation("keygen", false),
	        peg$c42 = "link",
	        peg$c43 = peg$literalExpectation("link", false),
	        peg$c44 = "meta",
	        peg$c45 = peg$literalExpectation("meta", false),
	        peg$c46 = "param",
	        peg$c47 = peg$literalExpectation("param", false),
	        peg$c48 = "source",
	        peg$c49 = peg$literalExpectation("source", false),
	        peg$c50 = "track",
	        peg$c51 = peg$literalExpectation("track", false),
	        peg$c52 = "wbr",
	        peg$c53 = peg$literalExpectation("wbr", false),
	        peg$c54 = function(open) {
	            return new MarkupElementExpression("script", open.attributes, [], location()); 
	          },
	        peg$c55 = function(open, child) {
	            return new MarkupElementExpression("script", open.attributes, child ? [child] : [], location()); 
	          },
	        peg$c56 = "<script",
	        peg$c57 = peg$literalExpectation("<script", false),
	        peg$c58 = function(attributes) {
	            return {
	              attributes: attributes
	            }
	          },
	        peg$c59 = function(childChars) {
	          
	            return new MarkupTextExpression(text(), location());
	          },
	        peg$c60 = function(char) {
	            return text();
	          },
	        peg$c61 = "</script>",
	        peg$c62 = peg$literalExpectation("</script>", false),
	        peg$c63 = function(startTag, attributes) {
	            return new MarkupElementExpression(startTag, attributes, [], location());
	          },
	        peg$c64 = function(startTag, attributes, childNodes, endTag) {
	            if (startTag != endTag) {
	              expected('</' + startTag + '>');
	            }
	            return new MarkupElementExpression(startTag, attributes, childNodes, location());
	          },
	        peg$c65 = function(name) { return name; },
	        peg$c66 = function(attributes) {
	            return attributes;
	          },
	        peg$c67 = function(attribute) {
	            return attribute;
	          },
	        peg$c68 = "=",
	        peg$c69 = peg$literalExpectation("=", false),
	        peg$c70 = function(key, value) {
	            return new MarkupAttributeExpression(key, value, location());
	          },
	        peg$c71 = function(key) {
	            return new MarkupAttributeExpression(key, "", location());
	          },
	        peg$c72 = "\"",
	        peg$c73 = peg$literalExpectation("\"", false),
	        peg$c74 = function(characters) { return characters.join(''); },
	        peg$c75 = "'",
	        peg$c76 = peg$literalExpectation("'", false),
	        peg$c77 = "\\",
	        peg$c78 = peg$literalExpectation("\\", false),
	        peg$c79 = function() { return text(); },
	        peg$c80 = "\\\"",
	        peg$c81 = peg$literalExpectation("\\\"", false),
	        peg$c82 = "\\'",
	        peg$c83 = peg$literalExpectation("\\'", false),
	        peg$c84 = /^[^<]/,
	        peg$c85 = peg$classExpectation(["<"], true, false),
	        peg$c86 = function() {
	            return new MarkupTextExpression(text(), location());
	          },
	        peg$c87 = /^[a-zA-Z0-9$-.]/,
	        peg$c88 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], ["$", "."]], false, false),
	        peg$c89 = /^[ \n\r\t]/,
	        peg$c90 = peg$classExpectation([" ", "\n", "\r", "\t"], false, false),

	        peg$currPos          = 0,
	        peg$savedPos         = 0,
	        peg$posDetailsCache  = [{ line: 1, column: 1 }],
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$silentFails      = 0,

	        peg$result;

	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleFunctions)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }

	      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	    }

	    function text() {
	      return input.substring(peg$savedPos, peg$currPos);
	    }

	    function location() {
	      return peg$computeLocation(peg$savedPos, peg$currPos);
	    }

	    function expected(description, location) {
	      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

	      throw peg$buildStructuredError(
	        [peg$otherExpectation(description)],
	        input.substring(peg$savedPos, peg$currPos),
	        location
	      );
	    }

	    function error(message, location) {
	      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

	      throw peg$buildSimpleError(message, location);
	    }

	    function peg$literalExpectation(text, ignoreCase) {
	      return { type: "literal", text: text, ignoreCase: ignoreCase };
	    }

	    function peg$classExpectation(parts, inverted, ignoreCase) {
	      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
	    }

	    function peg$anyExpectation() {
	      return { type: "any" };
	    }

	    function peg$endExpectation() {
	      return { type: "end" };
	    }

	    function peg$otherExpectation(description) {
	      return { type: "other", description: description };
	    }

	    function peg$computePosDetails(pos) {
	      var details = peg$posDetailsCache[pos], p;

	      if (details) {
	        return details;
	      } else {
	        p = pos - 1;
	        while (!peg$posDetailsCache[p]) {
	          p--;
	        }

	        details = peg$posDetailsCache[p];
	        details = {
	          line:   details.line,
	          column: details.column
	        };

	        while (p < pos) {
	          if (input.charCodeAt(p) === 10) {
	            details.line++;
	            details.column = 1;
	          } else {
	            details.column++;
	          }

	          p++;
	        }

	        peg$posDetailsCache[pos] = details;
	        return details;
	      }
	    }

	    function peg$computeLocation(startPos, endPos) {
	      var startPosDetails = peg$computePosDetails(startPos),
	          endPosDetails   = peg$computePosDetails(endPos);

	      return {
	        start: {
	          offset: startPos,
	          line:   startPosDetails.line,
	          column: startPosDetails.column
	        },
	        end: {
	          offset: endPos,
	          line:   endPosDetails.line,
	          column: endPosDetails.column
	        }
	      };
	    }

	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }

	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }

	      peg$maxFailExpected.push(expected);
	    }

	    function peg$buildSimpleError(message, location) {
	      return new peg$SyntaxError(message, null, null, location);
	    }

	    function peg$buildStructuredError(expected, found, location) {
	      return new peg$SyntaxError(
	        peg$SyntaxError.buildMessage(expected, found),
	        expected,
	        found,
	        location
	      );
	    }

	    function peg$parseStart() {
	      var s0;

	      s0 = peg$parseFragment();

	      return s0;
	    }

	    function peg$parseFragment() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      s2 = peg$parseNode();
	      if (s2 === peg$FAILED) {
	        s2 = peg$parseTextNode();
	      }
	      while (s2 !== peg$FAILED) {
	        s1.push(s2);
	        s2 = peg$parseNode();
	        if (s2 === peg$FAILED) {
	          s2 = peg$parseTextNode();
	        }
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c0(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseNode() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parse_();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseComment();
	        if (s2 === peg$FAILED) {
	          s2 = peg$parseDOCTYPE();
	          if (s2 === peg$FAILED) {
	            s2 = peg$parseScript();
	            if (s2 === peg$FAILED) {
	              s2 = peg$parseVoidElement();
	              if (s2 === peg$FAILED) {
	                s2 = peg$parseElement();
	                if (s2 === peg$FAILED) {
	                  s2 = peg$parseTextNode();
	                }
	              }
	            }
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c1(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseComment() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 4) === peg$c2) {
	        s1 = peg$c2;
	        peg$currPos += 4;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c3); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parseCommentCharacter();
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$parseCommentCharacter();
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.substr(peg$currPos, 3) === peg$c4) {
	            s3 = peg$c4;
	            peg$currPos += 3;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c5); }
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c6(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseCommentCharacter() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.substr(peg$currPos, 3) === peg$c4) {
	        s2 = peg$c4;
	        peg$currPos += 3;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c5); }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        if (input.length > peg$currPos) {
	          s2 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c7); }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c8(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseDOCTYPE() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 2) === peg$c9) {
	        s1 = peg$c9;
	        peg$currPos += 2;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c10); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parseDOCTYPECharacter();
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$parseDOCTYPECharacter();
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 62) {
	            s3 = peg$c11;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c12); }
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c13(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseDOCTYPECharacter() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 62) {
	        s2 = peg$c11;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c12); }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        if (input.length > peg$currPos) {
	          s2 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c7); }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c8(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseVoidElement() {
	      var s0, s1, s2, s3, s4, s5, s6;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 60) {
	        s1 = peg$c14;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c15); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseVoidTagName();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseElementAttributes();
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              if (input.charCodeAt(peg$currPos) === 62) {
	                s5 = peg$c11;
	                peg$currPos++;
	              } else {
	                s5 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c12); }
	              }
	              if (s5 === peg$FAILED) {
	                if (input.substr(peg$currPos, 2) === peg$c16) {
	                  s5 = peg$c16;
	                  peg$currPos += 2;
	                } else {
	                  s5 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c17); }
	                }
	              }
	              if (s5 === peg$FAILED) {
	                s5 = null;
	              }
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parseEndVoidTag();
	                if (s6 === peg$FAILED) {
	                  s6 = null;
	                }
	                if (s6 !== peg$FAILED) {
	                  peg$savedPos = s0;
	                  s1 = peg$c18(s2, s3, s6);
	                  s0 = s1;
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseEndVoidTag() {
	      var s0, s1, s2, s3, s4;

	      s0 = peg$currPos;
	      s1 = peg$parse_();
	      if (s1 !== peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c19) {
	          s2 = peg$c19;
	          peg$currPos += 2;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c20); }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseVoidTagName();
	          if (s3 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 62) {
	              s4 = peg$c11;
	              peg$currPos++;
	            } else {
	              s4 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c12); }
	            }
	            if (s4 !== peg$FAILED) {
	              peg$savedPos = s0;
	              s1 = peg$c21(s3);
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseVoidTagName() {
	      var s0;

	      if (input.substr(peg$currPos, 4) === peg$c22) {
	        s0 = peg$c22;
	        peg$currPos += 4;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c23); }
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 4) === peg$c24) {
	          s0 = peg$c24;
	          peg$currPos += 4;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c25); }
	        }
	        if (s0 === peg$FAILED) {
	          if (input.substr(peg$currPos, 2) === peg$c26) {
	            s0 = peg$c26;
	            peg$currPos += 2;
	          } else {
	            s0 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c27); }
	          }
	          if (s0 === peg$FAILED) {
	            if (input.substr(peg$currPos, 3) === peg$c28) {
	              s0 = peg$c28;
	              peg$currPos += 3;
	            } else {
	              s0 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c29); }
	            }
	            if (s0 === peg$FAILED) {
	              if (input.substr(peg$currPos, 7) === peg$c30) {
	                s0 = peg$c30;
	                peg$currPos += 7;
	              } else {
	                s0 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c31); }
	              }
	              if (s0 === peg$FAILED) {
	                if (input.substr(peg$currPos, 5) === peg$c32) {
	                  s0 = peg$c32;
	                  peg$currPos += 5;
	                } else {
	                  s0 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c33); }
	                }
	                if (s0 === peg$FAILED) {
	                  if (input.substr(peg$currPos, 2) === peg$c34) {
	                    s0 = peg$c34;
	                    peg$currPos += 2;
	                  } else {
	                    s0 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c35); }
	                  }
	                  if (s0 === peg$FAILED) {
	                    if (input.substr(peg$currPos, 3) === peg$c36) {
	                      s0 = peg$c36;
	                      peg$currPos += 3;
	                    } else {
	                      s0 = peg$FAILED;
	                      if (peg$silentFails === 0) { peg$fail(peg$c37); }
	                    }
	                    if (s0 === peg$FAILED) {
	                      if (input.substr(peg$currPos, 5) === peg$c38) {
	                        s0 = peg$c38;
	                        peg$currPos += 5;
	                      } else {
	                        s0 = peg$FAILED;
	                        if (peg$silentFails === 0) { peg$fail(peg$c39); }
	                      }
	                      if (s0 === peg$FAILED) {
	                        if (input.substr(peg$currPos, 6) === peg$c40) {
	                          s0 = peg$c40;
	                          peg$currPos += 6;
	                        } else {
	                          s0 = peg$FAILED;
	                          if (peg$silentFails === 0) { peg$fail(peg$c41); }
	                        }
	                        if (s0 === peg$FAILED) {
	                          if (input.substr(peg$currPos, 4) === peg$c42) {
	                            s0 = peg$c42;
	                            peg$currPos += 4;
	                          } else {
	                            s0 = peg$FAILED;
	                            if (peg$silentFails === 0) { peg$fail(peg$c43); }
	                          }
	                          if (s0 === peg$FAILED) {
	                            if (input.substr(peg$currPos, 4) === peg$c44) {
	                              s0 = peg$c44;
	                              peg$currPos += 4;
	                            } else {
	                              s0 = peg$FAILED;
	                              if (peg$silentFails === 0) { peg$fail(peg$c45); }
	                            }
	                            if (s0 === peg$FAILED) {
	                              if (input.substr(peg$currPos, 5) === peg$c46) {
	                                s0 = peg$c46;
	                                peg$currPos += 5;
	                              } else {
	                                s0 = peg$FAILED;
	                                if (peg$silentFails === 0) { peg$fail(peg$c47); }
	                              }
	                              if (s0 === peg$FAILED) {
	                                if (input.substr(peg$currPos, 6) === peg$c48) {
	                                  s0 = peg$c48;
	                                  peg$currPos += 6;
	                                } else {
	                                  s0 = peg$FAILED;
	                                  if (peg$silentFails === 0) { peg$fail(peg$c49); }
	                                }
	                                if (s0 === peg$FAILED) {
	                                  if (input.substr(peg$currPos, 5) === peg$c50) {
	                                    s0 = peg$c50;
	                                    peg$currPos += 5;
	                                  } else {
	                                    s0 = peg$FAILED;
	                                    if (peg$silentFails === 0) { peg$fail(peg$c51); }
	                                  }
	                                  if (s0 === peg$FAILED) {
	                                    if (input.substr(peg$currPos, 3) === peg$c52) {
	                                      s0 = peg$c52;
	                                      peg$currPos += 3;
	                                    } else {
	                                      s0 = peg$FAILED;
	                                      if (peg$silentFails === 0) { peg$fail(peg$c53); }
	                                    }
	                                  }
	                                }
	                              }
	                            }
	                          }
	                        }
	                      }
	                    }
	                  }
	                }
	              }
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseScript() {
	      var s0;

	      s0 = peg$parseScriptWithoutChildNodes();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseScriptWithChildNodes();
	      }

	      return s0;
	    }

	    function peg$parseScriptWithoutChildNodes() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$parseScriptTagOpen();
	      if (s1 !== peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c16) {
	          s2 = peg$c16;
	          peg$currPos += 2;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c17); }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c54(s1);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseScriptWithChildNodes() {
	      var s0, s1, s2, s3, s4, s5, s6;

	      s0 = peg$currPos;
	      s1 = peg$parseScriptTagOpen();
	      if (s1 !== peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 62) {
	          s2 = peg$c11;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c12); }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseScriptChildNode();
	            if (s4 === peg$FAILED) {
	              s4 = null;
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parse_();
	              if (s5 !== peg$FAILED) {
	                s6 = peg$parseScriptTagClose();
	                if (s6 !== peg$FAILED) {
	                  peg$savedPos = s0;
	                  s1 = peg$c55(s1, s4);
	                  s0 = s1;
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseScriptTagOpen() {
	      var s0, s1, s2, s3, s4;

	      s0 = peg$currPos;
	      if (input.substr(peg$currPos, 7) === peg$c56) {
	        s1 = peg$c56;
	        peg$currPos += 7;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c57); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseElementAttributes();
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parse_();
	            if (s4 !== peg$FAILED) {
	              peg$savedPos = s0;
	              s1 = peg$c58(s3);
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseScriptChildNode() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      s2 = peg$parseString();
	      if (s2 === peg$FAILED) {
	        s2 = peg$parseScriptTagChildChar();
	      }
	      while (s2 !== peg$FAILED) {
	        s1.push(s2);
	        s2 = peg$parseString();
	        if (s2 === peg$FAILED) {
	          s2 = peg$parseScriptTagChildChar();
	        }
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c59(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseScriptTagChildChar() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      s2 = peg$parseScriptTagClose();
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        if (input.length > peg$currPos) {
	          s2 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c7); }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c60(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseScriptTagClose() {
	      var s0;

	      if (input.substr(peg$currPos, 9) === peg$c61) {
	        s0 = peg$c61;
	        peg$currPos += 9;
	      } else {
	        s0 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c62); }
	      }

	      return s0;
	    }

	    function peg$parseElement() {
	      var s0;

	      s0 = peg$parseElementWithoutChildNodes();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseElementWithChildNodes();
	      }

	      return s0;
	    }

	    function peg$parseElementWithoutChildNodes() {
	      var s0, s1, s2, s3, s4;

	      s0 = peg$currPos;
	      s1 = peg$parseElementStart();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseElementAttributes();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            if (input.substr(peg$currPos, 2) === peg$c16) {
	              s4 = peg$c16;
	              peg$currPos += 2;
	            } else {
	              s4 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c17); }
	            }
	            if (s4 !== peg$FAILED) {
	              peg$savedPos = s0;
	              s1 = peg$c63(s1, s2);
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseElementWithChildNodes() {
	      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

	      s0 = peg$currPos;
	      s1 = peg$parseElementStart();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseElementAttributes();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 62) {
	              s4 = peg$c11;
	              peg$currPos++;
	            } else {
	              s4 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c12); }
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parse_();
	              if (s5 !== peg$FAILED) {
	                s6 = [];
	                s7 = peg$parseNode();
	                while (s7 !== peg$FAILED) {
	                  s6.push(s7);
	                  s7 = peg$parseNode();
	                }
	                if (s6 !== peg$FAILED) {
	                  s7 = peg$parse_();
	                  if (s7 !== peg$FAILED) {
	                    if (input.substr(peg$currPos, 2) === peg$c19) {
	                      s8 = peg$c19;
	                      peg$currPos += 2;
	                    } else {
	                      s8 = peg$FAILED;
	                      if (peg$silentFails === 0) { peg$fail(peg$c20); }
	                    }
	                    if (s8 !== peg$FAILED) {
	                      s9 = peg$parseName();
	                      if (s9 !== peg$FAILED) {
	                        if (input.charCodeAt(peg$currPos) === 62) {
	                          s10 = peg$c11;
	                          peg$currPos++;
	                        } else {
	                          s10 = peg$FAILED;
	                          if (peg$silentFails === 0) { peg$fail(peg$c12); }
	                        }
	                        if (s10 !== peg$FAILED) {
	                          peg$savedPos = s0;
	                          s1 = peg$c64(s1, s2, s6, s9);
	                          s0 = s1;
	                        } else {
	                          peg$currPos = s0;
	                          s0 = peg$FAILED;
	                        }
	                      } else {
	                        peg$currPos = s0;
	                        s0 = peg$FAILED;
	                      }
	                    } else {
	                      peg$currPos = s0;
	                      s0 = peg$FAILED;
	                    }
	                  } else {
	                    peg$currPos = s0;
	                    s0 = peg$FAILED;
	                  }
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseElementStart() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 60) {
	        s1 = peg$c14;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c15); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseName();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c65(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseElementAttributes() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      s2 = peg$parseElementAttribute();
	      while (s2 !== peg$FAILED) {
	        s1.push(s2);
	        s2 = peg$parseElementAttribute();
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c66(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseElementAttribute() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$parse_();
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseElementAttributeInner();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c67(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseElementAttributeInner() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseName();
	      if (s1 !== peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 61) {
	          s2 = peg$c68;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c69); }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseString();
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c70(s1, s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        s1 = peg$parseName();
	        if (s1 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c71(s1);
	        }
	        s0 = s1;
	      }

	      return s0;
	    }

	    function peg$parseString() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 34) {
	        s1 = peg$c72;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c73); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parseDoubleStringCharacter();
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$parseDoubleStringCharacter();
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 34) {
	            s3 = peg$c72;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c73); }
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c74(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 39) {
	          s1 = peg$c75;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c76); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = [];
	          s3 = peg$parseSingleStringCharacter();
	          while (s3 !== peg$FAILED) {
	            s2.push(s3);
	            s3 = peg$parseSingleStringCharacter();
	          }
	          if (s2 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 39) {
	              s3 = peg$c75;
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c76); }
	            }
	            if (s3 !== peg$FAILED) {
	              peg$savedPos = s0;
	              s1 = peg$c74(s2);
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }

	      return s0;
	    }

	    function peg$parseDoubleStringCharacter() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 34) {
	        s2 = peg$c72;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c73); }
	      }
	      if (s2 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s2 = peg$c77;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c78); }
	        }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        if (input.length > peg$currPos) {
	          s2 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c7); }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c79();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c80) {
	          s0 = peg$c80;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c81); }
	        }
	      }

	      return s0;
	    }

	    function peg$parseSingleStringCharacter() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 39) {
	        s2 = peg$c75;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c76); }
	      }
	      if (s2 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s2 = peg$c77;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c78); }
	        }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        if (input.length > peg$currPos) {
	          s2 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c7); }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c79();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c82) {
	          s0 = peg$c82;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c83); }
	        }
	      }

	      return s0;
	    }

	    function peg$parseTextNode() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      if (peg$c84.test(input.charAt(peg$currPos))) {
	        s2 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c85); }
	      }
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          if (peg$c84.test(input.charAt(peg$currPos))) {
	            s2 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c85); }
	          }
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c86();
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseName() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      if (peg$c87.test(input.charAt(peg$currPos))) {
	        s2 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c88); }
	      }
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          if (peg$c87.test(input.charAt(peg$currPos))) {
	            s2 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c88); }
	          }
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c79();
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parse_() {
	      var s0, s1;

	      s0 = [];
	      if (peg$c89.test(input.charAt(peg$currPos))) {
	        s1 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c90); }
	      }
	      while (s1 !== peg$FAILED) {
	        s0.push(s1);
	        if (peg$c89.test(input.charAt(peg$currPos))) {
	          s1 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c90); }
	        }
	      }

	      return s0;
	    }



	    const {
	      MarkupTextExpression,
	      HTMLScriptExpression,
	      MarkupCommentExpression,
	      MarkupElementExpression,
	      MarkupAttributeExpression,
	      MarkupFragmentExpression,
	    } = __webpack_require__(251);


	    peg$result = peg$startRuleFunction();

	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail(peg$endExpectation());
	      }

	      throw peg$buildStructuredError(
	        peg$maxFailExpected,
	        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
	        peg$maxFailPos < input.length
	          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
	          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
	      );
	    }
	  }

	  return {
	    SyntaxError: peg$SyntaxError,
	    parse:       peg$parse
	  };
	})();

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	(function (MarkupExpressionKind) {
	    MarkupExpressionKind[MarkupExpressionKind["FRAGMENT"] = 1] = "FRAGMENT";
	    MarkupExpressionKind[MarkupExpressionKind["ATTRIBUTE"] = 2] = "ATTRIBUTE";
	    MarkupExpressionKind[MarkupExpressionKind["ELEMENT"] = 3] = "ELEMENT";
	    MarkupExpressionKind[MarkupExpressionKind["TEXT"] = 4] = "TEXT";
	    MarkupExpressionKind[MarkupExpressionKind["COMMENT"] = 5] = "COMMENT";
	})(exports.MarkupExpressionKind || (exports.MarkupExpressionKind = {}));
	var MarkupExpressionKind = exports.MarkupExpressionKind;
	function serializeMarkupExpression(expression) {
	    return expression.accept({
	        visitAttribute({ kind, name, value, location }) {
	            return { kind, name, value, location };
	        },
	        visitComment({ kind, nodeValue, location }) {
	            return { kind, nodeValue, location };
	        },
	        visitDocumentFragment({ kind, childNodes, location }) {
	            return { kind, location, childNodes: childNodes.map(child => child.accept(this)) };
	        },
	        visitText({ kind, nodeValue, location }) {
	            return { kind, nodeValue, location };
	        },
	        visitElement({ kind, attributes, childNodes, location }) {
	            return { kind, location, attribute: attributes.map(attribute => attribute.accept(this)), childNodes: childNodes.map(child => child.accept(this)) };
	        }
	    });
	}
	exports.serializeMarkupExpression = serializeMarkupExpression;
	function deserializeMarkupExpression(data) {
	    switch (data.kind) {
	        case MarkupExpressionKind.ATTRIBUTE: return new MarkupAttributeExpression(data.name, data.value, data.location);
	        case MarkupExpressionKind.COMMENT: return new MarkupCommentExpression(data.nodeValue, data.location);
	        case MarkupExpressionKind.TEXT: return new MarkupTextExpression(data.nodeValue, data.location);
	        case MarkupExpressionKind.FRAGMENT: return new MarkupFragmentExpression(data.childNodes.map(deserializeMarkupExpression), data.location);
	        case MarkupExpressionKind.ELEMENT: return new MarkupElementExpression(data.nodeName, data.attributes.map(deserializeMarkupExpression), data.childNodes.map(deserializeMarkupExpression), data.location);
	    }
	}
	exports.deserializeMarkupExpression = deserializeMarkupExpression;
	function traverseMarkupExpression(target, each) {
	    target.accept({
	        visitAttribute: each,
	        visitComment: each,
	        visitDocumentFragment(fragment) {
	            for (const child of fragment.childNodes) {
	                if (each(child) === false)
	                    return;
	                child.accept(this);
	            }
	        },
	        visitElement(element) {
	            for (const child of element.attributes) {
	                if (each(child) === false)
	                    break;
	            }
	            for (const child of element.childNodes) {
	                if (each(child) === false)
	                    break;
	                child.accept(this);
	            }
	        },
	        visitText: each
	    });
	}
	exports.traverseMarkupExpression = traverseMarkupExpression;
	function findMarkupExpression(target, filter) {
	    let found;
	    traverseMarkupExpression(target, (expression) => {
	        if (filter(expression)) {
	            found = expression;
	            return false;
	        }
	    });
	    return found;
	}
	exports.findMarkupExpression = findMarkupExpression;
	class MarkupExpression extends common_1.BaseExpression {
	    constructor(location) {
	        super(location);
	    }
	}
	exports.MarkupExpression = MarkupExpression;
	class MarkupNodeExpression extends MarkupExpression {
	    constructor(nodeName, location) {
	        super(location);
	        this.nodeName = nodeName;
	    }
	}
	exports.MarkupNodeExpression = MarkupNodeExpression;
	class MarkupContainerExpression extends MarkupNodeExpression {
	    constructor(name, childNodes, location) {
	        super(name, location);
	        this.childNodes = childNodes;
	        childNodes.forEach((child) => child.parent = this);
	    }
	    removeChild(child) {
	        const i = this.childNodes.indexOf(child);
	        if (i !== -1) {
	            child.parent = undefined;
	            this.childNodes.splice(i, 1);
	        }
	    }
	    appendChild(child) {
	        this.childNodes.push(child);
	    }
	    insertBefore(child, referenceNode) {
	        const index = this.childNodes.indexOf(referenceNode);
	        this.childNodes.splice(index, 0, child);
	    }
	    replaceChild(newChild, oldChild) {
	        const index = this.childNodes.indexOf(oldChild);
	        this.childNodes.splice(index, 1, newChild);
	    }
	}
	exports.MarkupContainerExpression = MarkupContainerExpression;
	class MarkupFragmentExpression extends MarkupContainerExpression {
	    constructor(childNodes, location) {
	        super("#document-fragment", childNodes, location);
	        this.kind = MarkupExpressionKind.FRAGMENT;
	    }
	    accept(visitor) {
	        return visitor.visitDocumentFragment(this);
	    }
	    clone() {
	        return new MarkupFragmentExpression(this.childNodes.map((child) => child.clone()), common_1.cloneSourceLocation(this.location));
	    }
	}
	exports.MarkupFragmentExpression = MarkupFragmentExpression;
	/**
	 * Markup
	 */
	class MarkupElementExpression extends MarkupContainerExpression {
	    constructor(name, attributes, childNodes, location) {
	        super(name, childNodes, location);
	        this.attributes = attributes;
	        this.kind = MarkupExpressionKind.ELEMENT;
	        attributes.forEach((attribute) => attribute.parent = this);
	    }
	    getAttribute(name) {
	        for (const attribute of this.attributes) {
	            if (attribute.name === name)
	                return attribute.value;
	        }
	    }
	    setAttribute(name, newValue, newIndex) {
	        let attribute;
	        let i = 0;
	        for (; i < this.attributes.length; i++) {
	            attribute = this.attributes[i];
	            if (attribute.name === name) {
	                attribute.value = newValue;
	                break;
	            }
	        }
	        if (i === this.attributes.length) {
	            this.attributes.push(attribute = new MarkupAttributeExpression(name, newValue, null));
	        }
	        if (newIndex != null && newIndex !== i) {
	            this.attributes.splice(i, 1);
	            this.attributes.splice(newIndex, 0, attribute);
	        }
	    }
	    removeAttribute(name) {
	        for (let i = this.attributes.length; i--;) {
	            const attribute = this.attributes[i];
	            // there may be multiple instances in the expression, so remove all occurences.
	            if (attribute.name === name) {
	                this.attributes.splice(i, 1);
	            }
	        }
	    }
	    accept(visitor) {
	        return visitor.visitElement(this);
	    }
	    clone() {
	        return new MarkupElementExpression(this.nodeName, this.attributes.map((child) => child.clone()), this.childNodes.map((child) => child.clone()), common_1.cloneSourceLocation(this.location));
	    }
	}
	exports.MarkupElementExpression = MarkupElementExpression;
	class MarkupAttributeExpression extends MarkupExpression {
	    constructor(name, value, location) {
	        super(location);
	        this.name = name;
	        this.value = value;
	        this.kind = MarkupExpressionKind.ATTRIBUTE;
	    }
	    accept(visitor) {
	        return visitor.visitAttribute(this);
	    }
	    clone() {
	        return new MarkupAttributeExpression(this.name, this.value, common_1.cloneSourceLocation(this.location));
	    }
	}
	exports.MarkupAttributeExpression = MarkupAttributeExpression;
	class MarkupTextExpression extends MarkupNodeExpression {
	    constructor(nodeValue, location) {
	        super("#text", location);
	        this.nodeValue = nodeValue;
	        this.kind = MarkupExpressionKind.TEXT;
	    }
	    accept(visitor) {
	        return visitor.visitText(this);
	    }
	    clone() {
	        return new MarkupTextExpression(this.nodeValue, common_1.cloneSourceLocation(this.location));
	    }
	}
	exports.MarkupTextExpression = MarkupTextExpression;
	class MarkupCommentExpression extends MarkupNodeExpression {
	    constructor(nodeValue, location) {
	        super("#comment", location);
	        this.nodeValue = nodeValue;
	        this.kind = MarkupExpressionKind.COMMENT;
	    }
	    accept(visitor) {
	        return visitor.visitComment(this);
	    }
	    clone() {
	        return new MarkupCommentExpression(this.nodeValue, common_1.cloneSourceLocation(this.location));
	    }
	}
	exports.MarkupCommentExpression = MarkupCommentExpression;


/***/ },
/* 252 */
/***/ function(module, exports) {

	"use strict";
	// TODO - this needs to be async
	function evaluateMarkup(expression, doc, namespaceURI, module, parentContainer) {
	    function linkSourceInfo(expression, synthetic) {
	        synthetic.$module = module;
	        synthetic.$source = {
	            kind: expression.kind,
	            filePath: module && module.source.filePath,
	            start: expression.location.start,
	            end: expression.location.end
	        };
	        return synthetic;
	    }
	    function appendChildNodes(container, expression) {
	        for (let i = 0, n = expression.childNodes.length; i < n; i++) {
	            const child = evaluateMarkup(expression.childNodes[i], doc, namespaceURI, module, container);
	            child.$createdCallback();
	        }
	    }
	    return expression.accept({
	        visitAttribute(expression) {
	            return { name: expression.name, value: expression.value };
	        },
	        visitComment(expression) {
	            const node = linkSourceInfo(expression, doc.createComment(expression.nodeValue));
	            linkSourceInfo(expression, node);
	            parentContainer.appendChild(node);
	            return node;
	        },
	        visitElement(expression) {
	            const xmlns = expression.getAttribute("xmlns") || namespaceURI || doc.defaultNamespaceURI;
	            // bypass $createdCallback executed by document
	            const elementClass = doc.$getElementClassNS(xmlns, expression.nodeName);
	            const element = new elementClass(xmlns, expression.nodeName);
	            element.$setOwnerDocument(doc);
	            parentContainer.appendChild(element);
	            for (let i = 0, n = expression.attributes.length; i < n; i++) {
	                const attributeExpression = expression.attributes[i];
	                const attribute = attributeExpression.accept(this);
	                element.setAttribute(attribute.name, attribute.value);
	            }
	            linkSourceInfo(expression, element);
	            appendChildNodes(element, expression);
	            return element;
	        },
	        visitDocumentFragment(expression) {
	            let container;
	            if (!expression.parent && parentContainer) {
	                container = parentContainer;
	            }
	            else {
	                container = doc.createDocumentFragment();
	                linkSourceInfo(expression, container);
	            }
	            appendChildNodes(container, expression);
	            if (container !== parentContainer) {
	                container.$createdCallback();
	            }
	            return container;
	        },
	        visitText(expression) {
	            const node = doc.createTextNode(expression.nodeValue);
	            linkSourceInfo(expression, node);
	            parentContainer.appendChild(node);
	            return node;
	        }
	    });
	}
	exports.evaluateMarkup = evaluateMarkup;


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const lodash_1 = __webpack_require__(56);
	function formatMarkupExpression(node, defaultIndentation = "  ") {
	    const indentation = defaultIndentation;
	    function format(current, level = 0) {
	        function indent() {
	            return lodash_1.repeat(indentation, level);
	        }
	        return current.accept({
	            visitAttribute(attribute) {
	                return ` ${attribute.name}="${attribute.value}"`;
	            },
	            visitElement(element) {
	                let buffer = indent() + `<${element.nodeName}${element.attributes.map((attribute) => format(attribute)).join("")}>`;
	                if (element.childNodes.length) {
	                    buffer += "\n" + element.childNodes.map((child) => format(child, level + 1)).join("\n") + "\n" + indent();
	                }
	                buffer += `</${element.nodeName}>`;
	                return buffer;
	            },
	            visitComment(comment) {
	                return indent() + `<!--${comment.nodeValue}-->`;
	            },
	            visitDocumentFragment(fragment) {
	                return fragment.childNodes.map((child) => format(child, level)).join("\n");
	            },
	            visitText(text) {
	                return indent() + text.nodeValue.trim();
	            }
	        });
	    }
	    return format(node, 0);
	}
	exports.formatMarkupExpression = formatMarkupExpression;


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const element_1 = __webpack_require__(242);
	const common_1 = __webpack_require__(46);
	// TODO - possibly move this over to @tandem/common/display or similar
	class VisibleDOMNodeCapabilities {
	    constructor(movable, resizable) {
	        this.movable = movable;
	        this.resizable = resizable;
	    }
	    merge(...capabilities) {
	        return VisibleDOMNodeCapabilities.merge(this, ...capabilities);
	    }
	    static notCapableOfAnything() {
	        return new VisibleDOMNodeCapabilities(false, false);
	    }
	    static merge(...capabilities) {
	        return capabilities.reduce((a, b) => (new VisibleDOMNodeCapabilities(a ? a.movable && b.movable : b.movable, b ? a.resizable && b.resizable : b.resizable)));
	    }
	}
	exports.VisibleDOMNodeCapabilities = VisibleDOMNodeCapabilities;
	class VisibleSyntheticDOMElement extends element_1.SyntheticDOMElement {
	    get renderer() {
	        return this.browser.renderer;
	    }
	    getComputedStyle() {
	        return this.renderer.getComputedStyle(this.uid);
	    }
	    getBoundingClientRect() {
	        return this.renderer.getBoundingRect(this.uid);
	    }
	    getAbsoluteBounds() {
	        if (!this.computeVisibility())
	            return common_1.BoundingRect.zeros();
	        return this._absoluteBounds;
	    }
	    getCapabilities() {
	        if (!this.computeVisibility())
	            return VisibleDOMNodeCapabilities.notCapableOfAnything();
	        return this._capabilities;
	    }
	    computeVisibility() {
	        const newStyle = this.getComputedStyle();
	        const newBounds = this.getBoundingClientRect();
	        if (!newStyle || !newBounds.visible) {
	            this._computedStyle = undefined;
	            this._currentBounds = undefined;
	            return this._computedVisibility = false;
	        }
	        if (this._computedVisibility) {
	            if (this._currentBounds.equalTo(newBounds) && this._computedStyle.uid === newStyle.uid) {
	                return true;
	            }
	        }
	        this._computedStyle = newStyle;
	        this._currentBounds = newBounds;
	        this._absoluteBounds = this.computeAbsoluteBounds(this._computedStyle, this._currentBounds);
	        this._capabilities = this.computeCapabilities(this._computedStyle);
	        return this._computedVisibility = true;
	    }
	}
	__decorate([
	    common_1.bindable()
	], VisibleSyntheticDOMElement.prototype, "_absoluteBounds", void 0);
	__decorate([
	    common_1.bindable()
	], VisibleSyntheticDOMElement.prototype, "_capabilities", void 0);
	exports.VisibleSyntheticDOMElement = VisibleSyntheticDOMElement;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const element_1 = __webpack_require__(242);
	const container_1 = __webpack_require__(232);
	const value_node_1 = __webpack_require__(245);
	const document_1 = __webpack_require__(230);
	function isDOMNodeMutation(mutation) {
	    return element_1.isDOMElementMutation(mutation) || container_1.isDOMContainerMutation(mutation) || value_node_1.isDOMValueNodeMutation(mutation) || document_1.isDOMDocumentMutation(mutation);
	}
	exports.isDOMNodeMutation = isDOMNodeMutation;


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(257));


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const css_1 = __webpack_require__(258);
	const common_1 = __webpack_require__(46);
	const markup_1 = __webpack_require__(231);
	class ElementClassList extends Array {
	    constructor(target) {
	        super(...String(target.getAttribute("class") || "").split(" "));
	        this.target = target;
	    }
	    add(value) {
	        this.push(value);
	        this._reset();
	    }
	    remove(value) {
	        const index = this.indexOf(value);
	        if (index !== -1)
	            this.splice(index, 1);
	        this._reset();
	    }
	    _reset() {
	        this.target.setAttribute("className", this.join(" "));
	    }
	}
	// TODO - proxy dataset
	let SyntheticHTMLElement = class SyntheticHTMLElement extends markup_1.VisibleSyntheticDOMElement {
	    constructor(ns, tagName) {
	        super(ns, tagName);
	        this._style = new css_1.SyntheticCSSStyle();
	    }
	    getClientRects() {
	        return [common_1.BoundingRect.zeros()];
	    }
	    getBoundingClientRect() {
	        return (this.browser && this.browser.renderer.getBoundingRect(this.uid)) || common_1.BoundingRect.zeros();
	    }
	    get classList() {
	        return this._classList;
	    }
	    get style() {
	        return this._styleProxy || this._resetStyleProxy();
	    }
	    get text() {
	        return this.getAttribute("text");
	    }
	    focus() {
	        // TODO - possibly set activeElement on synthetic document
	    }
	    blur() {
	        // TODO
	    }
	    get className() {
	        return this.class;
	    }
	    set className(value) {
	        this.class = value;
	    }
	    get class() {
	        return this.getAttribute("class") || "";
	    }
	    set class(value) {
	        this.setAttribute("class", value);
	    }
	    set text(value) {
	        this.setAttribute("text", value);
	    }
	    set style(value) {
	        this._style.clearAll();
	        Object.assign(this._style, value);
	        this.onStyleChange();
	    }
	    attributeChangedCallback(name, oldValue, newValue) {
	        if (name === "style") {
	            this._resetStyleFromAttribute();
	        }
	        else if (name === "class") {
	            this._classList = new ElementClassList(this);
	        }
	        super.attributeChangedCallback(name, oldValue, newValue);
	    }
	    get innerHTML() {
	        return this.childNodes.map((child) => child.toString()).join("");
	    }
	    get outerHTML() {
	        return this.toString();
	    }
	    set innerHTML(value) {
	        this.removeAllChildren();
	        this.appendChild(markup_1.evaluateMarkup(markup_1.parseMarkup(value), this.ownerDocument, this.namespaceURI));
	    }
	    _resetStyleFromAttribute() {
	        this._style.clearAll();
	        Object.assign(this._style, css_1.SyntheticCSSStyle.fromString(this.getAttribute("style") || ""));
	    }
	    _resetStyleProxy() {
	        // Proxy the style here so that any changes get synchronized back
	        // to the attribute
	        // element.
	        return this._styleProxy = new Proxy(this._style, {
	            get: (target, propertyName, receiver) => {
	                return target[propertyName];
	            },
	            set: (target, propertyName, value, receiver) => {
	                // normalize the value if it's a pixel unit. Numbers are invalid for CSS declarations.
	                if (typeof value === "number") {
	                    value = Math.round(value) + "px";
	                }
	                target.setProperty(propertyName.toString(), value);
	                this.onStyleChange();
	                return true;
	            }
	        });
	    }
	    onStyleChange() {
	        this.setAttribute("style", this.style.cssText.replace(/[\n\t\s]+/g, " "));
	    }
	    computeCapabilities(style) {
	        return new markup_1.VisibleDOMNodeCapabilities(/fixed|absolute/.test(style.position), /fixed|absolute/.test(style.position));
	    }
	    computeAbsoluteBounds(style) {
	        return this.getBoundingClientRect();
	    }
	    setAbsolutePosition({ left, top }) {
	        // const oldBounds = this.getAbsoluteBounds();
	        Object.assign(this.style, {
	            left: left,
	            top: top
	        });
	    }
	    setAbsoluteBounds(newBounds) {
	        // const oldBounds = this.getAbsoluteBounds();
	        Object.assign(this.style, {
	            left: newBounds.left,
	            top: newBounds.top,
	            width: newBounds.width,
	            height: newBounds.height
	        });
	    }
	};
	SyntheticHTMLElement = __decorate([
	    common_1.serializable()
	], SyntheticHTMLElement);
	exports.SyntheticHTMLElement = SyntheticHTMLElement;


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(259));
	__export(__webpack_require__(262));
	__export(__webpack_require__(266));
	__export(__webpack_require__(260));
	__export(__webpack_require__(270));
	__export(__webpack_require__(273));
	__export(__webpack_require__(271));
	__export(__webpack_require__(264));
	__export(__webpack_require__(261));
	__export(__webpack_require__(268));
	__export(__webpack_require__(265));
	__export(__webpack_require__(274));
	__export(__webpack_require__(269));


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const sift = __webpack_require__(43);
	const lodash_1 = __webpack_require__(56);
	const style_rule_1 = __webpack_require__(260);
	const common_1 = __webpack_require__(46);
	const sandbox_1 = __webpack_require__(167);
	exports.isValidCSSDeclarationProperty = sift({ $and: [{ $ne: /^[\$_]/ }, { $ne: "uid" }, { $ne: /^\d+$/ }] });
	// https://www.w3.org/TR/CSS21/propidx.html
	exports.INHERITED_CSS_STYLE_PROPERTIES = [
	    "azimuth",
	    "borderCollapse",
	    "borderSpacing",
	    "captionSide",
	    "color",
	    "cursor",
	    "direction",
	    "elevation",
	    "emptyCells",
	    "fontFamily",
	    "fontSize",
	    "fontStyle",
	    "fontVariant",
	    "fontWeight",
	    "font",
	    "letterSpacing",
	    "lineHeight",
	    "listStyleImage",
	    "listStylePosition",
	    "listStyleType",
	    "listStyle",
	    "orphans",
	    "pitchRange",
	    "pitch",
	    "quotes",
	    "richness",
	    "speakHeader",
	    "speakNumeral",
	    "speakPunctuation",
	    "speak",
	    "speechRate",
	    "stress",
	    "textAlign",
	    "textIndent",
	    "textDecoration",
	    "textTransform",
	    "visibility",
	    "voiceFamily",
	    "volume",
	    "whiteSpace",
	    "widows",
	    "wordSpacing"
	];
	function isInheritedCSSStyleProperty(name) {
	    return exports.INHERITED_CSS_STYLE_PROPERTIES.indexOf(name) !== -1;
	}
	exports.isInheritedCSSStyleProperty = isInheritedCSSStyleProperty;
	let SyntheticCSSStyle_1 = class SyntheticCSSStyle {
	    constructor() {
	        this.$source = null;
	        this[Symbol.iterator] = function* () {
	            for (let i = 0, n = this.length || 0; i < n; i++) {
	                yield this[i];
	            }
	        };
	        this.$uid = sandbox_1.generateSyntheticUID();
	    }
	    clone() {
	        const clone = new SyntheticCSSStyle_1();
	        clone.deserialize(this);
	        clone.$uid = this.$uid;
	        return clone;
	    }
	    get length() {
	        return this.$length || 0;
	    }
	    item(index) {
	        return this[index];
	    }
	    getProperties() {
	        return [...this];
	    }
	    get uid() {
	        return this.$uid;
	    }
	    getPropertyIndex(name) {
	        return this.getProperties().indexOf(name);
	    }
	    removeProperty(name, notifyOwnerNode) {
	        this.setProperty(name, undefined, undefined, undefined, notifyOwnerNode);
	    }
	    getPropertyValue(name) {
	        const value = this[name];
	        return value && value.split(/\s*\!important/)[0];
	    }
	    getPropertyPriority(name) {
	        const value = this[name];
	        return value && value.indexOf("!important") !== -1 ? "important" : "";
	    }
	    setProperty(name, newValue, priority, oldName, notifyOwnerNode = true) {
	        if (!exports.isValidCSSDeclarationProperty(name))
	            return false;
	        // fix in case they"re kebab case
	        name = lodash_1.camelCase(name);
	        oldName = oldName != null ? lodash_1.camelCase(oldName) : oldName;
	        let index = oldName ? this.getPropertyIndex(oldName) : this.getPropertyIndex(name);
	        // ensure that internal keys are not set
	        if (!/^\$/.test(name)) {
	            this[~index ? index : this.length] = name;
	        }
	        if (name != null) {
	            this[name] = newValue;
	        }
	        if (oldName != null) {
	            this[oldName] = undefined;
	        }
	        this.updatePropertyIndices();
	        if (notifyOwnerNode !== true)
	            return;
	        // I"m not a fan of sending notifications from another object like this -- I"d typically make this
	        // object an observable, and notify changes from here. However, since this particular class is used so often, sending
	        // notifications from here would be put a notable bottleneck on the app. So, instead we"re notifying the owner of this node (typically the
	        // root document). Less ideal, but achieves the same result of notifying the system of any changes to the synthetic document.
	        const ownerNode = this.$parentRule && this.$parentRule.ownerNode;
	        if (ownerNode) {
	            ownerNode.notify(new common_1.PropertyMutation(style_rule_1.SyntheticCSSElementStyleRuleMutationTypes.SET_DECLARATION, this.$parentRule, name, newValue, undefined, oldName).toEvent(true));
	        }
	    }
	    updatePropertyIndices() {
	        const model = {};
	        for (let i = 0; i < this.length; i++) {
	            const key = this[i];
	            const value = this[key];
	            if (value != null) {
	                model[key] = value;
	            }
	            // reset for now
	            this[i] = undefined;
	        }
	        for (const key in this) {
	            if (!exports.isValidCSSDeclarationProperty(key))
	                continue;
	            if (this[key] == null)
	                continue;
	            model[key] = this[key];
	        }
	        let i = 0;
	        for (const key in model) {
	            this[i++] = key;
	        }
	        this.$length = Object.keys(model).length;
	    }
	    equalTo(declaration) {
	        function compare(a, b) {
	            for (const key in a) {
	                if (!exports.isValidCSSDeclarationProperty(key))
	                    continue;
	                if (a[key] !== b[key]) {
	                    return false;
	                }
	            }
	            return true;
	        }
	        return compare(this, declaration) && compare(declaration, this);
	    }
	    get parentRule() {
	        return this.$parentRule;
	    }
	    get cssText() {
	        const buffer = [];
	        for (const key in this) {
	            if (!exports.isValidCSSDeclarationProperty(key))
	                continue;
	            const value = this[key];
	            if (value) {
	                buffer.push("\t", lodash_1.kebabCase(key), ": ", value, ";\n");
	            }
	        }
	        return buffer.join("");
	    }
	    set cssText(value) {
	        console.warn("cssText setter not currently functional for SyntheticStyleRule");
	    }
	    toString() {
	        return this.cssText;
	    }
	    serialize() {
	        const obj = {};
	        for (const key in this) {
	            const value = this[key];
	            if (typeof value === "object")
	                continue;
	            obj[key] = value;
	        }
	        return obj;
	    }
	    deserialize(value) {
	        Object.assign(this, value);
	        this.updatePropertyIndices();
	    }
	    clearAll() {
	        for (const key of this) {
	            this[key] = undefined;
	        }
	        this.updatePropertyIndices();
	    }
	    static fromString(source) {
	        const decl = new SyntheticCSSStyle_1();
	        const items = source.split(";");
	        for (let i = 0, n = items.length; i < n; i++) {
	            const expr = items[i];
	            const [name, value] = expr.split(":");
	            if (!name || !value)
	                continue;
	            decl[lodash_1.camelCase(name.trim())] = value.trim();
	        }
	        decl.updatePropertyIndices();
	        return decl;
	    }
	    static fromObject(declaration) {
	        const obj = new SyntheticCSSStyle_1();
	        if (declaration.length) {
	            for (let i = 0, n = declaration.length; i < n; i++) {
	                const key = declaration[i];
	                obj[key] = declaration[key];
	            }
	            obj.updatePropertyIndices();
	        }
	        else {
	            obj.deserialize(declaration);
	        }
	        return obj;
	    }
	    toObject() {
	        const obj = {};
	        for (const key in this) {
	            if (!exports.isValidCSSDeclarationProperty(key))
	                continue;
	            if (this[key] == null)
	                continue;
	            obj[key] = this[key];
	        }
	        return obj;
	    }
	    visitWalker(walker) { }
	};
	let SyntheticCSSStyle = SyntheticCSSStyle_1;
	SyntheticCSSStyle = SyntheticCSSStyle_1 = __decorate([
	    common_1.serializable()
	], SyntheticCSSStyle);
	exports.SyntheticCSSStyle = SyntheticCSSStyle;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const lodash_1 = __webpack_require__(56);
	const mesh_1 = __webpack_require__(13);
	const synthetic_browser_1 = __webpack_require__(216);
	const sandbox_1 = __webpack_require__(167);
	const style_1 = __webpack_require__(259);
	const base_1 = __webpack_require__(261);
	const common_1 = __webpack_require__(46);
	var SyntheticCSSStyleRuleMutationTypes;
	(function (SyntheticCSSStyleRuleMutationTypes) {
	    SyntheticCSSStyleRuleMutationTypes.SET_DECLARATION = "setDeclaration";
	})(SyntheticCSSStyleRuleMutationTypes = exports.SyntheticCSSStyleRuleMutationTypes || (exports.SyntheticCSSStyleRuleMutationTypes = {}));
	function isCSSStyleRuleMutation(mutation) {
	    return !!{
	        [SyntheticCSSStyleRuleMutationTypes.SET_DECLARATION]: true
	    }[mutation.type];
	}
	exports.isCSSStyleRuleMutation = isCSSStyleRuleMutation;
	// TODO - move this to synthetic-browser
	class SyntheticCSSStyleRuleEdit extends base_1.SyntheticCSSObjectEdit {
	    setDeclaration(name, value, oldName, index) {
	        return this.addChange(new common_1.PropertyMutation(SyntheticCSSStyleRuleMutationTypes.SET_DECLARATION, this.target, name, value, undefined, oldName, index));
	    }
	    addDiff(newRule) {
	        super.addDiff(newRule);
	        const oldKeys = Object.keys(this.target.style).filter(style_1.isValidCSSDeclarationProperty);
	        const newKeys = Object.keys(newRule.style).filter(style_1.isValidCSSDeclarationProperty);
	        common_1.diffArray(oldKeys, newKeys, (a, b) => {
	            return a === b ? 0 : -1;
	        }).accept({
	            visitInsert: ({ value, index }) => {
	                this.setDeclaration(value, newRule.style[value], undefined, index);
	            },
	            visitRemove: ({ index }) => {
	                // don't apply a move edit if the value doesn't exist.
	                if (this.target.style[oldKeys[index]]) {
	                    this.setDeclaration(oldKeys[index], undefined);
	                }
	            },
	            visitUpdate: ({ originalOldIndex, newValue, index }) => {
	                if (this.target.style[newValue] !== newRule.style[newValue]) {
	                    this.setDeclaration(newValue, newRule.style[newValue], undefined, index);
	                }
	            }
	        });
	        return this;
	    }
	}
	exports.SyntheticCSSStyleRuleEdit = SyntheticCSSStyleRuleEdit;
	class CSSStyleRuleEditor extends sandbox_1.BaseEditor {
	    applySingleMutation(mutation) {
	        if (mutation.type === SyntheticCSSStyleRuleMutationTypes.SET_DECLARATION) {
	            const { name, newValue, oldName } = mutation;
	            this.target.style.setProperty(lodash_1.kebabCase(name), newValue);
	            if (newValue == null) {
	                this.target.style.removeProperty(name);
	            }
	            if (oldName) {
	                this.target.style.removeProperty(oldName);
	            }
	        }
	    }
	}
	exports.CSSStyleRuleEditor = CSSStyleRuleEditor;
	class SyntheticCSSStyleRuleEditor extends sandbox_1.BaseEditor {
	    applyMutations(mutations) {
	        super.applyMutations(mutations);
	        new base_1.SyntheticCSSObjectEditor(this.target).applyMutations(mutations);
	        new CSSStyleRuleEditor(this.target).applyMutations(mutations);
	    }
	}
	exports.SyntheticCSSStyleRuleEditor = SyntheticCSSStyleRuleEditor;
	class SyntheticCSSStyleRule extends base_1.SyntheticCSSObject {
	    constructor(style) {
	        super();
	        this.style = style;
	        if (!style)
	            style = this.style = new style_1.SyntheticCSSStyle();
	        style.$parentRule = this;
	    }
	    get metadata() {
	        if (this._metadata)
	            return this._metadata;
	        this._metadata = new common_1.Metadata();
	        this._metadata.observe(this._metadataObserver = new mesh_1.CallbackDispatcher(this._onMetadataEvent.bind(this)));
	        return this._metadata;
	    }
	    createEdit() {
	        return new SyntheticCSSStyleRuleEdit(this);
	    }
	    toString() {
	        return this.cssText;
	    }
	    createEditor() {
	        return new SyntheticCSSStyleRuleEditor(this);
	    }
	    visitWalker(walker) {
	        walker.accept(this.style);
	    }
	    _onMetadataEvent(event) {
	        const ownerNode = this.$ownerNode || (this.$parentStyleSheet && this.$parentStyleSheet.$ownerNode);
	        if (ownerNode)
	            ownerNode.notify(event);
	    }
	}
	exports.SyntheticCSSStyleRule = SyntheticCSSStyleRule;
	var SyntheticCSSElementStyleRuleMutationTypes;
	(function (SyntheticCSSElementStyleRuleMutationTypes) {
	    SyntheticCSSElementStyleRuleMutationTypes.SET_DECLARATION = SyntheticCSSStyleRuleMutationTypes.SET_DECLARATION;
	    SyntheticCSSElementStyleRuleMutationTypes.SET_RULE_SELECTOR = "setRuleSelector";
	})(SyntheticCSSElementStyleRuleMutationTypes = exports.SyntheticCSSElementStyleRuleMutationTypes || (exports.SyntheticCSSElementStyleRuleMutationTypes = {}));
	function isCSSSElementtyleRuleMutation(mutation) {
	    return isCSSStyleRuleMutation(mutation) || !!{
	        [SyntheticCSSElementStyleRuleMutationTypes.SET_RULE_SELECTOR]: true
	    }[mutation.type];
	}
	exports.isCSSSElementtyleRuleMutation = isCSSSElementtyleRuleMutation;
	class SyntheticCSSElementStyleRuleEdit extends SyntheticCSSStyleRuleEdit {
	    setSelector(selector) {
	        return this.addChange(new common_1.SetValueMutation(SyntheticCSSElementStyleRuleMutationTypes.SET_RULE_SELECTOR, this.target, selector));
	    }
	    addDiff(newRule) {
	        super.addDiff(newRule);
	        if (this.target.selector !== newRule.selector) {
	            this.setSelector(newRule.selector);
	        }
	        return this;
	    }
	}
	exports.SyntheticCSSElementStyleRuleEdit = SyntheticCSSElementStyleRuleEdit;
	class SyntheticCSSElementStyleRuleSerializer {
	    serialize(value) {
	        return {
	            selector: value.selector,
	            style: common_1.serialize(value.style)
	        };
	    }
	    deserialize(value, injector) {
	        return new SyntheticCSSElementStyleRule(value.selector, common_1.deserialize(value.style, injector));
	    }
	}
	let SyntheticCSSElementStyleRule_1 = class SyntheticCSSElementStyleRule extends SyntheticCSSStyleRule {
	    constructor(selector, style) {
	        super(style);
	        this.selector = selector;
	    }
	    get cssText() {
	        return `${this.selector} {\n${this.style.cssText}}\n`;
	    }
	    createEdit() {
	        return new SyntheticCSSElementStyleRuleEdit(this);
	    }
	    cloneShallow() {
	        return new SyntheticCSSElementStyleRule_1(this.selector, undefined);
	    }
	    matchesElement(element) {
	        return synthetic_browser_1.getSelectorTester(this.selector).test(element);
	    }
	    countShallowDiffs(target) {
	        return this.selector === target.selector ? 0 : -1;
	    }
	};
	let SyntheticCSSElementStyleRule = SyntheticCSSElementStyleRule_1;
	SyntheticCSSElementStyleRule = SyntheticCSSElementStyleRule_1 = __decorate([
	    common_1.serializable(new base_1.SyntheticCSSObjectSerializer(new SyntheticCSSElementStyleRuleSerializer()))
	], SyntheticCSSElementStyleRule);
	exports.SyntheticCSSElementStyleRule = SyntheticCSSElementStyleRule;


/***/ },
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	const sandbox_1 = __webpack_require__(167);
	class SyntheticCSSObjectEdit extends sandbox_1.SyntheticObjectEdit {
	}
	exports.SyntheticCSSObjectEdit = SyntheticCSSObjectEdit;
	class SyntheticCSSObjectEditor extends sandbox_1.SyntheticObjectEditor {
	}
	exports.SyntheticCSSObjectEditor = SyntheticCSSObjectEditor;
	class SyntheticCSSObject {
	    constructor() {
	        this.$uid = sandbox_1.generateSyntheticUID();
	    }
	    get parentStyleSheet() {
	        return this.$parentStyleSheet || this.$parentRule && this.$parentRule.parentStyleSheet;
	    }
	    get ownerNode() {
	        return this.$ownerNode || this.$parentRule && this.$parentRule.ownerNode || this.$parentStyleSheet && this.$parentStyleSheet.ownerNode;
	    }
	    get parentRule() {
	        return this.$parentRule;
	    }
	    get uid() {
	        return this.$uid;
	    }
	    get source() {
	        return this.$source;
	    }
	    clone(deep) {
	        if (deep)
	            return common_1.deserialize(common_1.serialize(this), null);
	        return this.$linkClone(this.cloneShallow());
	    }
	    $linkClone(clone) {
	        clone.$source = this.$source;
	        clone.$uid = this.$uid;
	        return clone;
	    }
	}
	exports.SyntheticCSSObject = SyntheticCSSObject;
	exports.SyntheticCSSObjectSerializer = sandbox_1.SyntheticObjectSerializer;


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const sm = __webpack_require__(263);
	const lodash_1 = __webpack_require__(56);
	const lodash_2 = __webpack_require__(56);
	const atrule_1 = __webpack_require__(264);
	const font_face_1 = __webpack_require__(269);
	const style_rule_1 = __webpack_require__(260);
	const media_rule_1 = __webpack_require__(270);
	const style_sheet_1 = __webpack_require__(271);
	const keyframes_rule_1 = __webpack_require__(273);
	const style_1 = __webpack_require__(259);
	function evaluateCSS(expression, map, module) {
	    const dependency = module && module.source;
	    const sourceMapConsumer = map && new sm.SourceMapConsumer(map);
	    function getStyleDeclaration(rules) {
	        const obj = {};
	        for (let i = 0, n = rules.length; i < n; i++) {
	            const decl = rules[i];
	            if (!decl.value)
	                continue;
	            // Priority level is not part of the value in regular CSSStyleDeclaration instances. We're
	            // Adding it here because it's faster for the app, and easier to work with (for now).
	            obj[lodash_2.camelCase(decl.prop)] = decl.value + (decl.important ? " !important" : "");
	        }
	        return style_1.SyntheticCSSStyle.fromObject(obj);
	    }
	    function link(expression, synthetic) {
	        let filePath = dependency && dependency.filePath;
	        let start = expression.source.start;
	        let end = expression.source.end;
	        if (sourceMapConsumer) {
	            const originalPosition = sourceMapConsumer.originalPositionFor({
	                line: start.line,
	                column: start.column
	            });
	            start = {
	                line: originalPosition.line,
	                // Bad. Fixes Discrepancy between postcss & source-map source information.
	                // There's also an issue with sass and at rules when inlining styles (which isn't covered here). For example
	                // @media { body { color: red; }} will produce incorrect source maps
	                column: originalPosition.column + 1
	            };
	            filePath = originalPosition.source;
	            end = undefined;
	        }
	        synthetic.$source = {
	            kind: expression.type,
	            // todo - this may not be correct.
	            filePath: filePath,
	            start: start,
	            end: end
	        };
	        return synthetic;
	    }
	    const visitor = {
	        visitRoot(root) {
	            const ret = link(root, new style_sheet_1.SyntheticCSSStyleSheet(acceptAll(root.nodes)));
	            return ret;
	        },
	        visitAtRule(atRule) {
	            if (atRule.name === "keyframes") {
	                return link(atRule, new keyframes_rule_1.SyntheticCSSKeyframesRule(atRule.params, acceptAll(atRule.nodes)));
	            }
	            else if (atRule.name === "media") {
	                return link(atRule, new media_rule_1.SyntheticCSSMediaRule([atRule.params], acceptAll(atRule.nodes)));
	            }
	            else if (atRule.name === "font-face") {
	                return link(atRule, new font_face_1.SyntheticCSSFontFace(getStyleDeclaration(atRule.nodes)));
	            }
	            return link(atRule, new atrule_1.SyntheticCSSUnknownGroupAtRule(atRule.name, atRule.params, acceptAll(atRule.nodes)));
	        },
	        visitComment(comment) {
	            return null;
	        },
	        visitDeclaration(declaration) {
	            return null;
	        },
	        visitRule(rule) {
	            return link(rule, new style_rule_1.SyntheticCSSElementStyleRule(rule.selector, getStyleDeclaration(rule.nodes)));
	        }
	    };
	    function acceptAll(nodes) {
	        return lodash_1.without((nodes || []).map((child) => accept(child)), null);
	    }
	    function accept(expression) {
	        switch (expression.type) {
	            case "root": return visitor.visitRoot(expression);
	            case "rule": return visitor.visitRule(expression);
	            case "atrule": return visitor.visitAtRule(expression);
	            case "comment": return visitor.visitComment(expression);
	            case "decl": return visitor.visitDeclaration(expression);
	        }
	    }
	    return accept(expression);
	}
	exports.evaluateCSS = evaluateCSS;


/***/ },
/* 263 */
/***/ function(module, exports) {

	module.exports = require("source-map");

/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const grouping_1 = __webpack_require__(265);
	const base_1 = __webpack_require__(261);
	const common_1 = __webpack_require__(46);
	var SyntheticCSSGroupAtRuleMutationTypes;
	(function (SyntheticCSSGroupAtRuleMutationTypes) {
	    SyntheticCSSGroupAtRuleMutationTypes.SET_NAME_EDIT = "setNameEdit";
	})(SyntheticCSSGroupAtRuleMutationTypes = exports.SyntheticCSSGroupAtRuleMutationTypes || (exports.SyntheticCSSGroupAtRuleMutationTypes = {}));
	function isCSSAtRuleMutaton(mutation) {
	    return !!{
	        [SyntheticCSSGroupAtRuleMutationTypes.SET_NAME_EDIT]: true
	    }[mutation.type];
	}
	exports.isCSSAtRuleMutaton = isCSSAtRuleMutaton;
	class SyntheticCSSGroupAtRuleEdit extends grouping_1.SyntheticCSSGroupingRuleEdit {
	}
	exports.SyntheticCSSGroupAtRuleEdit = SyntheticCSSGroupAtRuleEdit;
	class SyntheticCSSGroupAtRuleEditor extends grouping_1.SyntheticCSSGroupingRuleEditor {
	}
	exports.SyntheticCSSGroupAtRuleEditor = SyntheticCSSGroupAtRuleEditor;
	class SyntheticCSSGroupAtRule extends grouping_1.SyntheticCSSGroupingRule {
	    constructor(cssRules = []) {
	        super(cssRules);
	    }
	    toString() {
	        return this.cssText;
	    }
	    get innerText() {
	        return this.cssRules.map(rule => rule.cssText).join("\n");
	    }
	    countShallowDiffs(target) {
	        return this.params === target.params ? 0 : -1;
	    }
	    visitWalker(walker) {
	        this.cssRules.forEach(rule => walker.accept(rule));
	    }
	}
	exports.SyntheticCSSGroupAtRule = SyntheticCSSGroupAtRule;
	class SyntheticCSSUnknownAtRuleSerializer {
	    serialize({ atRuleName, params, cssRules }) {
	        return {
	            atRuleName: atRuleName,
	            params: params,
	            cssRules: cssRules.map(common_1.serialize)
	        };
	    }
	    deserialize({ atRuleName, params, cssRules }, injector) {
	        return new SyntheticCSSUnknownGroupAtRule(atRuleName, params, cssRules.map((cs) => common_1.deserialize(cs, injector)));
	    }
	}
	let SyntheticCSSUnknownGroupAtRule_1 = class SyntheticCSSUnknownGroupAtRule extends SyntheticCSSGroupAtRule {
	    constructor(atRuleName, params, cssRules = []) {
	        super(cssRules);
	        this.atRuleName = atRuleName;
	        this.params = params;
	    }
	    get cssText() {
	        return `@${this.atRuleName} ${this.params} {\n${this.innerText} }`;
	    }
	    cloneShallow() {
	        return new SyntheticCSSUnknownGroupAtRule_1(this.atRuleName, this.params);
	    }
	};
	let SyntheticCSSUnknownGroupAtRule = SyntheticCSSUnknownGroupAtRule_1;
	SyntheticCSSUnknownGroupAtRule = SyntheticCSSUnknownGroupAtRule_1 = __decorate([
	    common_1.serializable(new base_1.SyntheticCSSObjectSerializer(new SyntheticCSSUnknownAtRuleSerializer()))
	], SyntheticCSSUnknownGroupAtRule);
	exports.SyntheticCSSUnknownGroupAtRule = SyntheticCSSUnknownGroupAtRule;


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	const parsers_1 = __webpack_require__(266);
	const utils_1 = __webpack_require__(268);
	const sandbox_1 = __webpack_require__(167);
	const evaluate_1 = __webpack_require__(262);
	const base_1 = __webpack_require__(261);
	var CSSGroupingRuleMutationTypes;
	(function (CSSGroupingRuleMutationTypes) {
	    CSSGroupingRuleMutationTypes.INSERT_RULE_EDIT = "insertRuleEdit";
	    CSSGroupingRuleMutationTypes.REMOVE_RULE_EDIT = "removeRuleEdit";
	    CSSGroupingRuleMutationTypes.MOVE_RULE_EDIT = "moveRuleEdit";
	})(CSSGroupingRuleMutationTypes = exports.CSSGroupingRuleMutationTypes || (exports.CSSGroupingRuleMutationTypes = {}));
	class SyntheticCSSGroupingRuleEdit extends base_1.SyntheticCSSObjectEdit {
	    insertRule(rule, index) {
	        return this.addChange(new common_1.InsertChildMutation(CSSGroupingRuleMutationTypes.INSERT_RULE_EDIT, this.target, rule.clone(true), index));
	    }
	    moveRule(rule, index, patchedOldIndex) {
	        return this.addChange(new common_1.MoveChildMutation(CSSGroupingRuleMutationTypes.MOVE_RULE_EDIT, this.target, rule.clone(true), patchedOldIndex || this.target.rules.indexOf(rule), index));
	    }
	    removeRule(rule) {
	        return this.addChange(new common_1.RemoveChildMutation(CSSGroupingRuleMutationTypes.REMOVE_RULE_EDIT, this.target, rule, this.target.rules.indexOf(rule)));
	    }
	    addDiff(groupingRule) {
	        super.addDiff(groupingRule);
	        utils_1.diffStyleSheetRules(this.target.rules, groupingRule.rules).accept({
	            visitInsert: ({ index, value }) => {
	                this.insertRule(value, index);
	            },
	            visitRemove: ({ index }) => {
	                this.removeRule(this.target.rules[index]);
	            },
	            visitUpdate: ({ originalOldIndex, patchedOldIndex, newValue, index }) => {
	                if (patchedOldIndex !== index) {
	                    this.moveRule(this.target.rules[originalOldIndex], index, patchedOldIndex);
	                }
	                const oldRule = this.target.rules[originalOldIndex];
	                this.addChildEdit(oldRule.createEdit().fromDiff(newValue));
	            }
	        });
	        return this;
	    }
	}
	exports.SyntheticCSSGroupingRuleEdit = SyntheticCSSGroupingRuleEdit;
	function isCSSGroupingStyleMutation(mutation) {
	    return !!{
	        [CSSGroupingRuleMutationTypes.INSERT_RULE_EDIT]: true,
	        [CSSGroupingRuleMutationTypes.REMOVE_RULE_EDIT]: true,
	        [CSSGroupingRuleMutationTypes.MOVE_RULE_EDIT]: true
	    }[mutation.type];
	}
	exports.isCSSGroupingStyleMutation = isCSSGroupingStyleMutation;
	class CSSGroupingRuleEditor extends sandbox_1.BaseEditor {
	    constructor(target, createInsertableCSSRule = (parent, child) => child.cssText, onInsertedChild, onDeletedChild) {
	        super(target);
	        this.target = target;
	        this.createInsertableCSSRule = createInsertableCSSRule;
	        this.onInsertedChild = onInsertedChild;
	        this.onDeletedChild = onDeletedChild;
	    }
	    applySingleMutation(mutation) {
	        if (mutation.type === CSSGroupingRuleMutationTypes.INSERT_RULE_EDIT) {
	            const { child, index } = mutation;
	            this.target.insertRule(this.createInsertableCSSRule(this.target, child), index);
	            if (this.onInsertedChild)
	                this.onInsertedChild(child, index);
	        }
	        else if (mutation.type === CSSGroupingRuleMutationTypes.REMOVE_RULE_EDIT) {
	            const { child, index } = mutation;
	            this.target.deleteRule(index);
	            if (this.onDeletedChild)
	                this.onDeletedChild(child, index);
	        }
	        else if (mutation.type === CSSGroupingRuleMutationTypes.MOVE_RULE_EDIT) {
	            const { oldIndex, child, index } = mutation;
	            const existingChild = this.target.cssRules[oldIndex];
	            this.target.deleteRule(oldIndex);
	            // TODO - move the existing instance -- don't just create a new one
	            this.target.insertRule(this.createInsertableCSSRule(this.target, existingChild), index);
	            if (this.onInsertedChild)
	                this.onInsertedChild(existingChild, index);
	        }
	    }
	}
	exports.CSSGroupingRuleEditor = CSSGroupingRuleEditor;
	class SyntheticCSSGroupingRuleEditor extends sandbox_1.BaseEditor {
	    applyMutations(mutations) {
	        new CSSGroupingRuleEditor(this.target, (parent, child) => {
	            return child.$parentRule === parent ? child : child.clone(true);
	        }).applyMutations(mutations);
	        new base_1.SyntheticCSSObjectEditor(this.target).applyMutations(mutations);
	    }
	}
	exports.SyntheticCSSGroupingRuleEditor = SyntheticCSSGroupingRuleEditor;
	class SyntheticCSSGroupingRule extends base_1.SyntheticCSSObject {
	    constructor(rules = []) {
	        super();
	        this.rules = rules;
	        rules.forEach((rule) => this.linkRule(rule));
	    }
	    get cssRules() {
	        return this.rules;
	    }
	    deleteRule(index) {
	        const rule = this.cssRules[index];
	        this.cssRules.splice(index, 1);
	        const owner = this.ownerNode;
	        if (owner)
	            owner.notify(new common_1.RemoveChildMutation(CSSGroupingRuleMutationTypes.REMOVE_RULE_EDIT, this, rule, index).toEvent());
	    }
	    createEditor() {
	        return new SyntheticCSSGroupingRuleEditor(this);
	    }
	    createEdit() {
	        return new SyntheticCSSGroupingRuleEdit(this);
	    }
	    insertRule(rule, index) {
	        const ruleInstance = typeof rule === "string" ? evaluate_1.evaluateCSS(parsers_1.parseCSS(rule)).rules[0] : rule;
	        if (index == undefined) {
	            index = this.rules.length;
	        }
	        this.rules.splice(index, 0, ruleInstance);
	        this.linkRule(ruleInstance);
	        const owner = this.ownerNode;
	        if (owner)
	            owner.notify(new common_1.InsertChildMutation(CSSGroupingRuleMutationTypes.INSERT_RULE_EDIT, this, ruleInstance, index).toEvent());
	        return index;
	    }
	    linkRule(rule) {
	        rule.$parentRule = this;
	    }
	}
	exports.SyntheticCSSGroupingRule = SyntheticCSSGroupingRule;


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const postcss = __webpack_require__(267);
	// TODO - cache source here for a bit 
	function parseCSS(source, map, syntax, useCache) {
	    return postcss().process(source, {
	        syntax: syntax,
	        map: map && {
	            prev: map
	        }
	    }).root;
	}
	exports.parseCSS = parseCSS;


/***/ },
/* 267 */
/***/ function(module, exports) {

	module.exports = require("postcss");

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const node_types_1 = __webpack_require__(233);
	const common_1 = __webpack_require__(46);
	const grouping_1 = __webpack_require__(265);
	const atrule_1 = __webpack_require__(264);
	const style_rule_1 = __webpack_require__(260);
	function diffStyleSheetRules(oldRules, newRules) {
	    return common_1.diffArray(oldRules, newRules, (oldRule, newRule) => {
	        if (oldRule.constructor.name !== newRule.constructor.name)
	            return -1;
	        return oldRule.countShallowDiffs(newRule);
	    });
	}
	exports.diffStyleSheetRules = diffStyleSheetRules;
	class MatchedCSSStyleRule {
	    constructor(target, rule, overriddenStyleProperties, inherited) {
	        this.target = target;
	        this.rule = rule;
	        this.overriddenStyleProperties = overriddenStyleProperties;
	        this.inherited = inherited;
	    }
	}
	exports.MatchedCSSStyleRule = MatchedCSSStyleRule;
	function eachMatchingStyleRule(element, each, filter) {
	    if (!filter)
	        filter = () => true;
	    for (let i = element.ownerDocument.styleSheets.length; i--;) {
	        const styleSheet = element.ownerDocument.styleSheets[i];
	        for (let j = styleSheet.rules.length; j--;) {
	            const rule = styleSheet.rules[j];
	            if (!(rule instanceof style_rule_1.SyntheticCSSElementStyleRule) || !filter(rule) || !rule.matchesElement(element))
	                continue;
	            each(rule);
	        }
	    }
	}
	exports.eachMatchingStyleRule = eachMatchingStyleRule;
	function eachInheritedMatchingStyleRule(element, each, filter) {
	    if (!filter)
	        filter = () => true;
	    const visited = {};
	    const run = (current) => {
	        if (current.nodeType !== node_types_1.DOMNodeType.ELEMENT)
	            return;
	        if (current.style) {
	            each(current, current);
	        }
	        eachMatchingStyleRule(current, (rule) => {
	            visited[rule.uid] = true;
	            each(current, rule);
	        }, (rule) => !visited[rule.uid]);
	    };
	    run(element);
	    element.ancestors.forEach(run);
	}
	exports.eachInheritedMatchingStyleRule = eachInheritedMatchingStyleRule;
	function getMatchingCSSStyleRules(target) {
	    const visited = {};
	    const usedStyles = {};
	    const matches = [];
	    eachInheritedMatchingStyleRule(target, (current, rule) => {
	        const inherited = current !== target;
	        const overriddenStyleProperties = {};
	        for (const property of rule.style) {
	            if (usedStyles[property]) {
	                overriddenStyleProperties[property] = true;
	            }
	            else {
	                usedStyles[property] = true;
	            }
	        }
	        matches.push(new MatchedCSSStyleRule(current, rule, overriddenStyleProperties, inherited));
	    });
	    return matches;
	}
	exports.getMatchingCSSStyleRules = getMatchingCSSStyleRules;
	function isCSSMutation(mutation) {
	    return grouping_1.isCSSGroupingStyleMutation(mutation) || style_rule_1.isCSSStyleRuleMutation(mutation) || atrule_1.isCSSAtRuleMutaton(mutation);
	}
	exports.isCSSMutation = isCSSMutation;
	function getCSSFontFaceRules(element) {
	    const ownerDocument = element.ownerDocument;
	    const fontFaces = [];
	    const used = {};
	    for (let i = ownerDocument.styleSheets.length; i--;) {
	        const styleSheet = ownerDocument.styleSheets[i];
	        for (let j = styleSheet.rules.length; j--;) {
	            const rule = styleSheet.rules[j];
	            if (rule["atRuleName"] && rule.atRuleName === "font-face") {
	                const fontFamily = String(rule.style.fontFamily);
	                if (used[fontFamily])
	                    continue;
	                used[fontFamily] = true;
	                fontFaces.push(rule);
	            }
	        }
	    }
	    return fontFaces;
	}
	exports.getCSSFontFaceRules = getCSSFontFaceRules;


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const style_rule_1 = __webpack_require__(260);
	const style_1 = __webpack_require__(259);
	const base_1 = __webpack_require__(261);
	const common_1 = __webpack_require__(46);
	class SyntheticCSSFontFaceSerializer {
	    serialize({ style }) {
	        return {
	            style: common_1.serialize(style)
	        };
	    }
	    deserialize({ style }, injector) {
	        return new SyntheticCSSFontFace(common_1.deserialize(style, injector));
	    }
	}
	let SyntheticCSSFontFace_1 = class SyntheticCSSFontFace extends style_rule_1.SyntheticCSSStyleRule {
	    constructor(style) {
	        super(style);
	        this.atRuleName = "font-face";
	    }
	    get params() {
	        return "";
	    }
	    get cssText() {
	        return `@font-face {
	      ${this.style.cssText}
	    }`;
	    }
	    cloneShallow() {
	        return new SyntheticCSSFontFace_1(new style_1.SyntheticCSSStyle());
	    }
	    countShallowDiffs(target) {
	        return this.cssText === target.cssText ? 0 : -1;
	    }
	};
	let SyntheticCSSFontFace = SyntheticCSSFontFace_1;
	SyntheticCSSFontFace = SyntheticCSSFontFace_1 = __decorate([
	    common_1.serializable(new base_1.SyntheticCSSObjectSerializer(new SyntheticCSSFontFaceSerializer()))
	], SyntheticCSSFontFace);
	exports.SyntheticCSSFontFace = SyntheticCSSFontFace;


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const base_1 = __webpack_require__(261);
	const common_1 = __webpack_require__(46);
	const atrule_1 = __webpack_require__(264);
	class SyntheticCSSMediaRuleSerializer {
	    serialize({ media, cssRules }) {
	        return {
	            media: media,
	            cssRules: cssRules.map(common_1.serialize)
	        };
	    }
	    deserialize({ media, cssRules }, injector) {
	        return new SyntheticCSSMediaRule(media, cssRules.map((cs) => common_1.deserialize(cs, injector)));
	    }
	}
	let SyntheticCSSMediaRule_1 = class SyntheticCSSMediaRule extends atrule_1.SyntheticCSSGroupAtRule {
	    constructor(media, rules) {
	        super(rules);
	        this.media = media;
	        this.atRuleName = "media";
	    }
	    get cssText() {
	        return `@media ${this.media.join(" ")} {\n${this.innerText}}\n`;
	    }
	    get params() {
	        return this.media.join(" ");
	    }
	    cloneShallow() {
	        return new SyntheticCSSMediaRule_1(this.media.concat(), []);
	    }
	    createEdit() {
	        return new atrule_1.SyntheticCSSGroupAtRuleEdit(this);
	    }
	    visitWalker(walker) {
	        this.cssRules.forEach(rule => walker.accept(rule));
	    }
	};
	let SyntheticCSSMediaRule = SyntheticCSSMediaRule_1;
	SyntheticCSSMediaRule = SyntheticCSSMediaRule_1 = __decorate([
	    common_1.serializable(new base_1.SyntheticCSSObjectSerializer(new SyntheticCSSMediaRuleSerializer()))
	], SyntheticCSSMediaRule);
	exports.SyntheticCSSMediaRule = SyntheticCSSMediaRule;


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const abab_1 = __webpack_require__(272);
	const css_1 = __webpack_require__(258);
	const grouping_1 = __webpack_require__(265);
	const base_1 = __webpack_require__(261);
	const common_1 = __webpack_require__(46);
	const utils_1 = __webpack_require__(268);
	class SyntheticCSSStyleSheetSerializer {
	    serialize(value) {
	        return {
	            rules: value.rules.map(common_1.serialize)
	        };
	    }
	    deserialize(value, injector) {
	        return new SyntheticCSSStyleSheet(value.rules.map(raw => common_1.deserialize(raw, injector)));
	    }
	}
	class CSSStyleSheetEditor extends grouping_1.SyntheticCSSGroupingRuleEditor {
	}
	exports.CSSStyleSheetEditor = CSSStyleSheetEditor;
	let _smcache = {};
	function parseSourceMaps(value) {
	    if (String(value).indexOf("sourceMappingURL=data") == -1)
	        return undefined;
	    if (_smcache[value])
	        return _smcache[value];
	    const sourceMappingURL = String(value).match(/sourceMappingURL=(data\:[^\s]+)/)[1];
	    // assuming that it's inlined here... shouldn't.
	    return _smcache[value] = JSON.parse(abab_1.atob(sourceMappingURL.split(",").pop()));
	}
	setInterval(() => _smcache = {}, 1000 * 60);
	let SyntheticCSSStyleSheet_1 = class SyntheticCSSStyleSheet extends grouping_1.SyntheticCSSGroupingRule {
	    constructor(rules) {
	        super(rules);
	        this.rules = rules;
	    }
	    linkRule(rule) {
	        super.linkRule(rule);
	        rule.$parentStyleSheet = this;
	    }
	    set cssText(value) {
	        let map = parseSourceMaps(value);
	        this
	            .createEdit()
	            .fromDiff(css_1.evaluateCSS(css_1.parseCSS(value, map), map))
	            .applyMutationsTo(this);
	    }
	    addImport(bstrURL, lIndex) {
	        // TODO -
	        return -1;
	    }
	    get cssText() {
	        return this.rules.map((rule) => rule.cssText).join("\n");
	    }
	    toString() {
	        return this.cssText;
	    }
	    countShallowDiffs(target) {
	        // This condition won't work as well for cases where the stylesheet is defined
	        // by some other code such as <style /> blocks. It *will* probably break if the source
	        // that instantiated this SyntheticCSSStyleSheet instance maintains a reference to it. Though, that's
	        // a totally different problem that needs to be resolved.
	        if (target.source.filePath === this.source.filePath)
	            return 0;
	        return utils_1.diffStyleSheetRules(this.rules, target.rules).count;
	    }
	    cloneShallow() {
	        return new SyntheticCSSStyleSheet_1([]);
	    }
	    visitWalker(walker) {
	        this.rules.forEach((rule) => walker.accept(rule));
	    }
	};
	let SyntheticCSSStyleSheet = SyntheticCSSStyleSheet_1;
	SyntheticCSSStyleSheet = SyntheticCSSStyleSheet_1 = __decorate([
	    common_1.serializable(new base_1.SyntheticCSSObjectSerializer(new SyntheticCSSStyleSheetSerializer()))
	], SyntheticCSSStyleSheet);
	exports.SyntheticCSSStyleSheet = SyntheticCSSStyleSheet;


/***/ },
/* 272 */
/***/ function(module, exports) {

	module.exports = require("abab");

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const base_1 = __webpack_require__(261);
	const common_1 = __webpack_require__(46);
	const atrule_1 = __webpack_require__(264);
	class SyntheticCSSKeyframesRuleSerializer {
	    serialize({ name, cssRules }) {
	        return {
	            name: name,
	            cssRules: cssRules.map(common_1.serialize)
	        };
	    }
	    deserialize({ name, cssRules }, injector) {
	        return new SyntheticCSSKeyframesRule(name, cssRules.map((cs) => common_1.deserialize(cs, injector)));
	    }
	}
	class SyntheticCSSKeyframesRuleEdit extends atrule_1.SyntheticCSSGroupAtRuleEdit {
	    setName(value) {
	        this.addChange(new common_1.PropertyMutation(atrule_1.SyntheticCSSGroupAtRuleMutationTypes.SET_NAME_EDIT, this.target, "name", value));
	    }
	    addDiff(newAtRule) {
	        if (this.target.name !== newAtRule.name) {
	            this.setName(newAtRule.name);
	        }
	        return super.addDiff(newAtRule);
	    }
	}
	exports.SyntheticCSSKeyframesRuleEdit = SyntheticCSSKeyframesRuleEdit;
	let SyntheticCSSKeyframesRule_1 = class SyntheticCSSKeyframesRule extends atrule_1.SyntheticCSSGroupAtRule {
	    constructor(name, rules) {
	        super(rules);
	        this.name = name;
	        this.atRuleName = "keyframes";
	    }
	    get params() {
	        return this.name;
	    }
	    get cssText() {
	        return `@keyframes ${this.name} {
	      ${this.innerText}
	    }`;
	    }
	    cloneShallow() {
	        return new SyntheticCSSKeyframesRule_1(this.name, []);
	    }
	    createEdit() {
	        return new SyntheticCSSKeyframesRuleEdit(this);
	    }
	    visitWalker(walker) {
	        this.cssRules.forEach(rule => walker.accept(rule));
	    }
	};
	let SyntheticCSSKeyframesRule = SyntheticCSSKeyframesRule_1;
	SyntheticCSSKeyframesRule = SyntheticCSSKeyframesRule_1 = __decorate([
	    common_1.serializable(new base_1.SyntheticCSSObjectSerializer(new SyntheticCSSKeyframesRuleSerializer()))
	], SyntheticCSSKeyframesRule);
	exports.SyntheticCSSKeyframesRule = SyntheticCSSKeyframesRule;


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * The data model for style declarations
	 */
	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const lodash_1 = __webpack_require__(56);
	const style_1 = __webpack_require__(259);
	const common_1 = __webpack_require__(46);
	const declaration_1 = __webpack_require__(275);
	__export(__webpack_require__(275));
	class SyntheticCSSStylePosition {
	    constructor(left, top) {
	        this.left = left;
	        this.top = top;
	    }
	    toString() {
	        if (this.left.value === 0.5 && this.top.value === 0.5) {
	            return "center";
	        }
	    }
	}
	exports.SyntheticCSSStylePosition = SyntheticCSSStylePosition;
	// blend modes: http://www.w3schools.com/cssref/pr_background-blend-mode.asp
	function isCSSBlendMode(blendMode) {
	    return /^(normal|multiply|screen|overlay|darken|lighten|color-dodge|saturation|color|luminosity)/.test(blendMode);
	}
	exports.isCSSBlendMode = isCSSBlendMode;
	function isCSSClipType(clip) {
	    return /^(border-box|padding-box|content-box|initial|inherit|text)/.test(clip);
	}
	exports.isCSSClipType = isCSSClipType;
	class SyntheticCSSStyleBackground extends common_1.Observable {
	    constructor(properties) {
	        super();
	        if (properties)
	            this.setProperties(properties);
	    }
	    setPosition(value) {
	        if (value[0] === "center") {
	            this.position = new SyntheticCSSStylePosition(new declaration_1.SyntheticCSSMeasurment(0.5, "%"), new declaration_1.SyntheticCSSMeasurment(0.5, "%"));
	        }
	    }
	    setProperties(properties) {
	        let color, clip, image, blendMode, position = [], repeat;
	        for (const value of properties) {
	            if (typeof value === "object") {
	                if (value instanceof declaration_1.SyntheticCSSColor) {
	                    color = value;
	                }
	            }
	            else if (/^(left|top|right|bottom|center)$/.test(value)) {
	                position.push(value);
	            }
	            else if (/repeat/.test(value)) {
	                repeat = value;
	            }
	            else if (isCSSBlendMode(value)) {
	                blendMode = value;
	            }
	            else if (isCSSClipType(value)) {
	                clip = value;
	            }
	            else {
	                image = value;
	            }
	        }
	        if (color)
	            this.color = color;
	        if (image)
	            this.image = image;
	        if (position.length)
	            this.setPosition(position);
	        if (repeat)
	            this.repeat = repeat;
	        if (blendMode)
	            this.blendMode = blendMode;
	        if (clip)
	            this.clip = clip;
	    }
	    setProperty(name, value) {
	        this[name] = evaluateCSSDeclValue2(value, name)[0];
	    }
	    toString() {
	        const params = [];
	        if (this.color)
	            params.push(this.color);
	        if (this.image)
	            params.push(this.image);
	        if (this.position)
	            params.push(this.position);
	        if (this.repeat)
	            params.push(this.repeat);
	        return params.join(" ");
	    }
	}
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSStyleBackground.prototype, "color", void 0);
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSStyleBackground.prototype, "image", void 0);
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSStyleBackground.prototype, "position", void 0);
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSStyleBackground.prototype, "repeat", void 0);
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSStyleBackground.prototype, "size", void 0);
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSStyleBackground.prototype, "blendMode", void 0);
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSStyleBackground.prototype, "clip", void 0);
	exports.SyntheticCSSStyleBackground = SyntheticCSSStyleBackground;
	function evaluateCSSDeclValue2(value, property) {
	    try {
	        value = declaration_1.evaluateCSSDeclValue(declaration_1.parseCSSDeclValue(value));
	    }
	    catch (e) {
	        // console.warn(String(value), e.stack.toString());
	        value = [value];
	    }
	    return property && isUnitBasedCSSProperty(property) ? value.map(declaration_1.SyntheticCSSMeasurment.cast) : value;
	}
	class SyntheticCSSBox extends common_1.Observable {
	    setProperty(name, value) {
	        this[name] = evaluateCSSDeclValue2(value, name)[0];
	    }
	    get width() {
	        return [this.topWidth, this.rightWidth, this.bottomWidth, this.leftWidth];
	    }
	    set width(params) {
	        if (params.length !== 4) {
	            this.leftWidth = params[1].clone();
	            this.rightWidth = params[1].clone();
	            this.topWidth = params[0].clone();
	            this.bottomWidth = params[0].clone();
	        }
	        else {
	            [this.topWidth, this.rightWidth, this.bottomWidth, this.leftWidth] = params;
	        }
	    }
	    getStyleProperties() {
	        if (String(this.leftWidth) === String(this.rightWidth) && String(this.topWidth) === String(this.bottomWidth)) {
	            return `${this.topWidth || 0} ${this.rightWidth || 0}`;
	        }
	        else {
	            return `${this.topWidth || 0} ${this.rightWidth || 0} ${this.bottomWidth || 0} ${this.leftWidth || 0}`;
	        }
	    }
	}
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSBox.prototype, "leftWidth", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSBox.prototype, "topWidth", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSBox.prototype, "rightWidth", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSBox.prototype, "bottomWidth", void 0);
	exports.SyntheticCSSBox = SyntheticCSSBox;
	class SyntheticCSSBorder extends SyntheticCSSBox {
	    get left() {
	        return this._getSideStyle("left");
	    }
	    set left(value) {
	        this._setSideStyle("left", value);
	    }
	    get top() {
	        return this._getSideStyle("top");
	    }
	    set top(value) {
	        this._setSideStyle("top", value);
	    }
	    get right() {
	        return this._getSideStyle("right");
	    }
	    set right(value) {
	        this._setSideStyle("right", value);
	    }
	    get bottom() {
	        return this._getSideStyle("bottom");
	    }
	    set width(value) {
	        this.leftWidth = value && value.clone();
	        this.topWidth = value && value.clone();
	        this.rightWidth = value && value.clone();
	        this.bottomWidth = value && value.clone();
	    }
	    set color(value) {
	        this.leftColor = value && value.clone();
	        this.topColor = value && value.clone();
	        this.rightColor = value && value.clone();
	        this.bottomColor = value && value.clone();
	    }
	    set style(value) {
	        this.leftStyle = value;
	        this.topStyle = value;
	        this.rightStyle = value;
	        this.bottomStyle = value;
	    }
	    set bottom(value) {
	        this._setSideStyle("bottom", value);
	    }
	    _getSideStyle(side) {
	        return [this[`${side}Width`], this[`${side}Color`], this[`${side}Style`]];
	    }
	    _setSideStyle(side, value) {
	        [this[`${side}Width`], this[`${side}Color`], this[`${side}Style`]] = this._sortParams(value);
	    }
	    setProperties(value) {
	        [this.width, this.color, this.style] = this._sortParams(value);
	    }
	    _sortParams(params) {
	        const ret = [];
	        while (params.length) {
	            const v = params.shift();
	            if (v instanceof declaration_1.SyntheticCSSColor) {
	                ret[1] = v;
	            }
	            else if (v instanceof declaration_1.SyntheticCSSMeasurment) {
	                ret[0] = v;
	            }
	            else {
	                ret[2] = v;
	            }
	        }
	        return ret;
	    }
	}
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSBorder.prototype, "leftColor", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSBorder.prototype, "leftStyle", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSBorder.prototype, "topColor", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSBorder.prototype, "topStyle", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSBorder.prototype, "rightColor", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSBorder.prototype, "rightStyle", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSBorder.prototype, "bottomColor", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSBorder.prototype, "bottomStyle", void 0);
	exports.SyntheticCSSBorder = SyntheticCSSBorder;
	class SyntheticCSSStyleBoxShadow extends common_1.Observable {
	    constructor(properties) {
	        super();
	        if (properties)
	            this.setProperties(properties);
	    }
	    setProperties(properties) {
	        let color, inset, dims = [];
	        for (const value of properties) {
	            if (value instanceof declaration_1.SyntheticCSSMeasurment || typeof value === "number") {
	                dims.push(value);
	            }
	            else if (value instanceof declaration_1.SyntheticCSSColor) {
	                color = value;
	            }
	            else if (value === "inset") {
	                inset = true;
	            }
	        }
	        this.color = color;
	        this.inset = inset;
	        this.setProperty("x", dims[0]);
	        this.setProperty("y", dims[1]);
	        this.setProperty("blur", dims[2]);
	        this.setProperty("spread", dims[3]);
	    }
	    setProperty(name, value) {
	        this[name] = evaluateCSSDeclValue2(value, name)[0];
	    }
	    toString() {
	        let params = [];
	        if (this.inset) {
	            params.push("inset");
	        }
	        params.push(this.x, this.y, this.blur, this.spread, this.color);
	        return params.join(" ");
	    }
	}
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleBoxShadow.prototype, "inset", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleBoxShadow.prototype, "x", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleBoxShadow.prototype, "y", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleBoxShadow.prototype, "blur", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleBoxShadow.prototype, "spread", void 0);
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSStyleBoxShadow.prototype, "color", void 0);
	exports.SyntheticCSSStyleBoxShadow = SyntheticCSSStyleBoxShadow;
	function isUnitBasedCSSProperty(property) {
	    return /^(x|y|blur|spread|letterSpacing|fontSize|lineHeight|width|height|minWidth|minHeight|maxWidth|maxHeight|left|top|right|bottom)$/.test(property);
	}
	exports.isUnitBasedCSSProperty = isUnitBasedCSSProperty;
	class SyntheticCSSStyleGraphics extends common_1.Observable {
	    constructor(style) {
	        super();
	        this.style = style;
	        this.border = new SyntheticCSSBorder();
	        this.margin = new SyntheticCSSBox();
	        this.padding = new SyntheticCSSBox();
	        this.backgrounds = new common_1.ObservableCollection();
	        this.boxShadows = new common_1.ObservableCollection();
	        this.filters = new common_1.ObservableCollection();
	        this.fontFamily = [];
	        this.setProperties(style);
	    }
	    setProperties(style) {
	        for (const propertyName of style) {
	            this.setProperty(propertyName, style[propertyName]);
	        }
	    }
	    dispose() {
	        // nothing
	    }
	    setProperty(name, value) {
	        value = evaluateCSSDeclValue2(value, name);
	        const handlers = {
	            // border             : (value) => this.border.setProperties(value),
	            // borderLeft         : (value) => this.border.left = value,
	            // borderLeftWidth    : ([value]) => this.border.leftWidth = value,
	            // borderLeftColor    : ([value]) => this.border.leftColor = value,
	            // borderLeftStyle    : ([value]) => this.border.leftStyle = value,
	            // borderTop          : (value) => this.border.top = value,
	            // borderTopWidth     : ([value]) => this.border.topWidth = value,
	            // borderTopColor     : ([value]) => this.border.topColor = value,
	            // borderTopStyle     : ([value]) => this.border.topStyle = value,
	            // borderRight        : (value) => this.border.right = value,
	            // borderRightWidth   : ([value]) => this.border.rightWidth = value,
	            // borderRightColor   : ([value]) => this.border.rightColor = value,
	            // borderRightStyle   : ([value]) => this.border.rightStyle = value,
	            // borderBottom       : (value) => this.border.bottom = value,
	            // borderBottomtWidth : ([value]) => this.border.bottomWidth = value,
	            // borderBottomColor  : ([value]) => this.border.bottomColor = value,
	            // borderBottomStyle  : ([value]) => this.border.bottomStyle = value,
	            // borderWidth        : ([value]) => this.border.width = value,
	            // borderColor        : ([value]) => this.border.color = value,
	            // borderStyle        : ([value]) => this.border.style = value,
	            // margin             : (value) => this.margin.width = value,
	            // marginTop          : (value) => this.margin.topWidth = value.clone(),
	            // marginRight        : (value) => this.margin.rightWidth = value.clone(),
	            // marginBottom       : (value) => this.margin.bottomWidth = value.clone(),
	            // marginLeft         : (value) => this.margin.leftWidth = value.clone(),
	            // padding            : (value) => this.padding.width = value,
	            // paddingTop          : (value) => this.padding.topWidth = value.clone(),
	            // paddingRight        : (value) => this.padding.rightWidth = value.clone(),
	            // paddingBottom       : (value) => this.padding.bottomWidth = value.clone(),
	            // paddingLeft         : (value) => this.padding.leftWidth = value.clone(),
	            backgroundColor: ([value]) => this.primaryBackground.color = value,
	            backgroundRepeat: ([value]) => this.primaryBackground.repeat = value,
	            backgroundImage: ([value]) => this.primaryBackground.image = value,
	            backgroundPosition: (value) => this.primaryBackground.setPosition(value),
	            fontFamily: (value) => this.fontFamily = lodash_1.flattenDeep(value).map((value) => value),
	            opacity: ([value]) => this.opacity = value,
	            mixBlendMode: ([value]) => this.mixBlendMode = value,
	            filter: (value) => this.filters = new common_1.ObservableCollection(...value),
	            background: (value) => {
	                // check for background: #F60, #F0F
	                if (Array.isArray(value) && Array.isArray(value[0])) {
	                    for (const background of value) {
	                        this.addBackground(background);
	                    }
	                }
	                else {
	                    this.primaryBackground.setProperties(value);
	                }
	            },
	            boxShadow: (value) => {
	                if (!Array.isArray(value[0]))
	                    value = [value];
	                for (const v of value) {
	                    this.addBoxShadow(v);
	                }
	            }
	        };
	        const handler = handlers[name];
	        if (handler) {
	            handler(value);
	        }
	        else {
	            // set to a blank string to unset the value - null / undefined get ignored
	            this[name] = value[0];
	        }
	    }
	    get primaryBackground() {
	        return this.backgrounds.length ? this.backgrounds[0] : this.addBackground();
	    }
	    addBackground(params) {
	        const background = new SyntheticCSSStyleBackground(params);
	        this.backgrounds.push(background);
	        return background;
	    }
	    removeBackground(background) {
	        const index = this.backgrounds.indexOf(background);
	        if (index !== -1)
	            this.backgrounds.splice(index, 1);
	        return background;
	    }
	    addBoxShadow(params) {
	        const boxShadow = new SyntheticCSSStyleBoxShadow(params);
	        this.boxShadows.push(boxShadow);
	        return boxShadow;
	    }
	    addFilter(name, params = []) {
	        const filter = evaluateCSSDeclValue2(`${name}(${params.join(" ")})`)[0];
	        this.filters.push(filter);
	        return filter;
	    }
	    renameFilter(filter, newName) {
	        const newFilter = evaluateCSSDeclValue2(`${newName}(${filter.params.join(" ")})`)[0];
	        const index = this.filters.indexOf(filter);
	        if (index !== -1) {
	            this.filters.splice(index, 1, newFilter);
	        }
	        return filter;
	    }
	    removeFilter(filter) {
	        const index = this.filters.indexOf(filter);
	        if (index !== -1) {
	            this.filters.splice(index, 1);
	        }
	        return filter;
	    }
	    removeBoxShadow(boxShadow) {
	        const index = this.boxShadows.indexOf(boxShadow);
	        if (index !== -1)
	            this.boxShadows.splice(index, 1);
	        return boxShadow;
	    }
	    toStyle() {
	        const style = new style_1.SyntheticCSSStyle();
	        [
	            // Layout
	            ["width"],
	            ["height"],
	            ["display"],
	            ["position"],
	            ["minWidth"],
	            ["minHeight"],
	            ["maxWidth"],
	            ["maxHeight"],
	            ["left"],
	            ["top"],
	            ["right"],
	            ["bottom"],
	            ["overflow"],
	            ["float"],
	            // flex
	            ["flexDirection"],
	            ["order"],
	            ["flex-grow"],
	            ["flex-shrink"],
	            ["flex-wrap"],
	            ["flex-flow"],
	            ["justify-content"],
	            ["align-items"],
	            // Typography
	            ["fontFamily", "fontFamily", ", "],
	            ["fontWeight"],
	            ["textTransform"],
	            ["fontSize"],
	            ["fontStyle"],
	            ["color"],
	            ["letterSpacing"],
	            ["lineHeight"],
	            ["textAlign"],
	            ["wordWrap"],
	            ["textDecoration"],
	            ["whiteSpace"],
	            ["textOverflow"],
	            // Appearange
	            ["opacity"],
	            ["mixBlendMode"],
	            // Effects
	            ["backgrounds", "background", ", "],
	            ["boxShadows", "boxShadow", ", "],
	            ["filters", "filter", " "],
	        ].forEach(([propertyName, styleName, sep]) => {
	            const value = this[propertyName];
	            const exists = value != null && (!sep || value.length);
	            if (exists) {
	                style.setProperty(styleName || propertyName, String(sep ? value.join(sep) : value));
	            }
	        });
	        return style;
	    }
	}
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "backgrounds", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "boxShadows", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "filters", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "margin", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "border", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "padding", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "opacity", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "mixBlendMode", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "fontFamily", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "color", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "fontSize", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "fontWeight", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "letterSpacing", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "lineHeight", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "textAlign", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "wordWrap", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "textDecoration", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "textTransform", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "fontStyle", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "whiteSpace", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "textOverflow", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "width", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "height", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "left", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "top", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "right", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "bottom", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "overflow", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "minWidth", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "minHeight", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "maxWidth", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "maxHeight", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "position", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "display", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "flex", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "alignItems", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "justifyContent", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "flexFlow", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "flexWrap", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "flexDirection", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSStyleGraphics.prototype, "float", void 0);
	exports.SyntheticCSSStyleGraphics = SyntheticCSSStyleGraphics;


/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const { parse } = __webpack_require__(276);
	exports.parseCSSDeclValue = parse;
	__export(__webpack_require__(277));
	__export(__webpack_require__(278));


/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = /*
	 * Generated by PEG.js 0.10.0.
	 *
	 * http://pegjs.org/
	 */
	(function() {
	  "use strict";

	  function peg$subclass(child, parent) {
	    function ctor() { this.constructor = child; }
	    ctor.prototype = parent.prototype;
	    child.prototype = new ctor();
	  }

	  function peg$SyntaxError(message, expected, found, location) {
	    this.message  = message;
	    this.expected = expected;
	    this.found    = found;
	    this.location = location;
	    this.name     = "SyntaxError";

	    if (typeof Error.captureStackTrace === "function") {
	      Error.captureStackTrace(this, peg$SyntaxError);
	    }
	  }

	  peg$subclass(peg$SyntaxError, Error);

	  peg$SyntaxError.buildMessage = function(expected, found) {
	    var DESCRIBE_EXPECTATION_FNS = {
	          literal: function(expectation) {
	            return "\"" + literalEscape(expectation.text) + "\"";
	          },

	          "class": function(expectation) {
	            var escapedParts = "",
	                i;

	            for (i = 0; i < expectation.parts.length; i++) {
	              escapedParts += expectation.parts[i] instanceof Array
	                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
	                : classEscape(expectation.parts[i]);
	            }

	            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
	          },

	          any: function(expectation) {
	            return "any character";
	          },

	          end: function(expectation) {
	            return "end of input";
	          },

	          other: function(expectation) {
	            return expectation.description;
	          }
	        };

	    function hex(ch) {
	      return ch.charCodeAt(0).toString(16).toUpperCase();
	    }

	    function literalEscape(s) {
	      return s
	        .replace(/\\/g, '\\\\')
	        .replace(/"/g,  '\\"')
	        .replace(/\0/g, '\\0')
	        .replace(/\t/g, '\\t')
	        .replace(/\n/g, '\\n')
	        .replace(/\r/g, '\\r')
	        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
	        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
	    }

	    function classEscape(s) {
	      return s
	        .replace(/\\/g, '\\\\')
	        .replace(/\]/g, '\\]')
	        .replace(/\^/g, '\\^')
	        .replace(/-/g,  '\\-')
	        .replace(/\0/g, '\\0')
	        .replace(/\t/g, '\\t')
	        .replace(/\n/g, '\\n')
	        .replace(/\r/g, '\\r')
	        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
	        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
	    }

	    function describeExpectation(expectation) {
	      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
	    }

	    function describeExpected(expected) {
	      var descriptions = new Array(expected.length),
	          i, j;

	      for (i = 0; i < expected.length; i++) {
	        descriptions[i] = describeExpectation(expected[i]);
	      }

	      descriptions.sort();

	      if (descriptions.length > 0) {
	        for (i = 1, j = 1; i < descriptions.length; i++) {
	          if (descriptions[i - 1] !== descriptions[i]) {
	            descriptions[j] = descriptions[i];
	            j++;
	          }
	        }
	        descriptions.length = j;
	      }

	      switch (descriptions.length) {
	        case 1:
	          return descriptions[0];

	        case 2:
	          return descriptions[0] + " or " + descriptions[1];

	        default:
	          return descriptions.slice(0, -1).join(", ")
	            + ", or "
	            + descriptions[descriptions.length - 1];
	      }
	    }

	    function describeFound(found) {
	      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
	    }

	    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
	  };

	  function peg$parse(input, options) {
	    options = options !== void 0 ? options : {};

	    var peg$FAILED = {},

	        peg$startRuleFunctions = { Start: peg$parseStart },
	        peg$startRuleFunction  = peg$parseStart,

	        peg$c0 = function(list) {
	            return list.items.length === 1 ? list.items[0] : list;
	          },
	        peg$c1 = function(first, rest) {
	            return new CSSDeclCommaListExpression([first].concat(rest), location());
	          },
	        peg$c2 = function(first, rest) {
	            return new CSSDeclSpaceListExpression([first].concat(rest), location());
	          },
	        peg$c3 = ",",
	        peg$c4 = peg$literalExpectation(",", false),
	        peg$c5 = function(expr) {
	            return expr;
	          },
	        peg$c6 = " ",
	        peg$c7 = peg$literalExpectation(" ", false),
	        peg$c8 = /^[a-zA-Z%]/,
	        peg$c9 = peg$classExpectation([["a", "z"], ["A", "Z"], "%"], false, false),
	        peg$c10 = function(number, unit) {
	            return new CSSDeclMeasurementExpression(number.value, unit.join(""), location());
	          },
	        peg$c11 = "deg",
	        peg$c12 = peg$literalExpectation("deg", false),
	        peg$c13 = function(number) {
	            return new CSSDeclDegreeExpression(number.value, location());
	          },
	        peg$c14 = "#",
	        peg$c15 = peg$literalExpectation("#", false),
	        peg$c16 = /^[a-zA-Z0-9]/,
	        peg$c17 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
	        peg$c18 = function(color) {
	            return new CSSDeclColorExpression(text(), location());
	          },
	        peg$c19 = "(",
	        peg$c20 = peg$literalExpectation("(", false),
	        peg$c21 = ")",
	        peg$c22 = peg$literalExpectation(")", false),
	        peg$c23 = function(id, params) {
	            return new CSSDeclCallExpression(id, params ? params.items : [], location());
	          },
	        peg$c24 = /^[^ (),]/,
	        peg$c25 = peg$classExpectation([" ", "(", ")", ","], true, false),
	        peg$c26 = function() {
	            return new CSSDeclIdentifierExpression(text(), location());
	          },
	        peg$c27 = "-",
	        peg$c28 = peg$literalExpectation("-", false),
	        peg$c29 = ".",
	        peg$c30 = peg$literalExpectation(".", false),
	        peg$c31 = /^[0-9]/,
	        peg$c32 = peg$classExpectation([["0", "9"]], false, false),
	        peg$c33 = function() {
	            return new CSSDeclLiteralExpression(Number(text()), location());
	          },
	        peg$c34 = "\"",
	        peg$c35 = peg$literalExpectation("\"", false),
	        peg$c36 = function(characters) { return new CSSDeclLiteralExpression(characters.join(""), location()); },
	        peg$c37 = "'",
	        peg$c38 = peg$literalExpectation("'", false),
	        peg$c39 = "\\",
	        peg$c40 = peg$literalExpectation("\\", false),
	        peg$c41 = peg$anyExpectation(),
	        peg$c42 = function() { return text(); },
	        peg$c43 = "\\\"",
	        peg$c44 = peg$literalExpectation("\\\"", false),
	        peg$c45 = "\\'",
	        peg$c46 = peg$literalExpectation("\\'", false),
	        peg$c47 = /^[ \n\r\t]/,
	        peg$c48 = peg$classExpectation([" ", "\n", "\r", "\t"], false, false),

	        peg$currPos          = 0,
	        peg$savedPos         = 0,
	        peg$posDetailsCache  = [{ line: 1, column: 1 }],
	        peg$maxFailPos       = 0,
	        peg$maxFailExpected  = [],
	        peg$silentFails      = 0,

	        peg$result;

	    if ("startRule" in options) {
	      if (!(options.startRule in peg$startRuleFunctions)) {
	        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
	      }

	      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
	    }

	    function text() {
	      return input.substring(peg$savedPos, peg$currPos);
	    }

	    function location() {
	      return peg$computeLocation(peg$savedPos, peg$currPos);
	    }

	    function expected(description, location) {
	      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

	      throw peg$buildStructuredError(
	        [peg$otherExpectation(description)],
	        input.substring(peg$savedPos, peg$currPos),
	        location
	      );
	    }

	    function error(message, location) {
	      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

	      throw peg$buildSimpleError(message, location);
	    }

	    function peg$literalExpectation(text, ignoreCase) {
	      return { type: "literal", text: text, ignoreCase: ignoreCase };
	    }

	    function peg$classExpectation(parts, inverted, ignoreCase) {
	      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
	    }

	    function peg$anyExpectation() {
	      return { type: "any" };
	    }

	    function peg$endExpectation() {
	      return { type: "end" };
	    }

	    function peg$otherExpectation(description) {
	      return { type: "other", description: description };
	    }

	    function peg$computePosDetails(pos) {
	      var details = peg$posDetailsCache[pos], p;

	      if (details) {
	        return details;
	      } else {
	        p = pos - 1;
	        while (!peg$posDetailsCache[p]) {
	          p--;
	        }

	        details = peg$posDetailsCache[p];
	        details = {
	          line:   details.line,
	          column: details.column
	        };

	        while (p < pos) {
	          if (input.charCodeAt(p) === 10) {
	            details.line++;
	            details.column = 1;
	          } else {
	            details.column++;
	          }

	          p++;
	        }

	        peg$posDetailsCache[pos] = details;
	        return details;
	      }
	    }

	    function peg$computeLocation(startPos, endPos) {
	      var startPosDetails = peg$computePosDetails(startPos),
	          endPosDetails   = peg$computePosDetails(endPos);

	      return {
	        start: {
	          offset: startPos,
	          line:   startPosDetails.line,
	          column: startPosDetails.column
	        },
	        end: {
	          offset: endPos,
	          line:   endPosDetails.line,
	          column: endPosDetails.column
	        }
	      };
	    }

	    function peg$fail(expected) {
	      if (peg$currPos < peg$maxFailPos) { return; }

	      if (peg$currPos > peg$maxFailPos) {
	        peg$maxFailPos = peg$currPos;
	        peg$maxFailExpected = [];
	      }

	      peg$maxFailExpected.push(expected);
	    }

	    function peg$buildSimpleError(message, location) {
	      return new peg$SyntaxError(message, null, null, location);
	    }

	    function peg$buildStructuredError(expected, found, location) {
	      return new peg$SyntaxError(
	        peg$SyntaxError.buildMessage(expected, found),
	        expected,
	        found,
	        location
	      );
	    }

	    function peg$parseStart() {
	      var s0, s1;

	      s0 = peg$currPos;
	      s1 = peg$parseCommaList();
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c0(s1);
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseCommaList() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseSpaceList();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parseCommaListRest();
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$parseCommaListRest();
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c1(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseSpaceList() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseExpression();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parseSpaceListRest();
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$parseSpaceListRest();
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c2(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseCommaListRest() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 44) {
	        s1 = peg$c3;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c4); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parse_();
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parseSpaceList();
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c5(s3);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseSpaceListRest() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 32) {
	        s1 = peg$c6;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c7); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$parseExpression();
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c5(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseExpression() {
	      var s0;

	      s0 = peg$parseDegree();
	      if (s0 === peg$FAILED) {
	        s0 = peg$parseMeasurement();
	        if (s0 === peg$FAILED) {
	          s0 = peg$parseNumber();
	          if (s0 === peg$FAILED) {
	            s0 = peg$parseColor();
	            if (s0 === peg$FAILED) {
	              s0 = peg$parseString();
	              if (s0 === peg$FAILED) {
	                s0 = peg$parseCall();
	                if (s0 === peg$FAILED) {
	                  s0 = peg$parseIdentifier();
	                }
	              }
	            }
	          }
	        }
	      }

	      return s0;
	    }

	    function peg$parseMeasurement() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      s1 = peg$parseNumber();
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        if (peg$c8.test(input.charAt(peg$currPos))) {
	          s3 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c9); }
	        }
	        if (s3 !== peg$FAILED) {
	          while (s3 !== peg$FAILED) {
	            s2.push(s3);
	            if (peg$c8.test(input.charAt(peg$currPos))) {
	              s3 = input.charAt(peg$currPos);
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c9); }
	            }
	          }
	        } else {
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c10(s1, s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseDegree() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$parseNumber();
	      if (s1 !== peg$FAILED) {
	        if (input.substr(peg$currPos, 3) === peg$c11) {
	          s2 = peg$c11;
	          peg$currPos += 3;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c12); }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c13(s1);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseColor() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 35) {
	        s1 = peg$c14;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c15); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        if (peg$c16.test(input.charAt(peg$currPos))) {
	          s3 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c17); }
	        }
	        if (s3 !== peg$FAILED) {
	          while (s3 !== peg$FAILED) {
	            s2.push(s3);
	            if (peg$c16.test(input.charAt(peg$currPos))) {
	              s3 = input.charAt(peg$currPos);
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c17); }
	            }
	          }
	        } else {
	          s2 = peg$FAILED;
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c18(s2);
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseCall() {
	      var s0, s1, s2, s3, s4, s5, s6;

	      s0 = peg$currPos;
	      s1 = peg$parseIdentifier();
	      if (s1 !== peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 40) {
	          s2 = peg$c19;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c20); }
	        }
	        if (s2 !== peg$FAILED) {
	          s3 = peg$parse_();
	          if (s3 !== peg$FAILED) {
	            s4 = peg$parseCommaList();
	            if (s4 === peg$FAILED) {
	              s4 = null;
	            }
	            if (s4 !== peg$FAILED) {
	              s5 = peg$parse_();
	              if (s5 !== peg$FAILED) {
	                if (input.charCodeAt(peg$currPos) === 41) {
	                  s6 = peg$c21;
	                  peg$currPos++;
	                } else {
	                  s6 = peg$FAILED;
	                  if (peg$silentFails === 0) { peg$fail(peg$c22); }
	                }
	                if (s6 !== peg$FAILED) {
	                  peg$savedPos = s0;
	                  s1 = peg$c23(s1, s4);
	                  s0 = s1;
	                } else {
	                  peg$currPos = s0;
	                  s0 = peg$FAILED;
	                }
	              } else {
	                peg$currPos = s0;
	                s0 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseIdentifier() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = [];
	      if (peg$c24.test(input.charAt(peg$currPos))) {
	        s2 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c25); }
	      }
	      if (s2 !== peg$FAILED) {
	        while (s2 !== peg$FAILED) {
	          s1.push(s2);
	          if (peg$c24.test(input.charAt(peg$currPos))) {
	            s2 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s2 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c25); }
	          }
	        }
	      } else {
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        peg$savedPos = s0;
	        s1 = peg$c26();
	      }
	      s0 = s1;

	      return s0;
	    }

	    function peg$parseNumber() {
	      var s0, s1, s2, s3, s4, s5, s6, s7;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 45) {
	        s1 = peg$c27;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c28); }
	      }
	      if (s1 === peg$FAILED) {
	        s1 = null;
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 46) {
	          s3 = peg$c29;
	          peg$currPos++;
	        } else {
	          s3 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c30); }
	        }
	        if (s3 !== peg$FAILED) {
	          s4 = [];
	          if (peg$c31.test(input.charAt(peg$currPos))) {
	            s5 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s5 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c32); }
	          }
	          if (s5 !== peg$FAILED) {
	            while (s5 !== peg$FAILED) {
	              s4.push(s5);
	              if (peg$c31.test(input.charAt(peg$currPos))) {
	                s5 = input.charAt(peg$currPos);
	                peg$currPos++;
	              } else {
	                s5 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c32); }
	              }
	            }
	          } else {
	            s4 = peg$FAILED;
	          }
	          if (s4 !== peg$FAILED) {
	            s3 = [s3, s4];
	            s2 = s3;
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s2;
	          s2 = peg$FAILED;
	        }
	        if (s2 === peg$FAILED) {
	          s2 = peg$currPos;
	          s3 = [];
	          if (peg$c31.test(input.charAt(peg$currPos))) {
	            s4 = input.charAt(peg$currPos);
	            peg$currPos++;
	          } else {
	            s4 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c32); }
	          }
	          if (s4 !== peg$FAILED) {
	            while (s4 !== peg$FAILED) {
	              s3.push(s4);
	              if (peg$c31.test(input.charAt(peg$currPos))) {
	                s4 = input.charAt(peg$currPos);
	                peg$currPos++;
	              } else {
	                s4 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c32); }
	              }
	            }
	          } else {
	            s3 = peg$FAILED;
	          }
	          if (s3 !== peg$FAILED) {
	            s4 = peg$currPos;
	            if (input.charCodeAt(peg$currPos) === 46) {
	              s5 = peg$c29;
	              peg$currPos++;
	            } else {
	              s5 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c30); }
	            }
	            if (s5 !== peg$FAILED) {
	              s6 = [];
	              if (peg$c31.test(input.charAt(peg$currPos))) {
	                s7 = input.charAt(peg$currPos);
	                peg$currPos++;
	              } else {
	                s7 = peg$FAILED;
	                if (peg$silentFails === 0) { peg$fail(peg$c32); }
	              }
	              if (s7 !== peg$FAILED) {
	                while (s7 !== peg$FAILED) {
	                  s6.push(s7);
	                  if (peg$c31.test(input.charAt(peg$currPos))) {
	                    s7 = input.charAt(peg$currPos);
	                    peg$currPos++;
	                  } else {
	                    s7 = peg$FAILED;
	                    if (peg$silentFails === 0) { peg$fail(peg$c32); }
	                  }
	                }
	              } else {
	                s6 = peg$FAILED;
	              }
	              if (s6 !== peg$FAILED) {
	                s5 = [s5, s6];
	                s4 = s5;
	              } else {
	                peg$currPos = s4;
	                s4 = peg$FAILED;
	              }
	            } else {
	              peg$currPos = s4;
	              s4 = peg$FAILED;
	            }
	            if (s4 === peg$FAILED) {
	              s4 = null;
	            }
	            if (s4 !== peg$FAILED) {
	              s3 = [s3, s4];
	              s2 = s3;
	            } else {
	              peg$currPos = s2;
	              s2 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s2;
	            s2 = peg$FAILED;
	          }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c33();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }

	      return s0;
	    }

	    function peg$parseString() {
	      var s0, s1, s2, s3;

	      s0 = peg$currPos;
	      if (input.charCodeAt(peg$currPos) === 34) {
	        s1 = peg$c34;
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c35); }
	      }
	      if (s1 !== peg$FAILED) {
	        s2 = [];
	        s3 = peg$parseDoubleStringCharacter();
	        while (s3 !== peg$FAILED) {
	          s2.push(s3);
	          s3 = peg$parseDoubleStringCharacter();
	        }
	        if (s2 !== peg$FAILED) {
	          if (input.charCodeAt(peg$currPos) === 34) {
	            s3 = peg$c34;
	            peg$currPos++;
	          } else {
	            s3 = peg$FAILED;
	            if (peg$silentFails === 0) { peg$fail(peg$c35); }
	          }
	          if (s3 !== peg$FAILED) {
	            peg$savedPos = s0;
	            s1 = peg$c36(s2);
	            s0 = s1;
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        s0 = peg$currPos;
	        if (input.charCodeAt(peg$currPos) === 39) {
	          s1 = peg$c37;
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c38); }
	        }
	        if (s1 !== peg$FAILED) {
	          s2 = [];
	          s3 = peg$parseSingleStringCharacter();
	          while (s3 !== peg$FAILED) {
	            s2.push(s3);
	            s3 = peg$parseSingleStringCharacter();
	          }
	          if (s2 !== peg$FAILED) {
	            if (input.charCodeAt(peg$currPos) === 39) {
	              s3 = peg$c37;
	              peg$currPos++;
	            } else {
	              s3 = peg$FAILED;
	              if (peg$silentFails === 0) { peg$fail(peg$c38); }
	            }
	            if (s3 !== peg$FAILED) {
	              peg$savedPos = s0;
	              s1 = peg$c36(s2);
	              s0 = s1;
	            } else {
	              peg$currPos = s0;
	              s0 = peg$FAILED;
	            }
	          } else {
	            peg$currPos = s0;
	            s0 = peg$FAILED;
	          }
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      }

	      return s0;
	    }

	    function peg$parseDoubleStringCharacter() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 34) {
	        s2 = peg$c34;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c35); }
	      }
	      if (s2 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s2 = peg$c39;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c40); }
	        }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        if (input.length > peg$currPos) {
	          s2 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c41); }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c42();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c43) {
	          s0 = peg$c43;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c44); }
	        }
	      }

	      return s0;
	    }

	    function peg$parseSingleStringCharacter() {
	      var s0, s1, s2;

	      s0 = peg$currPos;
	      s1 = peg$currPos;
	      peg$silentFails++;
	      if (input.charCodeAt(peg$currPos) === 39) {
	        s2 = peg$c37;
	        peg$currPos++;
	      } else {
	        s2 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c38); }
	      }
	      if (s2 === peg$FAILED) {
	        if (input.charCodeAt(peg$currPos) === 92) {
	          s2 = peg$c39;
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c40); }
	        }
	      }
	      peg$silentFails--;
	      if (s2 === peg$FAILED) {
	        s1 = void 0;
	      } else {
	        peg$currPos = s1;
	        s1 = peg$FAILED;
	      }
	      if (s1 !== peg$FAILED) {
	        if (input.length > peg$currPos) {
	          s2 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s2 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c41); }
	        }
	        if (s2 !== peg$FAILED) {
	          peg$savedPos = s0;
	          s1 = peg$c42();
	          s0 = s1;
	        } else {
	          peg$currPos = s0;
	          s0 = peg$FAILED;
	        }
	      } else {
	        peg$currPos = s0;
	        s0 = peg$FAILED;
	      }
	      if (s0 === peg$FAILED) {
	        if (input.substr(peg$currPos, 2) === peg$c45) {
	          s0 = peg$c45;
	          peg$currPos += 2;
	        } else {
	          s0 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c46); }
	        }
	      }

	      return s0;
	    }

	    function peg$parse_() {
	      var s0, s1;

	      s0 = [];
	      if (peg$c47.test(input.charAt(peg$currPos))) {
	        s1 = input.charAt(peg$currPos);
	        peg$currPos++;
	      } else {
	        s1 = peg$FAILED;
	        if (peg$silentFails === 0) { peg$fail(peg$c48); }
	      }
	      while (s1 !== peg$FAILED) {
	        s0.push(s1);
	        if (peg$c47.test(input.charAt(peg$currPos))) {
	          s1 = input.charAt(peg$currPos);
	          peg$currPos++;
	        } else {
	          s1 = peg$FAILED;
	          if (peg$silentFails === 0) { peg$fail(peg$c48); }
	        }
	      }

	      return s0;
	    }


	      const {
	        CSSDeclListExpression,
	        CSSDeclCallExpression,
	        CSSDeclColorExpression,
	        CSSDeclDegreeExpression,
	        CSSDeclNumberExpression,
	        CSSDeclLiteralExpression,
	        CSSDeclSpaceListExpression,
	        CSSDeclCommaListExpression,
	        CSSDeclIdentifierExpression,
	        CSSDeclMeasurementExpression,
	      } = __webpack_require__(277);


	    peg$result = peg$startRuleFunction();

	    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
	      return peg$result;
	    } else {
	      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
	        peg$fail(peg$endExpectation());
	      }

	      throw peg$buildStructuredError(
	        peg$maxFailExpected,
	        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
	        peg$maxFailPos < input.length
	          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
	          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
	      );
	    }
	  }

	  return {
	    SyntaxError: peg$SyntaxError,
	    parse:       peg$parse
	  };
	})();

/***/ },
/* 277 */
/***/ function(module, exports) {

	"use strict";
	(function (CSSDeclValueExpressionKind) {
	    CSSDeclValueExpressionKind[CSSDeclValueExpressionKind["IDENTIFIER"] = 1] = "IDENTIFIER";
	    CSSDeclValueExpressionKind[CSSDeclValueExpressionKind["COMMA_LIST"] = 2] = "COMMA_LIST";
	    CSSDeclValueExpressionKind[CSSDeclValueExpressionKind["SPACE_LIST"] = 3] = "SPACE_LIST";
	    CSSDeclValueExpressionKind[CSSDeclValueExpressionKind["MEASUREMENT"] = 4] = "MEASUREMENT";
	    CSSDeclValueExpressionKind[CSSDeclValueExpressionKind["DEGREE"] = 5] = "DEGREE";
	    CSSDeclValueExpressionKind[CSSDeclValueExpressionKind["LITERAL"] = 6] = "LITERAL";
	    CSSDeclValueExpressionKind[CSSDeclValueExpressionKind["CALL"] = 7] = "CALL";
	    CSSDeclValueExpressionKind[CSSDeclValueExpressionKind["COLOR"] = 8] = "COLOR";
	    CSSDeclValueExpressionKind[CSSDeclValueExpressionKind["BINARY"] = 9] = "BINARY";
	})(exports.CSSDeclValueExpressionKind || (exports.CSSDeclValueExpressionKind = {}));
	var CSSDeclValueExpressionKind = exports.CSSDeclValueExpressionKind;
	class CSSDeclValueExpression {
	    constructor(kind, location) {
	        this.kind = kind;
	        this.location = location;
	    }
	}
	exports.CSSDeclValueExpression = CSSDeclValueExpression;
	class CSSDeclColorExpression extends CSSDeclValueExpression {
	    constructor(value, location) {
	        super(CSSDeclValueExpressionKind.COLOR, location);
	        this.value = value;
	    }
	    accept(visitor) {
	        return visitor.visitColor(this);
	    }
	}
	exports.CSSDeclColorExpression = CSSDeclColorExpression;
	class CSSDeclIdentifierExpression extends CSSDeclValueExpression {
	    constructor(value, location) {
	        super(CSSDeclValueExpressionKind.IDENTIFIER, location);
	        this.value = value;
	    }
	    accept(visitor) {
	        return visitor.visitIdentifier(this);
	    }
	    toString() {
	        return this.value;
	    }
	}
	exports.CSSDeclIdentifierExpression = CSSDeclIdentifierExpression;
	class CSSDeclListExpression extends CSSDeclValueExpression {
	    constructor(kind, items, location) {
	        super(kind, location);
	        this.items = items;
	    }
	}
	exports.CSSDeclListExpression = CSSDeclListExpression;
	class CSSDeclCommaListExpression extends CSSDeclListExpression {
	    constructor(items, location) {
	        super(CSSDeclValueExpressionKind.COMMA_LIST, items, location);
	    }
	    accept(visitor) {
	        return visitor.visitCommaList(this);
	    }
	}
	exports.CSSDeclCommaListExpression = CSSDeclCommaListExpression;
	class CSSDeclSpaceListExpression extends CSSDeclListExpression {
	    constructor(items, location) {
	        super(CSSDeclValueExpressionKind.SPACE_LIST, items, location);
	    }
	    accept(visitor) {
	        return visitor.visitSpaceList(this);
	    }
	}
	exports.CSSDeclSpaceListExpression = CSSDeclSpaceListExpression;
	class CSSDeclMeasurementExpression extends CSSDeclValueExpression {
	    constructor(value, unit, location) {
	        super(CSSDeclValueExpressionKind.MEASUREMENT, location);
	        this.value = value;
	        this.unit = unit;
	    }
	    accept(visitor) {
	        return visitor.visitMeasurement(this);
	    }
	}
	exports.CSSDeclMeasurementExpression = CSSDeclMeasurementExpression;
	class CSSDeclDegreeExpression extends CSSDeclValueExpression {
	    constructor(value, location) {
	        super(CSSDeclValueExpressionKind.DEGREE, location);
	        this.value = value;
	    }
	    accept(visitor) {
	        return visitor.visitDegree(this);
	    }
	}
	exports.CSSDeclDegreeExpression = CSSDeclDegreeExpression;
	class CSSDeclLiteralExpression extends CSSDeclValueExpression {
	    constructor(value, location) {
	        super(CSSDeclValueExpressionKind.LITERAL, location);
	        this.value = value;
	    }
	    accept(visitor) {
	        return visitor.visitLiteral(this);
	    }
	}
	exports.CSSDeclLiteralExpression = CSSDeclLiteralExpression;
	class CSSDeclCallExpression extends CSSDeclValueExpression {
	    constructor(identifier, params, location) {
	        super(CSSDeclValueExpressionKind.CALL, location);
	        this.identifier = identifier;
	        this.params = params;
	    }
	    accept(visitor) {
	        return visitor.visitCall(this);
	    }
	}
	exports.CSSDeclCallExpression = CSSDeclCallExpression;


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const tinyColor = __webpack_require__(279);
	const { parse } = __webpack_require__(276);
	const common_1 = __webpack_require__(46);
	const sandbox_1 = __webpack_require__(167);
	/*

	run this:  http://www.w3schools.com/colors/colors_names.asp

	var colorMap = {};

	Array.prototype.forEach.call(document.querySelectorAll("td:first-child a[href*='/colors/color_tryit.asp']"), (element) => {
	  colorMap[element.textContent.toLowerCase().trim()] =  element.parentNode.nextElementSibling.textContent.toUpperCase().trim();
	});

	console.log(JSON.stringify(colorMap, null, 2));

	Copy stdout and paste below

	*/
	exports.BUILTIN_CSS_COLOR_MAP = {
	    "aliceblue": "#F0F8FF",
	    "antiquewhite": "#FAEBD7",
	    "aqua": "#00FFFF",
	    "aquamarine": "#7FFFD4",
	    "azure": "#F0FFFF",
	    "beige": "#F5F5DC",
	    "bisque": "#FFE4C4",
	    "black": "#000000",
	    "blanchedalmond": "#FFEBCD",
	    "blue": "#0000FF",
	    "blueviolet": "#8A2BE2",
	    "brown": "#A52A2A",
	    "burlywood": "#DEB887",
	    "cadetblue": "#5F9EA0",
	    "chartreuse": "#7FFF00",
	    "chocolate": "#D2691E",
	    "coral": "#FF7F50",
	    "cornflowerblue": "#6495ED",
	    "cornsilk": "#FFF8DC",
	    "crimson": "#DC143C",
	    "cyan": "#00FFFF",
	    "darkblue": "#00008B",
	    "darkcyan": "#008B8B",
	    "darkgoldenrod": "#B8860B",
	    "darkgray": "#A9A9A9",
	    "darkgrey": "#A9A9A9",
	    "darkgreen": "#006400",
	    "darkkhaki": "#BDB76B",
	    "darkmagenta": "#8B008B",
	    "darkolivegreen": "#556B2F",
	    "darkorange": "#FF8C00",
	    "darkorchid": "#9932CC",
	    "darkred": "#8B0000",
	    "darksalmon": "#E9967A",
	    "darkseagreen": "#8FBC8F",
	    "darkslateblue": "#483D8B",
	    "darkslategray": "#2F4F4F",
	    "darkslategrey": "#2F4F4F",
	    "darkturquoise": "#00CED1",
	    "darkviolet": "#9400D3",
	    "deeppink": "#FF1493",
	    "deepskyblue": "#00BFFF",
	    "dimgray": "#696969",
	    "dimgrey": "#696969",
	    "dodgerblue": "#1E90FF",
	    "firebrick": "#B22222",
	    "floralwhite": "#FFFAF0",
	    "forestgreen": "#228B22",
	    "fuchsia": "#FF00FF",
	    "gainsboro": "#DCDCDC",
	    "ghostwhite": "#F8F8FF",
	    "gold": "#FFD700",
	    "goldenrod": "#DAA520",
	    "gray": "#808080",
	    "grey": "#808080",
	    "green": "#008000",
	    "greenyellow": "#ADFF2F",
	    "honeydew": "#F0FFF0",
	    "hotpink": "#FF69B4",
	    "indianred": "#CD5C5C",
	    "indigo": "#4B0082",
	    "ivory": "#FFFFF0",
	    "khaki": "#F0E68C",
	    "lavender": "#E6E6FA",
	    "lavenderblush": "#FFF0F5",
	    "lawngreen": "#7CFC00",
	    "lemonchiffon": "#FFFACD",
	    "lightblue": "#ADD8E6",
	    "lightcoral": "#F08080",
	    "lightcyan": "#E0FFFF",
	    "lightgoldenrodyellow": "#FAFAD2",
	    "lightgray": "#D3D3D3",
	    "lightgrey": "#D3D3D3",
	    "lightgreen": "#90EE90",
	    "lightpink": "#FFB6C1",
	    "lightsalmon": "#FFA07A",
	    "lightseagreen": "#20B2AA",
	    "lightskyblue": "#87CEFA",
	    "lightslategray": "#778899",
	    "lightslategrey": "#778899",
	    "lightsteelblue": "#B0C4DE",
	    "lightyellow": "#FFFFE0",
	    "lime": "#00FF00",
	    "limegreen": "#32CD32",
	    "linen": "#FAF0E6",
	    "magenta": "#FF00FF",
	    "maroon": "#800000",
	    "mediumaquamarine": "#66CDAA",
	    "mediumblue": "#0000CD",
	    "mediumorchid": "#BA55D3",
	    "mediumpurple": "#9370DB",
	    "mediumseagreen": "#3CB371",
	    "mediumslateblue": "#7B68EE",
	    "mediumspringgreen": "#00FA9A",
	    "mediumturquoise": "#48D1CC",
	    "mediumvioletred": "#C71585",
	    "midnightblue": "#191970",
	    "mintcream": "#F5FFFA",
	    "mistyrose": "#FFE4E1",
	    "moccasin": "#FFE4B5",
	    "navajowhite": "#FFDEAD",
	    "navy": "#000080",
	    "oldlace": "#FDF5E6",
	    "olive": "#808000",
	    "olivedrab": "#6B8E23",
	    "orange": "#FFA500",
	    "orangered": "#FF4500",
	    "orchid": "#DA70D6",
	    "palegoldenrod": "#EEE8AA",
	    "palegreen": "#98FB98",
	    "paleturquoise": "#AFEEEE",
	    "palevioletred": "#DB7093",
	    "papayawhip": "#FFEFD5",
	    "peachpuff": "#FFDAB9",
	    "peru": "#CD853F",
	    "pink": "#FFC0CB",
	    "plum": "#DDA0DD",
	    "powderblue": "#B0E0E6",
	    "purple": "#800080",
	    "rebeccapurple": "#663399",
	    "red": "#FF0000",
	    "rosybrown": "#BC8F8F",
	    "royalblue": "#4169E1",
	    "saddlebrown": "#8B4513",
	    "salmon": "#FA8072",
	    "sandybrown": "#F4A460",
	    "seagreen": "#2E8B57",
	    "seashell": "#FFF5EE",
	    "sienna": "#A0522D",
	    "silver": "#C0C0C0",
	    "skyblue": "#87CEEB",
	    "slateblue": "#6A5ACD",
	    "slategray": "#708090",
	    "slategrey": "#708090",
	    "snow": "#FFFAFA",
	    "springgreen": "#00FF7F",
	    "steelblue": "#4682B4",
	    "tan": "#D2B48C",
	    "teal": "#008080",
	    "thistle": "#D8BFD8",
	    "tomato": "#FF6347",
	    "turquoise": "#40E0D0",
	    "violet": "#EE82EE",
	    "wheat": "#F5DEB3",
	    "white": "#FFFFFF",
	    "whitesmoke": "#F5F5F5",
	    "yellow": "#FFFF00",
	    "yellowgreen": "#9ACD32"
	};
	for (const key in exports.BUILTIN_CSS_COLOR_MAP) {
	    exports.BUILTIN_CSS_COLOR_MAP[exports.BUILTIN_CSS_COLOR_MAP[key]] = key;
	}
	class SyntheticCSSValue extends common_1.Observable {
	    constructor() {
	        super();
	        this.$uid = sandbox_1.generateSyntheticUID();
	    }
	    get uid() {
	        return this.$uid;
	    }
	    visitWalker(walker) { }
	}
	exports.SyntheticCSSValue = SyntheticCSSValue;
	const toHex = (value) => {
	    return ("0" + value.toString(16)).slice(-2);
	};
	class SyntheticCSSColor extends SyntheticCSSValue {
	    constructor(r, g, b, a = 1) {
	        super();
	        this.r = r;
	        this.g = g;
	        this.b = b;
	        this.a = a;
	    }
	    static fromRGBA({ r, g, b, a }) {
	        return new SyntheticCSSColor(r, g, b, a);
	    }
	    clone() {
	        return new SyntheticCSSColor(this.r, this.g, this.b, this.a);
	    }
	    toHex() {
	        return `#${[this.r, this.g, this.b].map(toHex).join("")}`.toUpperCase();
	    }
	    toString() {
	        if (this.a !== 1) {
	            return `rgba(${this.r}, ${this.g}, ${this.b}, ${this.a})`;
	        }
	        const hex = this.toHex();
	        const alias = exports.BUILTIN_CSS_COLOR_MAP[hex];
	        if (alias)
	            return alias;
	        return hex;
	    }
	}
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSColor.prototype, "r", void 0);
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSColor.prototype, "g", void 0);
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSColor.prototype, "b", void 0);
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSColor.prototype, "a", void 0);
	exports.SyntheticCSSColor = SyntheticCSSColor;
	class SyntheticCSSFilter extends SyntheticCSSValue {
	    constructor(name, params) {
	        super();
	        this.name = name;
	        this.params = params;
	    }
	    clone() {
	        return exports.evaluateCSSDeclValue(parse(this.toString()))[0];
	    }
	}
	exports.SyntheticCSSFilter = SyntheticCSSFilter;
	class SyntheticAmountFilter extends SyntheticCSSFilter {
	    constructor(name, params) {
	        super(name, params);
	        this.name = name;
	        this.amount = params[0] || new SyntheticCSSMeasurment(0, "px");
	    }
	    setProperty(name, value) {
	        this[name] = exports.evaluateCSSDeclValue(parse(value))[0];
	    }
	    toString() {
	        return `${this.name}(${this.amount})`;
	    }
	}
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticAmountFilter.prototype, "amount", void 0);
	exports.SyntheticAmountFilter = SyntheticAmountFilter;
	// https://developer.mozilla.org/en-US/docs/Web/CSS/filter see drop-shadow options
	class SyntheticDropShadowFilter extends SyntheticCSSFilter {
	    constructor(name, params) {
	        super(name, params);
	        params = params.concat();
	        this.x = SyntheticCSSMeasurment.cast(params.shift());
	        this.y = SyntheticCSSMeasurment.cast(params.shift());
	        const colorOrMeasurement = params.pop();
	        if (colorOrMeasurement instanceof SyntheticCSSColor) {
	            this.color = colorOrMeasurement;
	        }
	        else {
	            params.push(colorOrMeasurement);
	        }
	        const blur = params.shift();
	        const spread = params.shift();
	        if (blur)
	            this.blur = SyntheticCSSMeasurment.cast(blur);
	        if (spread)
	            this.spread = SyntheticCSSMeasurment.cast(spread);
	    }
	    setProperty(name, value) {
	        this[name] = exports.evaluateCSSDeclValue(parse(value))[0];
	    }
	    toString() {
	        const params = [this.x, this.y];
	        if (this.blur)
	            params.push(this.blur);
	        if (this.spread)
	            params.push(this.spread);
	        if (this.color)
	            params.push(this.color);
	        return `drop-shadow(${params.join(" ")})`;
	    }
	}
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticDropShadowFilter.prototype, "x", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticDropShadowFilter.prototype, "y", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticDropShadowFilter.prototype, "blur", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticDropShadowFilter.prototype, "spread", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticDropShadowFilter.prototype, "color", void 0);
	exports.SyntheticDropShadowFilter = SyntheticDropShadowFilter;
	class SyntheticCSSDegree extends SyntheticCSSValue {
	    constructor(value) {
	        super();
	        this.value = Math.round(value) % 360;
	    }
	    clone() {
	        return new SyntheticCSSDegree(this.value);
	    }
	    toString() {
	        return `${this.value}deg`;
	    }
	}
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSDegree.prototype, "value", void 0);
	exports.SyntheticCSSDegree = SyntheticCSSDegree;
	class SyntheticCSSMeasurment extends SyntheticCSSValue {
	    constructor(value, unit) {
	        super();
	        this.value = value;
	        this.unit = unit;
	    }
	    clone() {
	        return new SyntheticCSSMeasurment(this.value, this.unit);
	    }
	    toString() {
	        return `${this.value}${this.unit}`;
	    }
	    static cast(value) {
	        if (typeof value === "number")
	            return new SyntheticCSSMeasurment(value, "px");
	        // check for invalid units -- something like 40p should be defaulted to 40px
	        if (typeof value === "string")
	            return new SyntheticCSSMeasurment(Number(/\d/.test(value) ? value.match(/\d+/)[0] : 0), "px");
	        if (value == null)
	            return new SyntheticCSSMeasurment(0, "px");
	        return value;
	    }
	}
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSMeasurment.prototype, "value", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSMeasurment.prototype, "unit", void 0);
	exports.SyntheticCSSMeasurment = SyntheticCSSMeasurment;
	class SyntheticCSSGradientColorStop extends SyntheticCSSValue {
	    constructor(color, stop) {
	        super();
	        this.color = color;
	        this.stop = stop;
	    }
	    clone() {
	        return new SyntheticCSSGradientColorStop(this.color, this.stop);
	    }
	}
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSGradientColorStop.prototype, "color", void 0);
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSGradientColorStop.prototype, "stop", void 0);
	exports.SyntheticCSSGradientColorStop = SyntheticCSSGradientColorStop;
	class SyntheticCSSLinearGradient extends SyntheticCSSValue {
	    constructor(angle, colorStops) {
	        super();
	        this.angle = angle;
	        this.colorStops = new common_1.ObservableCollection(...colorStops);
	    }
	    clone() {
	        return new SyntheticCSSLinearGradient(this.angle, this.colorStops.map(colorStop => colorStop.clone()));
	    }
	    toString() {
	        let buffer = "linear-gradient(";
	        const params = [];
	        if (this.angle) {
	            params.push(this.angle);
	        }
	        for (const { color, stop } of this.colorStops) {
	            if (stop) {
	                params.push(`${color} ${stop * 100}%`);
	            }
	            else {
	                params.push(`${color}`);
	            }
	        }
	        return `linear-gradient(${params.join(", ")})`;
	    }
	}
	__decorate([
	    common_1.bindable(true)
	], SyntheticCSSLinearGradient.prototype, "angle", void 0);
	__decorate([
	    common_1.bindable(true),
	    common_1.bubble()
	], SyntheticCSSLinearGradient.prototype, "colorStops", void 0);
	exports.SyntheticCSSLinearGradient = SyntheticCSSLinearGradient;
	// for now use built-in functions 
	const globalContext = {
	    rgba([r], [g], [b], [a]) {
	        return new SyntheticCSSColor(r, g, b, a);
	    },
	    rgb([r], [g], [b]) {
	        return new SyntheticCSSColor(r, g, b);
	    },
	    url([value]) {
	        return value;
	    },
	    // TODO - translate
	    translateY([value]) {
	        return value;
	    },
	    translateX([value]) {
	        return value;
	    },
	    translate([value]) {
	        return value;
	    },
	    rotate([value]) {
	        return value;
	    },
	    scale([value]) {
	        return value;
	    },
	    "linear-gradient": (...args) => {
	        const angle = typeof args[0][0] === "number" || typeof args[0][0] === "string" ? args.shift() : 0;
	        const colorStops = args.map(([color, measurement]) => {
	            return new SyntheticCSSGradientColorStop(color, measurement && measurement.value / 100);
	        });
	        return new SyntheticCSSLinearGradient(angle, colorStops);
	    }
	};
	exports.CSS_FILTER_TYPES = [
	    "blur",
	    "brightness",
	    "contrast",
	    "drop-shadow",
	    "grayscale",
	    "hue-rotate",
	    "invert",
	    "opacity",
	    "saturate",
	    "sepia"
	];
	for (const filterType of exports.CSS_FILTER_TYPES) {
	    globalContext[filterType] = (...params) => {
	        const params2 = params[0];
	        if (filterType === "drop-shadow") {
	            return new SyntheticDropShadowFilter(filterType, params2);
	        }
	        return new SyntheticAmountFilter(filterType, params2);
	    };
	}
	const parseHexColor = (value) => {
	    const c = tinyColor(value);
	    const rgba = c.toRgb();
	    return new SyntheticCSSColor(rgba.r, rgba.g, rgba.b, rgba.a);
	};
	for (const colorName in exports.BUILTIN_CSS_COLOR_MAP) {
	    const syntheticColor = parseHexColor(exports.BUILTIN_CSS_COLOR_MAP[colorName]);
	    globalContext[colorName] = () => syntheticColor.clone();
	}
	exports.evaluateCSSDeclValue = (expression) => {
	    return expression.accept({
	        visitCall(call) {
	            const name = call.identifier.value;
	            if (!globalContext[name])
	                throw new Error(`Cannot call CSS property value ${name}`);
	            return globalContext[name](...call.params.map((param) => {
	                return param.accept(this);
	            }));
	        },
	        visitColor(color) {
	            return parseHexColor(color.value);
	        },
	        visitDegree(degree) {
	            return new SyntheticCSSDegree(degree.value);
	        },
	        visitLiteral(literal) {
	            return literal.value;
	        },
	        visitCommaList(list) {
	            return list.items.map(item => item.accept(this));
	        },
	        visitSpaceList(list) {
	            return list.items.map(item => item.accept(this));
	        },
	        visitIdentifier(identifier) {
	            const create = globalContext[identifier.value];
	            return (create && create()) || identifier.value;
	        },
	        visitMeasurement(measurement) {
	            return new SyntheticCSSMeasurment(measurement.value, measurement.unit);
	        }
	    });
	};


/***/ },
/* 279 */
/***/ function(module, exports) {

	module.exports = require("tinycolor2");

/***/ },
/* 280 */
/***/ function(module, exports) {

	"use strict";
	class SyntheticLocalStorage {
	    constructor(_data = new Map()) {
	        this._data = _data;
	    }
	    get length() {
	        return this._data.size;
	    }
	    getItem(key) {
	        // note that null is parsable here -- important to ensure that operations such as JSON.parse work
	        return this._data.get(key) || null;
	    }
	    setItem(key, value) {
	        this._data.set(key, value);
	    }
	    removeItem(key) {
	        this._data.delete(key);
	    }
	    clear() {
	        this._data.clear();
	    }
	    key(index) {
	        return this._data.keys[index];
	    }
	}
	exports.SyntheticLocalStorage = SyntheticLocalStorage;


/***/ },
/* 281 */
/***/ function(module, exports) {

	"use strict";
	class SyntheticWindowTimers {
	    constructor() {
	        this._timerIDs = new Map();
	    }
	    setTimeout(callback, timeout, ...args) {
	        const timeoutID = setTimeout(callback, timeout, ...args);
	        this._timerIDs.set(timeoutID, clearTimeout);
	        return timeoutID;
	    }
	    setInterval(callback, timeout, ...args) {
	        const intervalID = setInterval(callback, timeout, ...args);
	        this._timerIDs.set(intervalID, clearInterval);
	        return intervalID;
	    }
	    setImmediate(callback, ...args) {
	        const immediateID = setImmediate(callback, ...args);
	        this._timerIDs.set(immediateID, clearImmediate);
	        return immediateID;
	    }
	    clearTimeout(timerID) { this.clearTimer(timerID); }
	    clearInterval(timerID) { this.clearTimer(timerID); }
	    clearImmediate(timerID) { this.clearTimer(timerID); }
	    clearTimer(timerID) {
	        const clearTimer = this._timerIDs.get(timerID);
	        if (clearTimer) {
	            this._timerIDs[timerID] = undefined;
	            clearTimer(timerID);
	        }
	    }
	    dispose() {
	        for (const timerID of this._timerIDs.keys()) {
	            this.clearTimer(timerID);
	        }
	    }
	}
	exports.SyntheticWindowTimers = SyntheticWindowTimers;


/***/ },
/* 282 */
/***/ function(module, exports) {

	"use strict";
	class FakeBlob {
	    constructor(parts, { type }) {
	        this.parts = parts;
	        this.type = type;
	    }
	}
	exports.FakeBlob = FakeBlob;
	exports.Blob = typeof window !== "undefined" ? window.Blob : FakeBlob;


/***/ },
/* 283 */
/***/ function(module, exports) {

	"use strict";
	class FakeURL {
	    static createObjectURL(blob) {
	        return `data:${blob.type},${encodeURIComponent(blob.parts.join(""))}`;
	    }
	    static revokeObjectURL(url) {
	        // do nothing
	    }
	}
	exports.FakeURL = FakeURL;
	exports.URL = typeof window !== "undefined" ? window.URL : FakeURL;


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	exports.bindDOMEventMethods = (eventTypes, target) => {
	    function handleDOMEventMethod(type, newListener, oldListener) {
	        if (oldListener) {
	            target.removeEventListener(type, newListener);
	        }
	        if (newListener) {
	            target.addEventListener(type, newListener);
	        }
	    }
	    eventTypes.forEach((eventType) => {
	        new common_1.PropertyWatcher(target, `on${eventType.toLowerCase()}`).connect(handleDOMEventMethod.bind(target, eventType));
	    });
	};
	exports.bindDOMNodeEventMethods = (target) => {
	    exports.bindDOMEventMethods(["load"], target);
	};


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(286));
	__export(__webpack_require__(289));
	__export(__webpack_require__(287));


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const common_1 = __webpack_require__(46);
	const utils_1 = __webpack_require__(284);
	const mesh_1 = __webpack_require__(13);
	const messages_1 = __webpack_require__(287);
	const events_1 = __webpack_require__(288);
	(function (XMLHttpRequestReadyState) {
	    XMLHttpRequestReadyState[XMLHttpRequestReadyState["UNSET"] = 0] = "UNSET";
	    XMLHttpRequestReadyState[XMLHttpRequestReadyState["OPENED"] = 1] = "OPENED";
	    XMLHttpRequestReadyState[XMLHttpRequestReadyState["HEADERS_RECEIVED"] = 2] = "HEADERS_RECEIVED";
	    XMLHttpRequestReadyState[XMLHttpRequestReadyState["LOADING"] = 3] = "LOADING";
	    XMLHttpRequestReadyState[XMLHttpRequestReadyState["DONE"] = 4] = "DONE";
	})(exports.XMLHttpRequestReadyState || (exports.XMLHttpRequestReadyState = {}));
	var XMLHttpRequestReadyState = exports.XMLHttpRequestReadyState;
	// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest
	class SyntheticXMLHttpRequest extends common_1.Observable {
	    constructor(bus) {
	        super();
	        this.bus = bus;
	        this.setReadyState(XMLHttpRequestReadyState.UNSET);
	        this._domListenerMap = new events_1.DOMEventDispatcherMap(this);
	        utils_1.bindDOMEventMethods(["readyStateChange"], this);
	    }
	    get readyState() {
	        return this._readyState;
	    }
	    get status() {
	        return this._response && this._response.status;
	    }
	    get responseType() {
	        return this._response && this._response.headers.contentType;
	    }
	    get responseText() {
	        return this._responseData.join("");
	    }
	    addEventListener(type, listener) {
	        this._domListenerMap.add(type, listener);
	    }
	    removeEventListener(type, listener) {
	        this._domListenerMap.remove(type, listener);
	    }
	    overrideMimeType(type) {
	        this._overrideMimeType = type;
	    }
	    open(method, url, async) {
	        this.setReadyState(XMLHttpRequestReadyState.OPENED);
	        this._method = method;
	        this._url = url;
	        this._async = async;
	    }
	    send(data) {
	        return __awaiter(this, void 0, void 0, function* () {
	            yield this._asyncSend(data);
	        });
	    }
	    setReadyState(state) {
	        this._readyState = state;
	        this.notify(new events_1.SyntheticDOMEvent("readyStateChange"));
	    }
	    abort() {
	        if (this._output && this.readyState !== XMLHttpRequestReadyState.DONE) {
	            this._output.abort("no reason");
	        }
	    }
	    _asyncSend(data) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return new Promise((resolve, reject) => {
	                this.setReadyState(XMLHttpRequestReadyState.LOADING);
	                const headers = {};
	                const request = new messages_1.HTTPRequest(this._method, this._url, headers);
	                const duplex = this.bus.dispatch(request);
	                const responseData = [];
	                this._output = duplex.writable;
	                duplex.readable.pipeTo(new mesh_1.WritableStream({
	                    write: (chunk) => {
	                        if (chunk && chunk.type === messages_1.HTTPResponse.HTTP_RESPONSE) {
	                            const response = this._response = chunk;
	                            this.setReadyState(XMLHttpRequestReadyState.HEADERS_RECEIVED);
	                        }
	                        else {
	                            responseData.push(chunk);
	                        }
	                        // first response must be a header here - TODO
	                    },
	                    close: () => {
	                        this._responseData = responseData;
	                        this.setReadyState(XMLHttpRequestReadyState.DONE);
	                        resolve();
	                    },
	                    abort: (reason) => {
	                    }
	                }));
	            });
	        });
	    }
	}
	__decorate([
	    common_1.bindable()
	], SyntheticXMLHttpRequest.prototype, "onreadystatechange", void 0);
	exports.SyntheticXMLHttpRequest = SyntheticXMLHttpRequest;


/***/ },
/* 287 */
/***/ function(module, exports) {

	"use strict";
	// http://www.restapitutorial.com/httpstatuscodes.html
	(function (HTTPStatusType) {
	    // success
	    HTTPStatusType[HTTPStatusType["OK"] = 200] = "OK";
	    HTTPStatusType[HTTPStatusType["CREATED"] = 201] = "CREATED";
	    HTTPStatusType[HTTPStatusType["NON_AUTHORITIVE_INFORMATION"] = 203] = "NON_AUTHORITIVE_INFORMATION";
	    HTTPStatusType[HTTPStatusType["NO_CONTENT"] = 204] = "NO_CONTENT";
	    HTTPStatusType[HTTPStatusType["RESET_CONTENT"] = 205] = "RESET_CONTENT";
	    HTTPStatusType[HTTPStatusType["PARTIAL_CONTENT"] = 206] = "PARTIAL_CONTENT";
	    HTTPStatusType[HTTPStatusType["MULTI_STATUS"] = 207] = "MULTI_STATUS";
	    HTTPStatusType[HTTPStatusType["ALREADY_REPORTED"] = 208] = "ALREADY_REPORTED";
	    HTTPStatusType[HTTPStatusType["IM_USED"] = 226] = "IM_USED";
	    // redirect
	    HTTPStatusType[HTTPStatusType["MULTIPLE_CHOISES"] = 300] = "MULTIPLE_CHOISES";
	    HTTPStatusType[HTTPStatusType["MOVED_PERMANENTLY"] = 301] = "MOVED_PERMANENTLY";
	    HTTPStatusType[HTTPStatusType["FOUND"] = 302] = "FOUND";
	    HTTPStatusType[HTTPStatusType["SEE_OTHER"] = 303] = "SEE_OTHER";
	    HTTPStatusType[HTTPStatusType["NOT_MODIFIED"] = 304] = "NOT_MODIFIED";
	    HTTPStatusType[HTTPStatusType["USE_PROXY"] = 205] = "USE_PROXY";
	    HTTPStatusType[HTTPStatusType["TEMPORARY_REDIRECT"] = 307] = "TEMPORARY_REDIRECT";
	    HTTPStatusType[HTTPStatusType["PERMANENT_REDIRECT"] = 308] = "PERMANENT_REDIRECT";
	    // client error
	    HTTPStatusType[HTTPStatusType["BAD_REQUEST"] = 400] = "BAD_REQUEST";
	    HTTPStatusType[HTTPStatusType["UNAUTHORIZED"] = 401] = "UNAUTHORIZED";
	    HTTPStatusType[HTTPStatusType["PAYMENT_REQUIRED"] = 402] = "PAYMENT_REQUIRED";
	    HTTPStatusType[HTTPStatusType["FORBIDDEN"] = 403] = "FORBIDDEN";
	    HTTPStatusType[HTTPStatusType["NOT_FOUND"] = 404] = "NOT_FOUND";
	    HTTPStatusType[HTTPStatusType["METHOD_NOT_ALLOWED"] = 405] = "METHOD_NOT_ALLOWED";
	    HTTPStatusType[HTTPStatusType["NOT_ACCEPTABLE"] = 406] = "NOT_ACCEPTABLE";
	    HTTPStatusType[HTTPStatusType["PROXY_AUTHENTICATION_REQUIRED"] = 407] = "PROXY_AUTHENTICATION_REQUIRED";
	    HTTPStatusType[HTTPStatusType["REQUEST_TIMEOUT"] = 408] = "REQUEST_TIMEOUT";
	    HTTPStatusType[HTTPStatusType["CONFLICT"] = 409] = "CONFLICT";
	    HTTPStatusType[HTTPStatusType["GONE"] = 410] = "GONE";
	    HTTPStatusType[HTTPStatusType["LENGTH_REQUIRED"] = 411] = "LENGTH_REQUIRED";
	    HTTPStatusType[HTTPStatusType["PRECONDITION_FALIED"] = 4012] = "PRECONDITION_FALIED";
	    HTTPStatusType[HTTPStatusType["REQUEST_ENTITY_TOO_LARGE"] = 413] = "REQUEST_ENTITY_TOO_LARGE";
	    HTTPStatusType[HTTPStatusType["REQUEST_URI_TOO_LONG"] = 414] = "REQUEST_URI_TOO_LONG";
	    HTTPStatusType[HTTPStatusType["UNSUPPORTED_MEDIA_TYPE"] = 415] = "UNSUPPORTED_MEDIA_TYPE";
	    HTTPStatusType[HTTPStatusType["REQUESTED_RANGE_NOT_SATISFIED"] = 416] = "REQUESTED_RANGE_NOT_SATISFIED";
	    HTTPStatusType[HTTPStatusType["EXPECTATION_FAILED"] = 417] = "EXPECTATION_FAILED";
	    HTTPStatusType[HTTPStatusType["IM_A_TEAPOT"] = 418] = "IM_A_TEAPOT";
	    HTTPStatusType[HTTPStatusType["ENHANCE_YOUR_CALM"] = 420] = "ENHANCE_YOUR_CALM";
	    HTTPStatusType[HTTPStatusType["UNPROCESSABLE_ENTITY"] = 422] = "UNPROCESSABLE_ENTITY";
	    HTTPStatusType[HTTPStatusType["LOCKED"] = 423] = "LOCKED";
	    HTTPStatusType[HTTPStatusType["FAILED_DEPENDENCY"] = 424] = "FAILED_DEPENDENCY";
	    HTTPStatusType[HTTPStatusType["TOO_MANY_REQUESTS"] = 429] = "TOO_MANY_REQUESTS";
	    HTTPStatusType[HTTPStatusType["REQUESTHEADER_FIELDS_TOO_LARGE"] = 431] = "REQUESTHEADER_FIELDS_TOO_LARGE";
	    HTTPStatusType[HTTPStatusType["NO_RESPONSE"] = 444] = "NO_RESPONSE";
	    HTTPStatusType[HTTPStatusType["RETRY_WITH"] = 449] = "RETRY_WITH";
	    HTTPStatusType[HTTPStatusType["UNAVAILABLE_FOR_LEGAL_REASONS"] = 451] = "UNAVAILABLE_FOR_LEGAL_REASONS";
	    HTTPStatusType[HTTPStatusType["CLIENT_COSED_REQUEST"] = 499] = "CLIENT_COSED_REQUEST";
	    // server error
	    HTTPStatusType[HTTPStatusType["INTERNAL_SERVER_ERROR"] = 500] = "INTERNAL_SERVER_ERROR";
	    HTTPStatusType[HTTPStatusType["NOT_IMPLEMENTED"] = 501] = "NOT_IMPLEMENTED";
	    HTTPStatusType[HTTPStatusType["BAD_GATEWAY"] = 502] = "BAD_GATEWAY";
	    HTTPStatusType[HTTPStatusType["SERVICE_UNAVAILABLE"] = 53] = "SERVICE_UNAVAILABLE";
	    HTTPStatusType[HTTPStatusType["GATEWAY_TIMEOUT"] = 504] = "GATEWAY_TIMEOUT";
	    HTTPStatusType[HTTPStatusType["HTTP_VERSION_NOT_SUPPORTED"] = 505] = "HTTP_VERSION_NOT_SUPPORTED";
	    HTTPStatusType[HTTPStatusType["VARIANT_ALSO_NEGOTIATES"] = 506] = "VARIANT_ALSO_NEGOTIATES";
	    HTTPStatusType[HTTPStatusType["INSUFFICIENT_STORAGE"] = 501] = "INSUFFICIENT_STORAGE";
	    HTTPStatusType[HTTPStatusType["LOOP_DETECTED"] = 508] = "LOOP_DETECTED";
	    HTTPStatusType[HTTPStatusType["BANDWIDTH_LIMIT_EXCEEDED"] = 509] = "BANDWIDTH_LIMIT_EXCEEDED";
	    HTTPStatusType[HTTPStatusType["NOT_EXTENDED"] = 510] = "NOT_EXTENDED";
	    HTTPStatusType[HTTPStatusType["NTETWORK_AUTHENTICATION_REQUIRED"] = 511] = "NTETWORK_AUTHENTICATION_REQUIRED";
	    HTTPStatusType[HTTPStatusType["NETWORK_READ_TIMEOUT_ERROR"] = 590] = "NETWORK_READ_TIMEOUT_ERROR";
	    HTTPStatusType[HTTPStatusType["NETWORK_CONNECT_TIMEOUT_ERROR"] = 599] = "NETWORK_CONNECT_TIMEOUT_ERROR";
	})(exports.HTTPStatusType || (exports.HTTPStatusType = {}));
	var HTTPStatusType = exports.HTTPStatusType;
	// TODO - HTTPRequest & HTTPResponse classes should be somewhere else such as @tandem/synthetic-server
	class HTTPRequest {
	    constructor(method, url, headers = {}) {
	        this.method = method;
	        this.url = url;
	        this.headers = headers;
	        this.type = HTTPRequest.HTTP_REQUEST;
	    }
	}
	HTTPRequest.HTTP_REQUEST = "httpRequest";
	exports.HTTPRequest = HTTPRequest;
	// maintaining the codebase conventions here... >.>
	class HTTPResponse {
	    constructor(status, headers = {}) {
	        this.status = status;
	        this.headers = headers;
	        this.type = HTTPResponse.HTTP_RESPONSE;
	    }
	}
	HTTPResponse.HTTP_RESPONSE = "httpResponse";
	exports.HTTPResponse = HTTPResponse;


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	class SyntheticDOMEvent extends common_1.CoreEvent {
	    constructor(type) {
	        super(type);
	        this.type = type;
	    }
	}
	exports.SyntheticDOMEvent = SyntheticDOMEvent;
	var DOMEventTypes;
	(function (DOMEventTypes) {
	    /**
	     * Fired when all nodes have been added to the Document object -- different from LOAD
	     * since DOM_CONTENT_LOADED doesn't wait for other assets such as stylesheet loads.
	     */
	    DOMEventTypes.DOM_CONTENT_LOADED = "DOMContentLoaded";
	    /**
	     * Fired after all assets and DOM content has loaded
	     */
	    DOMEventTypes.LOAD = "load";
	})(DOMEventTypes = exports.DOMEventTypes || (exports.DOMEventTypes = {}));
	class DOMEventDispatcher {
	    constructor(type, listener) {
	        this.type = type;
	        this.listener = listener;
	    }
	    dispatch(event) {
	        // TODO - check bool return value from event listener
	        if (event.type === this.type) {
	            this.listener(event);
	        }
	    }
	}
	exports.DOMEventDispatcher = DOMEventDispatcher;
	// TODO - implement capture bool check
	class DOMEventDispatcherMap {
	    constructor(target) {
	        this.target = target;
	        this._map = new Map();
	    }
	    add(type, listener, capture) {
	        const observer = new DOMEventDispatcher(type, listener);
	        if (!this._map.has(type)) {
	            this._map.set(type, []);
	        }
	        this._map.get(type).push(observer);
	        this.target.observe(observer);
	    }
	    remove(type, listener, capture) {
	        const observers = this._map.get(type) || [];
	        for (let i = observers.length; i--;) {
	            const observer = observers[i];
	            if (observer.listener === listener) {
	                observers.splice(i, 1);
	                this.target.unobserve(observer);
	                break;
	            }
	        }
	    }
	}
	exports.DOMEventDispatcherMap = DOMEventDispatcherMap;


/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const sandbox_1 = __webpack_require__(167);
	const mesh_1 = __webpack_require__(13);
	const common_1 = __webpack_require__(46);
	const messages_1 = __webpack_require__(287);
	let XHRServer = class XHRServer {
	    constructor(window) {
	    }
	    dispatch(request) {
	        if (request.type !== messages_1.HTTPRequest.HTTP_REQUEST)
	            return;
	        return new mesh_1.DuplexStream((input, output) => {
	            const writer = output.getWriter();
	            const response = new messages_1.HTTPResponse(messages_1.HTTPStatusType.OK, {
	                contentType: "text/plain"
	            });
	            writer.write(response);
	            this.logger.info(`XHR ${request.method} ${request.url}`);
	            // TODO - do not assume FS - only assuming for now to get certain features to work
	            this._fs.readFile(request.url).catch((e) => {
	                writer.abort(e);
	            }).then((buffer) => {
	                writer.write(String(buffer));
	                writer.close();
	            });
	        });
	    }
	};
	__decorate([
	    common_1.inject(sandbox_1.FileSystemProvider.ID)
	], XHRServer.prototype, "_fs", void 0);
	XHRServer = __decorate([
	    common_1.loggable()
	], XHRServer);
	exports.XHRServer = XHRServer;


/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const vm = __webpack_require__(202);
	const location_1 = __webpack_require__(228);
	const dom_1 = __webpack_require__(223);
	const renderers_1 = __webpack_require__(219);
	const common_1 = __webpack_require__(46);
	const sandbox_1 = __webpack_require__(167);
	const providers_1 = __webpack_require__(291);
	let BaseSyntheticBrowser = class BaseSyntheticBrowser extends common_1.Observable {
	    constructor(_injector, renderer, parent) {
	        super();
	        this._injector = _injector;
	        this.parent = parent;
	        this.status = new common_1.Status(null);
	        this.uid = sandbox_1.generateSyntheticUID();
	        _injector.inject(this);
	        this._renderer = _injector.inject(common_1.isMaster ? renderer || new renderers_1.SyntheticDOMRenderer() : new renderers_1.NoopRenderer());
	        this._renderer.observe(new common_1.BubbleDispatcher(this));
	        this._documentObserver = new common_1.BubbleDispatcher(this);
	    }
	    $didInject() { }
	    get document() {
	        return this.window && this.window.document;
	    }
	    get injector() {
	        return this._injector;
	    }
	    get location() {
	        return this._location;
	    }
	    get window() {
	        return this._window;
	    }
	    setWindow(value) {
	        if (this._window) {
	            this._window.document.unobserve(this._documentObserver);
	        }
	        const oldWindow = this._window;
	        this._window = value;
	        this._renderer.document = value.document;
	        this._window.document.observe(this._documentObserver);
	        this.notify(new common_1.PropertyMutation(common_1.PropertyMutation.PROPERTY_CHANGE, this, "window", value, oldWindow).toEvent());
	    }
	    get renderer() {
	        return this._renderer;
	    }
	    get openOptions() {
	        return this._openOptions;
	    }
	    open(options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (JSON.stringify(this._openOptions) === JSON.stringify(options) && this._window) {
	                return;
	            }
	            this._openOptions = options;
	            this._location = new location_1.SyntheticLocation(options.url);
	            yield this.open2(options);
	        });
	    }
	};
	__decorate([
	    common_1.bindable()
	], BaseSyntheticBrowser.prototype, "status", void 0);
	BaseSyntheticBrowser = __decorate([
	    common_1.loggable()
	], BaseSyntheticBrowser);
	exports.BaseSyntheticBrowser = BaseSyntheticBrowser;
	class SyntheticBrowser extends BaseSyntheticBrowser {
	    $didInject() {
	        super.$didInject();
	        this._sandbox = new sandbox_1.Sandbox(this._injector, this.createSandboxGlobals.bind(this));
	        common_1.watchProperty(this._sandbox, "status", this.onSandboxStatusChange.bind(this));
	        common_1.watchProperty(this._sandbox, "exports", this.onSandboxExportsChange.bind(this));
	        common_1.watchProperty(this._sandbox, "global", this.setWindow.bind(this));
	    }
	    get sandbox() {
	        return this._sandbox;
	    }
	    open2(options) {
	        return __awaiter(this, void 0, void 0, function* () {
	            this._script = options.injectScript;
	            this.logger.info(`Opening ${options.url} ...`);
	            const timerLogger = this.logger.startTimer();
	            const strategyOptions = options.dependencyGraphStrategyOptions || sandbox_1.DependencyGraphStrategyOptionsProvider.find(options.url, this._injector);
	            const graph = this._graph = sandbox_1.DependencyGraphProvider.getInstance(strategyOptions, this._injector);
	            this._entry = yield graph.getDependency(yield graph.resolve(options.url, "/"));
	            yield this._sandbox.open(this._entry);
	            timerLogger.stop(`Loaded ${options.url}`);
	        });
	    }
	    onSandboxStatusChange(newStatus) {
	        if (newStatus.type !== common_1.Status.COMPLETED) {
	            this.status = newStatus.clone();
	        }
	    }
	    get document() {
	        return this.window && this.window.document;
	    }
	    createSandboxGlobals() {
	        const window = new dom_1.SyntheticWindow(this.location, this, undefined);
	        this._registerElementClasses(window.document);
	        Object.assign(window, this._graph.createGlobalContext());
	        // user injected script to tweak the state of an app
	        this._injectScript(window);
	        return window;
	    }
	    _injectScript(window) {
	        if (!this._script)
	            return;
	        vm.runInNewContext(this._script, window);
	    }
	    _registerElementClasses(document) {
	        for (const dependency of providers_1.SyntheticDOMElementClassProvider.findAll(this._injector)) {
	            document.registerElementNS(dependency.xmlns, dependency.tagName, dependency.value);
	        }
	    }
	    onSandboxExportsChange(exports) {
	        return __awaiter(this, void 0, void 0, function* () {
	            const window = this._sandbox.global;
	            const document = window.document;
	            let exportsElement;
	            this.logger.debug("Evaluated entry", this.location.toString());
	            try {
	                if (exports.documentElement || exports.createDocumentElement) {
	                    document.removeAllChildren();
	                    document.appendChild(exports.documentElement || exports.createDocumentElement());
	                }
	                if (exports.bodyElement || exports.createBodyElement) {
	                    document.removeAllChildren();
	                    document.body.appendChild(exports.bodyElement || exports.createBodyElement());
	                }
	            }
	            catch (e) {
	                this.status = new common_1.Status(common_1.Status.ERROR, e);
	                throw e;
	            }
	            window.$doneLoading();
	            // quick fix to get synthetic window to fire load events
	            this.status = new common_1.Status(common_1.Status.COMPLETED);
	        });
	    }
	}
	exports.SyntheticBrowser = SyntheticBrowser;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	class SyntheticDOMElementClassProvider extends common_1.Provider {
	    constructor(xmlns, tagName, value) {
	        super(SyntheticDOMElementClassProvider.getNamespace(xmlns, tagName), value);
	        this.xmlns = xmlns;
	        this.tagName = tagName;
	    }
	    clone() {
	        return new SyntheticDOMElementClassProvider(this.xmlns, this.tagName, this.value);
	    }
	    static getNamespace(xmlns, tagName) {
	        return [this.SYNTHETIC_ELEMENT_CLASS_NS, encodeURIComponent(xmlns), tagName].join("/");
	    }
	    static findAll(injector) {
	        return injector.queryAll([this.SYNTHETIC_ELEMENT_CLASS_NS, "**"].join("/"));
	    }
	}
	SyntheticDOMElementClassProvider.SYNTHETIC_ELEMENT_CLASS_NS = "syntheticMarkupElementClass";
	exports.SyntheticDOMElementClassProvider = SyntheticDOMElementClassProvider;
	class MarkupMimeTypeXMLNSProvider extends common_1.Provider {
	    constructor(mimeType, xmlns) {
	        super(MarkupMimeTypeXMLNSProvider.getNamespace(mimeType), xmlns);
	        this.mimeType = mimeType;
	        this.xmlns = xmlns;
	    }
	    static getNamespace(mimeType) {
	        return [this.MARKUP_MIME_TYPE_XMLNS, mimeType].join("/");
	    }
	    static lookup(path, injector) {
	        const mimeType = common_1.MimeTypeProvider.lookup(path, injector);
	        const provider = injector.query(this.getNamespace(mimeType));
	        return provider && provider.value;
	    }
	}
	MarkupMimeTypeXMLNSProvider.MARKUP_MIME_TYPE_XMLNS = "markupMimeTypeXMLNS";
	exports.MarkupMimeTypeXMLNSProvider = MarkupMimeTypeXMLNSProvider;


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(293));
	__export(__webpack_require__(294));


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const postcss = __webpack_require__(267);
	const lodash_1 = __webpack_require__(56);
	const common_1 = __webpack_require__(46);
	const synthetic_browser_1 = __webpack_require__(216);
	const sandbox_1 = __webpack_require__(167);
	// TODO - move this to synthetic-browser
	// TODO - may need to split this out into separate CSS editors. Some of this is specific
	// to SASS
	class CSSEditor extends sandbox_1.BaseContentEditor {
	    [synthetic_browser_1.SyntheticCSSElementStyleRuleMutationTypes.SET_RULE_SELECTOR](node, { target, newValue }) {
	        const source = target.source;
	        node.selector = newValue;
	    }
	    [synthetic_browser_1.CSSGroupingRuleMutationTypes.REMOVE_RULE_EDIT](node, { target, child }) {
	        const childNode = this.findTargetASTNode(node, child);
	        childNode.parent.removeChild(childNode);
	    }
	    [synthetic_browser_1.CSSGroupingRuleMutationTypes.MOVE_RULE_EDIT](node, { target, child, index }) {
	        const childNode = this.findTargetASTNode(node, child);
	        const parent = childNode.parent;
	        parent.removeChild(childNode);
	        parent.insertBefore(node.nodes[index], childNode);
	    }
	    [synthetic_browser_1.CSSGroupingRuleMutationTypes.INSERT_RULE_EDIT](node, { target, child, index }) {
	        let newChild = child;
	        const newChildNode = {
	            rule(rule) {
	                const ruleNode = postcss.rule({
	                    selector: rule.selector,
	                });
	                for (const key in rule.style.toObject()) {
	                    ruleNode.append(postcss.decl({
	                        prop: key,
	                        value: rule.style[key]
	                    }));
	                }
	                return ruleNode;
	            },
	            atrule(atrule) {
	                const ruleNode = postcss.atRule({
	                    name: atrule.atRuleName,
	                    params: atrule.params
	                });
	                for (const rule of atrule.cssRules) {
	                    ruleNode.append(this[rule.source.kind](rule));
	                }
	                return ruleNode;
	            }
	        }[newChild.source.kind](newChild);
	        if (index >= node.nodes.length) {
	            node.append(newChildNode);
	        }
	        else {
	            node.each((child, i) => {
	                if (child.parent === node && i === index) {
	                    node.insertBefore(child, newChildNode);
	                    return false;
	                }
	            });
	        }
	    }
	    [synthetic_browser_1.SyntheticCSSElementStyleRuleMutationTypes.SET_DECLARATION](node, { target, name, newValue, oldName, index }) {
	        const source = target.source;
	        name = lodash_1.kebabCase(name);
	        let found;
	        let foundIndex = -1;
	        const shouldAdd = node.walkDecls((decl, index) => {
	            if (decl.prop === name || decl.prop === oldName) {
	                if (name && newValue) {
	                    decl.prop = name;
	                    decl.value = newValue;
	                    foundIndex = index;
	                }
	                else {
	                    node.removeChild(decl);
	                }
	                found = true;
	            }
	        });
	        if (index != null, foundIndex > -1 && foundIndex !== index) {
	            const decl = node.nodes[foundIndex];
	            node.removeChild(decl);
	            if (index === node.nodes.length) {
	                node.append(decl);
	            }
	            else {
	                node.insertBefore(node.nodes[index], decl);
	            }
	        }
	        if (!found && newValue) {
	            node.append(postcss.decl({ prop: name, value: newValue }));
	        }
	    }
	    findTargetASTNode(root, target) {
	        let found;
	        const walk = (node, index) => {
	            if (found)
	                return false;
	            if (this.nodeMatchesSyntheticSource(node, target.source)) {
	                found = node;
	                return false;
	            }
	        };
	        if (walk(root, -1) !== false) {
	            root.walk(walk);
	        }
	        return found;
	    }
	    nodeMatchesSyntheticSource(node, source) {
	        return node.type === source.kind && node.source && common_1.sourcePositionEquals(node.source.start, source.start);
	    }
	    parseContent(content) {
	        return synthetic_browser_1.parseCSS(content, undefined, null, false);
	    }
	    getFormattedContent(root) {
	        // try parsing again. This should throw an error if any edits are invalid.
	        synthetic_browser_1.parseCSS(root.toString());
	        return root.toString();
	    }
	}
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], CSSEditor.prototype, "_injector", void 0);
	exports.CSSEditor = CSSEditor;
	function isRuleNode(node) {
	    return node.type === "rule";
	}


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	const sandbox_1 = __webpack_require__(167);
	const synthetic_browser_1 = __webpack_require__(216);
	class MarkupEditor extends sandbox_1.BaseContentEditor {
	    [common_1.RemoveMutation.REMOVE_CHANGE](node, { target }) {
	        node.parent.removeChild(node);
	    }
	    [synthetic_browser_1.SyntheticDOMValueNodeMutationTypes.SET_VALUE_NODE_EDIT](node, { target, newValue }) {
	        node.nodeValue = newValue;
	    }
	    [synthetic_browser_1.SyntheticDOMElementMutationTypes.SET_ELEMENT_ATTRIBUTE_EDIT](node, { target, name, newValue, oldName, index }) {
	        const syntheticElement = target;
	        if (newValue == null) {
	            node.removeAttribute(name);
	        }
	        else {
	            node.setAttribute(name, newValue, index);
	        }
	        if (oldName) {
	            node.removeAttribute(oldName);
	        }
	    }
	    [synthetic_browser_1.SyntheticDOMContainerMutationTypes.INSERT_CHILD_NODE_EDIT](node, { target, child, index }) {
	        const childExpression = synthetic_browser_1.parseMarkup(child.toString());
	        node.childNodes.splice(index, 0, childExpression);
	    }
	    [synthetic_browser_1.SyntheticDOMContainerMutationTypes.REMOVE_CHILD_NODE_EDIT](node, { target, child, index }) {
	        const childNode = this.findTargetASTNode(node, child);
	        node.childNodes.splice(node.childNodes.indexOf(childNode), 1);
	    }
	    [synthetic_browser_1.SyntheticDOMContainerMutationTypes.MOVE_CHILD_NODE_EDIT](node, { target, child, index }) {
	        const childNode = this.findTargetASTNode(node, child);
	        node.childNodes.splice(node.childNodes.indexOf(childNode), 1);
	        node.childNodes.splice(index, 0, childNode);
	    }
	    findTargetASTNode(root, synthetic) {
	        return synthetic_browser_1.findMarkupExpression(root, (expression) => {
	            return expression.kind === synthetic.source.kind && common_1.sourcePositionEquals(expression.location.start, synthetic.source.start);
	        });
	    }
	    parseContent(content) {
	        return synthetic_browser_1.parseMarkup(content);
	    }
	    getFormattedContent(root) {
	        return synthetic_browser_1.formatMarkupExpression(root);
	    }
	}
	exports.MarkupEditor = MarkupEditor;


/***/ },
/* 295 */
/***/ function(module, exports) {

	"use strict";
	exports.TDPROJECT_XMLNS = "tandem";
	exports.TDPROJECT_MIME_TYPE = "text/tdproject";
	exports.TD_FILE_EXTENSIONS = ["tdm", "tandem"];


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(297));
	__export(__webpack_require__(300));
	__export(__webpack_require__(301));
	__export(__webpack_require__(314));
	__export(__webpack_require__(315));
	__export(__webpack_require__(316));
	__export(__webpack_require__(317));
	__export(__webpack_require__(318));
	__export(__webpack_require__(319));
	__export(__webpack_require__(321));
	__export(__webpack_require__(322));
	__export(__webpack_require__(323));
	__export(__webpack_require__(324));


/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {"use strict";
	const base_1 = __webpack_require__(298);
	const mesh_1 = __webpack_require__(13);
	const node_1 = __webpack_require__(158);
	const child_process_1 = __webpack_require__(159);
	class SpawnWorkerCommand extends base_1.BaseStudioMasterCommand {
	    execute(action) {
	        const proxy = new mesh_1.ProxyBus();
	        const forkNode = () => {
	            // need to completely separate from master process so that native node modules on the 
	            // user machine work properly.
	            const proc = child_process_1.spawn(process.env.npm_node_execpath, [__dirname + "/../../index.js"], {
	                env: process.env,
	                stdio: ["inherit", "inherit", "inherit", "ipc"]
	            });
	            proxy.target = node_1.createProcessBus(this.config.family, proc, this.bus);
	            proc.on("close", () => {
	                setTimeout(forkNode, 500);
	            });
	        };
	        // TODO - check if node actually exists on system before doing this
	        forkNode();
	        this.bus.register(proxy);
	    }
	}
	exports.SpawnWorkerCommand = SpawnWorkerCommand;

	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const core_1 = __webpack_require__(165);
	const common_1 = __webpack_require__(46);
	const providers_1 = __webpack_require__(299);
	class BaseStudioMasterCommand extends common_1.BaseCommand {
	}
	__decorate([
	    common_1.inject(providers_1.TandemMasterStudioStoreProvider.ID)
	], BaseStudioMasterCommand.prototype, "masterStore", void 0);
	__decorate([
	    common_1.inject(core_1.ApplicationConfigurationProvider.ID)
	], BaseStudioMasterCommand.prototype, "config", void 0);
	exports.BaseStudioMasterCommand = BaseStudioMasterCommand;


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	const common_2 = __webpack_require__(46);
	class ProjectStarterFactoryProvider extends common_1.ClassFactoryProvider {
	    constructor(option, clazz) {
	        super(ProjectStarterFactoryProvider.getId(option.id), clazz);
	        this.option = option;
	        this.clazz = clazz;
	    }
	    create(option) {
	        return super.create(option);
	    }
	    static getId(name) {
	        return [this.NS, name].join("/");
	    }
	    clone() {
	        return new ProjectStarterFactoryProvider(this.option, this.clazz);
	    }
	    static create(option, injector) {
	        const provider = injector.query(this.getId(option.id));
	        return provider && provider.create(option);
	    }
	}
	ProjectStarterFactoryProvider.NS = "projectStarters";
	exports.ProjectStarterFactoryProvider = ProjectStarterFactoryProvider;
	class TandemMasterStudioStoreProvider extends common_2.StoreProvider {
	    constructor(clazz) {
	        super("tandemMasterStudio", clazz);
	    }
	}
	TandemMasterStudioStoreProvider.ID = common_2.StoreProvider.getId("tandemMasterStudio");
	exports.TandemMasterStudioStoreProvider = TandemMasterStudioStoreProvider;


/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const electron_1 = __webpack_require__(2);
	const base_1 = __webpack_require__(298);
	class OpenNewWorkspaceCommand extends base_1.BaseStudioMasterCommand {
	    execute({ filePath }) {
	        this.logger.info(`Opening workspace: ${filePath}`);
	        try {
	            let hash = "";
	            let width = 600;
	            let height = 400;
	            let frame = true;
	            const query = {
	                backendPort: this.config.port
	            };
	            if (filePath) {
	                width = 1024;
	                height = 768;
	                hash = `#/workspace?workspacePath=${encodeURIComponent(filePath)}`;
	            }
	            else {
	                hash = "#/welcome";
	                frame = false;
	            }
	            const win = new electron_1.BrowserWindow({ width: width, height: height, frame: frame, titleBarStyle: frame ? "hidden-inset" : undefined });
	            win.loadURL(`${this.config.browser.indexUrl}?backendPort=${this.config.port}${hash}`);
	            if (this.config.argv["dev-tools"]) {
	                win["toggleDevTools"]();
	            }
	        }
	        catch (e) {
	            console.error(e.stack);
	        }
	    }
	}
	exports.OpenNewWorkspaceCommand = OpenNewWorkspaceCommand;


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const fs = __webpack_require__(174);
	const path = __webpack_require__(6);
	const glob = __webpack_require__(302);
	const base_1 = __webpack_require__(298);
	const common_1 = __webpack_require__(303);
	function fileExists(filePath) {
	    return fs.existsSync(filePath) && !fs.lstatSync(filePath).isDirectory();
	}
	class CLIOpenWorkspaceCommand extends base_1.BaseStudioMasterCommand {
	    execute() {
	        let filePath = this.config.argv._[0];
	        // scan the CWD for any tandem files
	        if (filePath != null && !fileExists(filePath)) {
	            filePath = filePath.replace(/^\./, process.cwd()).replace(/^~/, process.env.HOME);
	            if (!fileExists(filePath)) {
	                filePath = glob.sync(path.join(filePath, `{${this.config.projectFileExtensions.map(ext => `*.${ext}`).join(",")}}`)).find((filePath) => {
	                    return true;
	                });
	            }
	        }
	        // open new workspace anyways -- the user will be prompted to open a file from there
	        if (!filePath) {
	            return this.bus.dispatch(new common_1.OpenNewWorkspaceRequest(undefined));
	        }
	        if (filePath.substr(0, 1) !== "/") {
	            filePath = path.join(process.cwd(), filePath);
	        }
	        if (!fileExists(filePath)) {
	            this.logger.error(`Cannot open ${filePath}: File does not exist.`);
	            return;
	        }
	        return this.bus.dispatch(new common_1.OpenNewWorkspaceRequest(filePath));
	    }
	}
	exports.CLIOpenWorkspaceCommand = CLIOpenWorkspaceCommand;


/***/ },
/* 302 */
/***/ function(module, exports) {

	module.exports = require("glob");

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(304));
	__export(__webpack_require__(305));
	__export(__webpack_require__(8));
	__export(__webpack_require__(308));


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const common_1 = __webpack_require__(8);
	const sandbox_1 = __webpack_require__(167);
	const common_2 = __webpack_require__(8);
	const mesh_1 = __webpack_require__(13);
	// scoping here
	mesh_1.addMessageVisitor(common_1.EditorFamilyType.MASTER)(mesh_1.setMessageTarget(common_1.EditorFamilyType.WORKER)(sandbox_1.ApplyFileEditRequest));
	mesh_1.addMessageVisitor(common_1.EditorFamilyType.MASTER)(mesh_1.setMessageTarget(common_1.EditorFamilyType.WORKER)(common_2.OpenRemoteBrowserRequest));
	let PingRequest_1 = class PingRequest {
	    constructor() {
	        this.type = PingRequest_1.PING;
	    }
	};
	let PingRequest = PingRequest_1;
	PingRequest.PING = "ping";
	PingRequest = PingRequest_1 = __decorate([
	    mesh_1.setMessageTarget(common_1.EditorFamilyType.MASTER)
	], PingRequest);
	exports.PingRequest = PingRequest;
	let OpenGettingStartedProjectRequest_1 = class OpenGettingStartedProjectRequest {
	    constructor() {
	        this.type = OpenGettingStartedProjectRequest_1.OPEN_GETTING_STARTED;
	    }
	};
	let OpenGettingStartedProjectRequest = OpenGettingStartedProjectRequest_1;
	OpenGettingStartedProjectRequest.OPEN_GETTING_STARTED = "openGettingStarted";
	OpenGettingStartedProjectRequest = OpenGettingStartedProjectRequest_1 = __decorate([
	    mesh_1.setMessageTarget(common_1.EditorFamilyType.MASTER)
	], OpenGettingStartedProjectRequest);
	exports.OpenGettingStartedProjectRequest = OpenGettingStartedProjectRequest;
	let GetProjectStartOptionsRequest_1 = class GetProjectStartOptionsRequest {
	    constructor() {
	        this.type = GetProjectStartOptionsRequest_1.GET_PROJECT_STARTER_OPTIONS;
	    }
	    static dispatch(bus) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return yield mesh_1.readAllChunks(bus.dispatch(new GetProjectStartOptionsRequest_1()));
	        });
	    }
	};
	let GetProjectStartOptionsRequest = GetProjectStartOptionsRequest_1;
	GetProjectStartOptionsRequest.GET_PROJECT_STARTER_OPTIONS = "getProjectStarterOption";
	GetProjectStartOptionsRequest = GetProjectStartOptionsRequest_1 = __decorate([
	    mesh_1.setMessageTarget(common_1.EditorFamilyType.MASTER)
	], GetProjectStartOptionsRequest);
	exports.GetProjectStartOptionsRequest = GetProjectStartOptionsRequest;
	let StartNewProjectRequest_1 = class StartNewProjectRequest {
	    constructor(option, directoryPath) {
	        this.option = option;
	        this.directoryPath = directoryPath;
	        this.type = StartNewProjectRequest_1.START_NEW_PROJECT;
	    }
	    static dispatch(option, directoryPath, bus) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return (yield mesh_1.readOneChunk(bus.dispatch(new StartNewProjectRequest_1(option, directoryPath)))).value;
	        });
	    }
	};
	let StartNewProjectRequest = StartNewProjectRequest_1;
	StartNewProjectRequest.START_NEW_PROJECT = "startNewProject";
	StartNewProjectRequest = StartNewProjectRequest_1 = __decorate([
	    mesh_1.setMessageTarget(common_1.EditorFamilyType.MASTER)
	], StartNewProjectRequest);
	exports.StartNewProjectRequest = StartNewProjectRequest;
	let OpenNewWorkspaceRequest_1 = class OpenNewWorkspaceRequest {
	    constructor(filePath) {
	        this.filePath = filePath;
	        this.type = OpenNewWorkspaceRequest_1.OPEN_NEW_WORKSPACE;
	    }
	};
	let OpenNewWorkspaceRequest = OpenNewWorkspaceRequest_1;
	OpenNewWorkspaceRequest.OPEN_NEW_WORKSPACE = "openNewWorkspace";
	OpenNewWorkspaceRequest = OpenNewWorkspaceRequest_1 = __decorate([
	    mesh_1.setMessageTarget(common_1.EditorFamilyType.MASTER)
	], OpenNewWorkspaceRequest);
	exports.OpenNewWorkspaceRequest = OpenNewWorkspaceRequest;
	let SelectDirectoryRequest_1 = class SelectDirectoryRequest {
	    constructor() {
	        this.type = SelectDirectoryRequest_1.SELECT_DIRECTORY_REQUEST;
	    }
	    static dispatch(bus) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return (yield mesh_1.readOneChunk(bus.dispatch(new SelectDirectoryRequest_1()))).value;
	        });
	    }
	};
	let SelectDirectoryRequest = SelectDirectoryRequest_1;
	SelectDirectoryRequest.SELECT_DIRECTORY_REQUEST = "selectDirectoryRequest";
	SelectDirectoryRequest = SelectDirectoryRequest_1 = __decorate([
	    mesh_1.setMessageTarget(common_1.EditorFamilyType.MASTER)
	], SelectDirectoryRequest);
	exports.SelectDirectoryRequest = SelectDirectoryRequest;
	let GetHelpOptionsRequest_1 = class GetHelpOptionsRequest {
	    constructor() {
	        this.type = GetHelpOptionsRequest_1.GET_HELP_OPTIONS;
	    }
	    static dispatch(bus) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return mesh_1.readAllChunks(bus.dispatch(new GetHelpOptionsRequest_1()));
	        });
	    }
	};
	let GetHelpOptionsRequest = GetHelpOptionsRequest_1;
	GetHelpOptionsRequest.GET_HELP_OPTIONS = "getHelpOptions";
	GetHelpOptionsRequest = GetHelpOptionsRequest_1 = __decorate([
	    mesh_1.setMessageTarget(common_1.EditorFamilyType.MASTER)
	], GetHelpOptionsRequest);
	exports.GetHelpOptionsRequest = GetHelpOptionsRequest;
	let OpenHelpOptionRequest_1 = class OpenHelpOptionRequest {
	    constructor(option) {
	        this.option = option;
	        this.type = OpenHelpOptionRequest_1.OPEN_HELP_OPTION;
	    }
	    static dispatch(option, bus) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return bus.dispatch(new OpenHelpOptionRequest_1(option));
	        });
	    }
	};
	let OpenHelpOptionRequest = OpenHelpOptionRequest_1;
	OpenHelpOptionRequest.OPEN_HELP_OPTION = "openHelpOption";
	OpenHelpOptionRequest = OpenHelpOptionRequest_1 = __decorate([
	    mesh_1.setMessageTarget(common_1.EditorFamilyType.MASTER)
	], OpenHelpOptionRequest);
	exports.OpenHelpOptionRequest = OpenHelpOptionRequest;


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(306));
	__export(__webpack_require__(307));


/***/ },
/* 306 */
/***/ function(module, exports) {

	"use strict";


/***/ },
/* 307 */
/***/ function(module, exports) {

	"use strict";
	class ProjectFileHandler {
	    constructor({ test, createPreview, dependencyGraph }) {
	        if (test instanceof RegExp) {
	            this.test = filePath => test.test(filePath);
	        }
	        else {
	            this.test = test;
	        }
	        this.createPreview = createPreview;
	        this.dependencyGraph = dependencyGraph;
	    }
	}
	exports.ProjectFileHandler = ProjectFileHandler;
	class ProjectConfig {
	    constructor({ fileHandlers }) {
	        this.fileHandlers = (fileHandlers || []).map(options => new ProjectFileHandler(options));
	    }
	}
	exports.ProjectConfig = ProjectConfig;


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(309));


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const path = __webpack_require__(6);
	const constants_1 = __webpack_require__(310);
	const stores_1 = __webpack_require__(305);
	const common_1 = __webpack_require__(46);
	const worker_1 = __webpack_require__(311);
	const sandbox_1 = __webpack_require__(167);
	/**
	 * Loads the project config into the application in the form of extensions
	 */
	let LoadProjectConfigCommand = class LoadProjectConfigCommand {
	    execute() {
	        const configPath = path.join(process.cwd(), constants_1.PROJECT_CONFIG_FILE_NAME);
	        this.logger.info(`Loading project config ${configPath}`);
	        const { fileHandlers } = new stores_1.ProjectConfig(__webpack_require__(313)(configPath));
	        this._injector.register(fileHandlers.map((handler, i) => {
	            return [
	                new worker_1.PreviewLoaderProvider("projectPreviewLoader" + i, handler.test.bind(handler), createProjectPreviewLoader(handler)),
	                new sandbox_1.DependencyGraphStrategyOptionsProvider("graphStrategyOptions" + i, handler.test.bind(handler), handler.dependencyGraph.strategy)
	            ];
	        }));
	    }
	};
	__decorate([
	    common_1.inject(sandbox_1.FileSystemProvider.ID)
	], LoadProjectConfigCommand.prototype, "_fileSystem", void 0);
	__decorate([
	    common_1.inject(sandbox_1.FileResolverProvider.ID)
	], LoadProjectConfigCommand.prototype, "_fileResolver", void 0);
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], LoadProjectConfigCommand.prototype, "_injector", void 0);
	LoadProjectConfigCommand = __decorate([
	    common_1.loggable()
	], LoadProjectConfigCommand);
	exports.LoadProjectConfigCommand = LoadProjectConfigCommand;
	const createProjectPreviewLoader = (fileHandler) => {
	    return class ProjectPreviewLoader {
	        loadFilePreview(request) {
	            return __awaiter(this, void 0, void 0, function* () {
	                const ret = fileHandler.createPreview({
	                    filePath: request.filePath.replace(/file:\/\//, "")
	                });
	                return ret;
	            });
	        }
	    }
	    ;
	};


/***/ },
/* 310 */
/***/ function(module, exports) {

	// TODO - this needs to be deprecated for .tandem projects
	"use strict";
	exports.PROJECT_CONFIG_FILE_NAME = "tandem.config.js";


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(312));
	__export(__webpack_require__(8));


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const common_1 = __webpack_require__(46);
	class FileImporterProvider extends common_1.ClassFactoryProvider {
	    constructor(name, test, importerClass) {
	        super(FileImporterProvider.getId(name), importerClass);
	        this.name = name;
	        this.test = test;
	        this.importerClass = importerClass;
	    }
	    static getId(name) {
	        return [this.NS, name].join("/");
	    }
	    create() {
	        return super.create();
	    }
	    clone() {
	        return new FileImporterProvider(this.name, this.test, this.importerClass);
	    }
	    static findByDropTarget(request, injector) {
	        const importers = injector.queryAll(this.getId("**"));
	        const importer = importers.find(importer => importer.test(request));
	        return importer;
	    }
	}
	FileImporterProvider.NS = "fileImporters";
	exports.FileImporterProvider = FileImporterProvider;
	class SelfPreviewLoader {
	    loadFilePreview(request) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return {
	                filePath: request.filePath.replace(/^file:\/\//, "")
	            };
	        });
	    }
	}
	exports.SelfPreviewLoader = SelfPreviewLoader;
	class PreviewLoaderProvider extends common_1.ClassFactoryProvider {
	    constructor(name, test, loaderClass) {
	        super(PreviewLoaderProvider.getId(name), loaderClass);
	        this.name = name;
	        this.test = test;
	        this.loaderClass = loaderClass;
	    }
	    static getId(name) {
	        return [this.NS, name].join("/");
	    }
	    create() {
	        return super.create();
	    }
	    clone() {
	        return new PreviewLoaderProvider(this.name, this.test, this.loaderClass);
	    }
	    static find(filePath, injector) {
	        const providers = injector.queryAll(this.getId("**"));
	        const provider = providers.find(provider => provider.test(filePath, injector));
	        return provider && provider.create();
	    }
	}
	PreviewLoaderProvider.NS = "filePreviewLoaders";
	exports.PreviewLoaderProvider = PreviewLoaderProvider;


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./index": 308,
		"./index.ts": 308,
		"./load-project-config": 309,
		"./load-project-config.ts": 309
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 313;


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const base_1 = __webpack_require__(298);
	const electron_1 = __webpack_require__(2);
	class SelectDirectoryCommand extends base_1.BaseStudioMasterCommand {
	    execute() {
	        return electron_1.dialog.showOpenDialog({
	            properties: ["openDirectory"]
	        })[0];
	    }
	}
	exports.SelectDirectoryCommand = SelectDirectoryCommand;


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const common_1 = __webpack_require__(46);
	const common_2 = __webpack_require__(46);
	const sandbox_1 = __webpack_require__(167);
	const worker_1 = __webpack_require__(311);
	let ImportFileCommand = class ImportFileCommand {
	    execute(request) {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.logger.info(`Importing ${request.filePath}`);
	            const importerProvider = worker_1.FileImporterProvider.findByDropTarget(request, this._injector);
	            if (!importerProvider) {
	                throw new Error(`File type supported.`);
	            }
	            const importer = importerProvider.create();
	            yield importer.importFile(request);
	        });
	    }
	};
	__decorate([
	    common_1.inject(sandbox_1.FileSystemProvider.ID)
	], ImportFileCommand.prototype, "_fileSystem", void 0);
	__decorate([
	    common_1.inject(common_2.InjectorProvider.ID)
	], ImportFileCommand.prototype, "_injector", void 0);
	ImportFileCommand = __decorate([
	    common_1.loggable()
	], ImportFileCommand);
	exports.ImportFileCommand = ImportFileCommand;


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const common_1 = __webpack_require__(46);
	const providers_1 = __webpack_require__(299);
	class GetProjectStarterOptionsCommand extends common_1.BaseCommand {
	    execute() {
	        return this._providers.map(provider => provider.option);
	    }
	}
	__decorate([
	    common_1.injectProvider(providers_1.ProjectStarterFactoryProvider.getId("**"))
	], GetProjectStarterOptionsCommand.prototype, "_providers", void 0);
	exports.GetProjectStarterOptionsCommand = GetProjectStarterOptionsCommand;


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const common_1 = __webpack_require__(46);
	const providers_1 = __webpack_require__(299);
	class StartProjectCommand extends common_1.BaseCommand {
	    execute(request) {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.logger.info(`Starting new ${request.option.label} project in ${request.directoryPath}`);
	            const starter = providers_1.ProjectStarterFactoryProvider.create(request.option, this.injector);
	            const { workspaceFilePath } = yield starter.start(request.directoryPath);
	            return workspaceFilePath;
	        });
	    }
	}
	exports.StartProjectCommand = StartProjectCommand;


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const base_1 = __webpack_require__(298);
	const synthetic_browser_1 = __webpack_require__(216);
	const glob = __webpack_require__(302);
	const fs = __webpack_require__(174);
	class GetHelpOptionsCommand extends base_1.BaseStudioMasterCommand {
	    execute() {
	        return glob.sync(this.config.help.directory + "/**/*.tandem").map((filePath) => {
	            const { document } = new synthetic_browser_1.SyntheticWindow();
	            document.body.innerHTML = fs.readFileSync(filePath, "utf8");
	            const root = document.body.firstChild;
	            root.$source = { filePath };
	            return {
	                id: root.uid,
	                page: root.getAttribute("page"),
	                label: root.getAttribute("label"),
	                filePath: filePath
	            };
	        });
	    }
	}
	exports.GetHelpOptionsCommand = GetHelpOptionsCommand;


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const fsa = __webpack_require__(320);
	const path = __webpack_require__(6);
	const base_1 = __webpack_require__(298);
	const messages_1 = __webpack_require__(304);
	class OpenHelpOptionCommand extends base_1.BaseStudioMasterCommand {
	    execute({ option }) {
	        const basename = path.basename(option.filePath);
	        const dir = path.dirname(option.filePath);
	        const tmp = path.join(this.config.tmpDirectory, String(Date.now()));
	        fsa.copySync(dir, tmp);
	        return this.bus.dispatch(new messages_1.OpenNewWorkspaceRequest(path.join(tmp, basename)));
	    }
	}
	exports.OpenHelpOptionCommand = OpenHelpOptionCommand;


/***/ },
/* 320 */
/***/ function(module, exports) {

	module.exports = require("fs-extra");

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const fsa = __webpack_require__(320);
	const base_1 = __webpack_require__(298);
	class InitSettingsDirectoryCommand extends base_1.BaseStudioMasterCommand {
	    execute() {
	        try {
	            fsa.removeSync(this.config.tmpDirectory);
	        }
	        catch (e) {
	        }
	        try {
	            fsa.mkdirpSync(this.config.tmpDirectory);
	            fsa.mkdirpSync(this.config.cacheDirectory);
	        }
	        catch (e) {
	        }
	    }
	}
	exports.InitSettingsDirectoryCommand = InitSettingsDirectoryCommand;


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const base_1 = __webpack_require__(298);
	class HandlePingCommand extends base_1.BaseStudioMasterCommand {
	    execute() {
	        return true;
	    }
	}
	exports.HandlePingCommand = HandlePingCommand;


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const base_1 = __webpack_require__(298);
	const mesh_1 = __webpack_require__(13);
	const child_process_1 = __webpack_require__(159);
	const common_1 = __webpack_require__(8);
	class OpenTextFileCommand extends base_1.BaseStudioMasterCommand {
	    execute(request) {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.logger.debug(`Opening text document: ${request.filePath}`);
	            let opened;
	            try {
	                opened = (yield mesh_1.readOneChunk(this.bus.dispatch(new common_1.SetCurrentFileRequest(request.filePath, request.selection)))).value;
	            }
	            catch (e) {
	                this.logger.error(e.stack);
	                throw e;
	            }
	            this.logger.debug(`Received ${opened} response from text editor`);
	            if (!opened) {
	                this.logger.debug(`Opening new text editor session`);
	                child_process_1.spawn(this.masterStore.userSettings.textEditor.bin, [request.filePath]);
	            }
	        });
	    }
	}
	exports.OpenTextFileCommand = OpenTextFileCommand;


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const fs = __webpack_require__(174);
	const path = __webpack_require__(6);
	const lodash_1 = __webpack_require__(56);
	const base_1 = __webpack_require__(298);
	function getTextEditorBin() {
	    return "/usr/bin/open";
	}
	function addDefaults(config) {
	    return lodash_1.merge({
	        textEditor: {
	            bin: getTextEditorBin()
	        }
	    }, config);
	}
	class InitSettingsCommand extends base_1.BaseStudioMasterCommand {
	    execute() {
	        const configPath = path.join(this.config.settingsDirectory, "config.json");
	        let config;
	        if (fs.existsSync(configPath)) {
	            config = JSON.parse(fs.readFileSync(configPath, "utf8"));
	        }
	        this.masterStore.userSettings = addDefaults(config || {});
	        this.logger.info("Using settings: " + JSON.stringify(this.masterStore.userSettings, null, 2));
	    }
	}
	exports.InitSettingsCommand = InitSettingsCommand;


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(326));


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const fs = __webpack_require__(174);
	const path = __webpack_require__(6);
	const mime = __webpack_require__(327);
	const cors = __webpack_require__(328);
	const express = __webpack_require__(329);
	const compression = __webpack_require__(330);
	const createSocketIOServer = __webpack_require__(331);
	const child_process_1 = __webpack_require__(159);
	const common_1 = __webpack_require__(8);
	const decorators_1 = __webpack_require__(69);
	const core_1 = __webpack_require__(165);
	const sandbox_1 = __webpack_require__(167);
	const messages_1 = __webpack_require__(47);
	// TODO - split this out into separate files -- turning into a god object.
	let BrowserService = class BrowserService extends core_1.CoreApplicationService {
	    $didInject() {
	        super.$didInject();
	        this.bus.register(this._ioService = this.injector.create(common_1.IOService, []));
	    }
	    [messages_1.InitializeApplicationRequest.INITIALIZE]() {
	        return __awaiter(this, void 0, void 0, function* () {
	            this._port = Number(this.config.port);
	            yield this._loadHttpServer();
	            yield this._loadStaticRoutes();
	            yield this._loadFileCacheRoutes();
	            yield this._loadSocketServer();
	            if (this.config.argv.open) {
	                child_process_1.exec(`open http://localhost:${this._port}/editor#/workspace`);
	            }
	        });
	    }
	    _loadHttpServer() {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.logger.info(`Listening on port ${this._port}`);
	            this._server = express();
	            this._socket = this._server.listen(this._port);
	        });
	    }
	    _loadStaticRoutes() {
	        return __awaiter(this, void 0, void 0, function* () {
	            this._server.use(cors());
	            this._server.use(compression());
	            for (const entryName in this.config.entries) {
	                var entryPath = this.config.entries[entryName];
	                var scriptName = path.basename(entryPath);
	                const prefix = "/" + entryName;
	                // this should be part of the config
	                const entryDirectory = path.dirname(entryPath);
	                this._server.use(prefix, express.static(entryDirectory));
	                const staticFileNames = fs.readdirSync(entryDirectory);
	                this._server.use(prefix, (req, res) => {
	                    res.send(this.getIndexHtmlContent(staticFileNames));
	                });
	            }
	        });
	    }
	    _loadFileCacheRoutes() {
	        return __awaiter(this, void 0, void 0, function* () {
	            this._server.use("/file-cache/", (req, res) => __awaiter(this, void 0, void 0, function* () {
	                const filePath = decodeURIComponent(req.path.substr(1));
	                const item = this._fileCache.eagerFindByFilePath(filePath);
	                const content = yield item.read();
	                res.type(mime.lookup(filePath));
	                res.end(content);
	            }));
	        });
	    }
	    // TODO - deprecate this
	    getIndexHtmlContent(staticFileNames) {
	        const host = `http://localhost:${this._port}`;
	        return `
	      <!DOCTYPE html>
	      <html>
	        <head>
	          <meta charset='utf-8' />
	          <style>
	            html, body {
	              width: 100%;
	              height: 100%;
	            }
	          </style>
	          <script type="text/javascript">
	            var config = {
	              server: {
	                hostname: window.location.hostname,
	                port: Number(window.location.port || 80),
	                cwd: "${process.cwd()}"
	              },
	              log: {
	                level: ${this.config.log && this.config.log.level}
	              }
	            };
	          </script>
	        </head>
	        <body>
	          <div id="app"></div>
	          ${staticFileNames.sort((a, b) => /css$/.test(a) ? -1 : 1).map((basename) => {
	            if (/css$/.test(basename)) {
	                return `<link rel="stylesheet" type="text/css" href="${basename}">`;
	            }
	            else if (/js$/.test(basename)) {
	                return `<script src="${basename}"></script>`;
	            }
	        }).filter((str) => !!str).join("\n")}
	        </body>
	      </html>
	    `;
	    }
	    _loadSocketServer() {
	        return __awaiter(this, void 0, void 0, function* () {
	            const io = createSocketIOServer();
	            io["set"]("origins", "*domain.com*:*");
	            io.on("connection", this._ioService.addConnection);
	            io.listen(this._socket);
	        });
	    }
	};
	__decorate([
	    decorators_1.inject(sandbox_1.FileCacheProvider.ID)
	], BrowserService.prototype, "_fileCache", void 0);
	BrowserService = __decorate([
	    decorators_1.loggable()
	], BrowserService);
	exports.BrowserService = BrowserService;


/***/ },
/* 327 */
/***/ function(module, exports) {

	module.exports = require("mime");

/***/ },
/* 328 */
/***/ function(module, exports) {

	module.exports = require("cors");

/***/ },
/* 329 */
/***/ function(module, exports) {

	module.exports = require("express");

/***/ },
/* 330 */
/***/ function(module, exports) {

	module.exports = require("compression");

/***/ },
/* 331 */
/***/ function(module, exports) {

	module.exports = require("socket.io");

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(333));
	__export(__webpack_require__(334));
	__export(__webpack_require__(336));


/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	// TODO - move this to tandem-starters repository
	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const fs = __webpack_require__(174);
	const path = __webpack_require__(6);
	const base_1 = __webpack_require__(334);
	const stripIndent = __webpack_require__(335);
	const FILES = {
	    "index.css": stripIndent(`
	    html, body {
	      padding: 0;
	      margin: 0;
	      font-family: Helvetica;
	    }
	  `),
	    "index.html": stripIndent(`
	    <html lang="en">
	      <head>
	        <link rel="stylesheet" href="./index.css">
	        <meta charset="utf-8">
	      </head>
	      <body>
	        Hola Mundo!
	      </body>
	    </html>
	  `),
	    "workspace.tandem": stripIndent(`
	    <tandem>
	      <artboard src="./index.html" title="Desktop 1440" style=" left: 2128px; top: -916px; width: 1440px; height: 900px; " class="artboard-entity">
	      </artboard>
	      <artboard src="./index.html" title="Desktop 1920" style=" left: -73px; top: -916px; width: 1920px; height: 1080px; " class="artboard-entity">
	      </artboard>
	      <artboard src="./index.html" title="iPad " style=" left: -46px; top: 521px; width: 768px; height: 1024px; " class="artboard-entity">
	      </artboard>
	      <artboard src="./index.html" title="iPhone 5/SE" style=" left: 1024px; top: 2210px; width: 320px; height: 568px; " class="artboard-entity">
	      </artboard>
	      <artboard src="./index.html" title="iPhone 6/7" class="artboard-entity" style=" left: 512px; top: 2210px; width: 375px; height: 667px; ">
	      </artboard>
	      <artboard src="./index.html" title="iPhone 6/7 Plus" class="artboard-entity" style=" left: 0px; top: 2210px; width: 414px; height: 736px; ">
	      </artboard>
	      <artboard src="./index.html" title="iPad Pro" style=" left: 887px; top: 521px; width: 1024px; height: 1366px; "></artboard>
	    </tandem>
	  `)
	};
	class ResponsiveProjectStarter extends base_1.BaseProjectStarter {
	    start(directoryPath) {
	        return __awaiter(this, void 0, void 0, function* () {
	            for (const fileName in FILES) {
	                fs.writeFileSync(path.join(directoryPath, fileName), FILES[fileName]);
	            }
	            return {
	                workspaceFilePath: path.join(directoryPath, "workspace.tandem")
	            };
	        });
	    }
	}
	exports.ResponsiveProjectStarter = ResponsiveProjectStarter;


/***/ },
/* 334 */
/***/ function(module, exports) {

	"use strict";
	class BaseProjectStarter {
	}
	exports.BaseProjectStarter = BaseProjectStarter;


/***/ },
/* 335 */
/***/ function(module, exports) {

	module.exports = require("strip-indent");

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	// TODO - move this to tandem-starters repository
	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const fs = __webpack_require__(174);
	const path = __webpack_require__(6);
	const base_1 = __webpack_require__(334);
	const stripIndent = __webpack_require__(335);
	const FILES = {
	    "workspace.tandem": stripIndent(`
	    <tandem>
	    </tandem>
	  `)
	};
	class BlankProjectStarter extends base_1.BaseProjectStarter {
	    start(directoryPath) {
	        return __awaiter(this, void 0, void 0, function* () {
	            for (const fileName in FILES) {
	                fs.writeFileSync(path.join(directoryPath, fileName), FILES[fileName]);
	            }
	            return {
	                workspaceFilePath: path.join(directoryPath, "workspace.tandem")
	            };
	        });
	    }
	}
	exports.BlankProjectStarter = BlankProjectStarter;


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(338));
	__export(__webpack_require__(305));


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const common_1 = __webpack_require__(46);
	class TandemStudioMasterStore extends common_1.Observable {
	}
	__decorate([
	    common_1.bindable(true)
	], TandemStudioMasterStore.prototype, "userSettings", void 0);
	exports.TandemStudioMasterStore = TandemStudioMasterStore;


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const services_1 = __webpack_require__(340);
	__webpack_require__(346);
	const mesh_1 = __webpack_require__(13);
	const messages_1 = __webpack_require__(347);
	const server_1 = __webpack_require__(349);
	const server_2 = __webpack_require__(354);
	const server_3 = __webpack_require__(361);
	const markdown_extension_1 = __webpack_require__(379);
	const server_4 = __webpack_require__(384);
	const server_5 = __webpack_require__(395);
	const common_1 = __webpack_require__(8);
	const core_1 = __webpack_require__(165);
	const common_2 = __webpack_require__(303);
	const synthetic_browser_1 = __webpack_require__(216);
	const common_3 = __webpack_require__(46);
	const providers_1 = __webpack_require__(345);
	const commands_1 = __webpack_require__(401);
	const sandbox_1 = __webpack_require__(167);
	exports.createCoreStudioWorkerProviders = () => {
	    return [
	        server_3.createHTMLEditorWorkerProviders(),
	        server_2.createSASSEditorWorkerProviders(),
	        server_1.createJavaScriptWorkerProviders(),
	        markdown_extension_1.createCoreMarkdownExtensionProviders(),
	        server_4.createTDProjectEditorWorkerProviders(),
	        server_5.createTypescriptEditorWorkerProviders(),
	        new common_3.CommandFactoryProvider(common_3.LoadApplicationRequest.LOAD, common_2.LoadProjectConfigCommand),
	        new sandbox_1.ProtocolURLResolverProvider("webpack", sandbox_1.WebpackProtocolResolver),
	        new sandbox_1.DependencyGraphStrategyProvider("webpack", sandbox_1.WebpackDependencyGraphStrategy),
	    ];
	};
	exports.initializeWorker = () => __awaiter(this, void 0, void 0, function* () {
	    const config = {
	        family: common_1.EditorFamilyType.WORKER,
	        cwd: process.cwd(),
	        experimental: !!process.env.EXPERIMENTAL,
	        port: process.env.PORT,
	        hostname: process.env.HOSTNAME,
	        log: {
	            level: Number(process.env.LOG_LEVEL),
	            prefix: "worker "
	        }
	    };
	    const injector = new common_3.Injector(common_1.createCommonEditorProviders(config), exports.createCoreStudioWorkerProviders(), new providers_1.DSProvider(new mesh_1.MemoryDataStore()), new core_1.ApplicationServiceProvider("sock", services_1.SockService), new core_1.ApplicationServiceProvider("ds", services_1.DSService), synthetic_browser_1.createSyntheticBrowserWorkerProviders(), 
	    // commands
	    new common_3.CommandFactoryProvider(messages_1.ImportFileRequest.IMPORT_FILE, commands_1.ImportFileCommand), new common_3.CommandFactoryProvider(sandbox_1.ApplyFileEditRequest.APPLY_EDITS, commands_1.ApplyFileEditCommand), new common_3.CommandFactoryProvider(common_3.InitializeApplicationRequest.INITIALIZE, commands_1.SyncFileCacheCommand), new common_3.CommandFactoryProvider(common_3.InitializeApplicationRequest.INITIALIZE, commands_1.StartMasterPingCommand));
	    const app = new core_1.ServiceApplication(injector);
	    // hook with the master process
	    app.bus.register(common_3.hook(config.family, app.bus));
	    yield app.initialize();
	});


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(341));
	__export(__webpack_require__(344));


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const mesh_1 = __webpack_require__(13);
	const core_1 = __webpack_require__(165);
	const common_1 = __webpack_require__(46);
	const os = __webpack_require__(342);
	const path = __webpack_require__(6);
	const net = __webpack_require__(343);
	const fsa = __webpack_require__(320);
	const SOCK_FILE = path.join(os.tmpdir(), `tandem-${process.env.USER}.sock`);
	class SockService extends core_1.CoreApplicationService {
	    constructor() {
	        super();
	        this._socketFile = SOCK_FILE;
	    }
	    /**
	     */
	    [common_1.LoadApplicationRequest.LOAD](action) {
	        return new Promise((resolve, reject) => {
	            let bus;
	            const client = net.connect({ path: this._socketFile });
	            client.once("connect", () => __awaiter(this, void 0, void 0, function* () {
	                const remoteBus = this._registerSocketBus(client);
	                resolve();
	            }));
	            client.once("error", this._startSocketServer.bind(this));
	            client.once("error", resolve);
	        });
	    }
	    _registerSocketBus(connection) {
	        const bus = new common_1.SockBus({ family: this.config.family, connection, testMessage: mesh_1.filterFamilyMessage }, {
	            dispatch: (message) => {
	                return this.bus.dispatch(message);
	            }
	        }, { serialize: common_1.serialize, deserialize: common_1.deserialize });
	        this.bus.register(bus);
	        connection.on("close", () => {
	            this.bus.unregister(bus);
	        });
	        return bus;
	    }
	    _startSocketServer() {
	        this._deleteSocketFile();
	        const server = net.createServer(this._registerSocketBus.bind(this));
	        server.listen(SOCK_FILE);
	    }
	    _deleteSocketFile() {
	        fsa.removeSync(SOCK_FILE);
	    }
	}
	exports.SockService = SockService;


/***/ },
/* 342 */
/***/ function(module, exports) {

	module.exports = require("os");

/***/ },
/* 343 */
/***/ function(module, exports) {

	module.exports = require("net");

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const mesh_1 = __webpack_require__(13);
	const providers_1 = __webpack_require__(345);
	const core_1 = __webpack_require__(165);
	const common_1 = __webpack_require__(46);
	class DSService extends core_1.BaseApplicationService {
	    $didInject() {
	        super.$didInject();
	        // TODO - detch data store dependency here
	        this._ds = new common_1.PostDsNotifierBus(this._mainDs, this.bus);
	        this._upsertBus = new common_1.UpsertBus(this.bus);
	    }
	    /**
	     * finds one or more items against the database
	     */
	    [mesh_1.DSFindRequest.DS_FIND](action) {
	        return this._ds.dispatch(action);
	    }
	    /**
	     * removes one or more items against the db
	     */
	    [mesh_1.DSRemoveRequest.DS_REMOVE](action) {
	        return this._ds.dispatch(action);
	    }
	    /**
	     * inserts one or more items against the db
	     */
	    [mesh_1.DSInsertRequest.DS_INSERT](action) {
	        return this._ds.dispatch(action);
	    }
	    /**
	     */
	    [mesh_1.DSUpdateRequest.DS_UPDATE](action) {
	        return this._ds.dispatch(action);
	    }
	    /**
	     */
	    [common_1.DSUpsertRequest.DS_UPSERT](action) {
	        return this._upsertBus.dispatch(action);
	    }
	}
	__decorate([
	    common_1.inject(providers_1.DSProvider.ID)
	], DSService.prototype, "_mainDs", void 0);
	exports.DSService = DSService;


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	class DSProvider extends common_1.Provider {
	    constructor(value) {
	        super(DSProvider.ID, value);
	    }
	}
	DSProvider.ID = "ds";
	exports.DSProvider = DSProvider;


/***/ },
/* 346 */
/***/ function(module, exports) {

	"use strict";


/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const Url = __webpack_require__(229);
	const array_1 = __webpack_require__(97);
	const messages_1 = __webpack_require__(47);
	const constants_1 = __webpack_require__(348);
	const common_1 = __webpack_require__(46);
	class MouseAction extends messages_1.CoreEvent {
	    constructor(type, originalEvent) {
	        super(type);
	        this.originalEvent = originalEvent;
	        Object.assign(this, {
	            clientX: originalEvent.clientX,
	            clientY: originalEvent.clientY,
	            metaKey: originalEvent.metaKey
	        });
	    }
	    preventDefault() {
	        this.originalEvent.preventDefault();
	    }
	}
	MouseAction.CANVAS_MOUSE_DOWN = "canvasMouseDown";
	MouseAction.SELECTION_DOUBLE_CLICK = "selectionDoubleClick";
	exports.MouseAction = MouseAction;
	class AlertMessage extends messages_1.CoreEvent {
	    constructor(type, level, text) {
	        super(type);
	        this.level = level;
	        this.text = text;
	    }
	    static createWarningMessage(text) {
	        return new AlertMessage(this.ALERT, common_1.LogLevel.WARNING, text);
	    }
	    static createErrorMessage(text) {
	        return new AlertMessage(this.ALERT, common_1.LogLevel.ERROR, text);
	    }
	}
	AlertMessage.ALERT = "alert";
	exports.AlertMessage = AlertMessage;
	class KeyboardAction extends messages_1.CoreEvent {
	    constructor(type, originalEvent) {
	        super(type);
	        this.originalEvent = originalEvent;
	        Object.assign(this, {
	            which: originalEvent.which,
	            keyCode: originalEvent.keyCode
	        });
	    }
	    preventDefault() {
	        this.originalEvent.preventDefault();
	    }
	}
	KeyboardAction.CANVAS_KEY_DOWN = "canvasKeyDown";
	exports.KeyboardAction = KeyboardAction;
	class SelectRequest extends messages_1.CoreEvent {
	    constructor(items = undefined, keepPreviousSelection = false, toggle = false) {
	        super(SelectRequest.SELECT);
	        this.items = array_1.toArray(items);
	        this.keepPreviousSelection = !!keepPreviousSelection;
	        this.toggle = toggle;
	    }
	}
	SelectRequest.SELECT = "SELECT";
	exports.SelectRequest = SelectRequest;
	class RedirectRequest {
	    constructor(routeNameOrPath, params, query) {
	        this.routeNameOrPath = routeNameOrPath;
	        this.params = params;
	        this.query = query;
	        this.type = RedirectRequest.REDIRECT;
	    }
	    static fromURL(value) {
	        const parts = Url.parse(value, true);
	        return new RedirectRequest(parts.pathname, {}, parts.query);
	    }
	}
	RedirectRequest.REDIRECT = "redirect";
	exports.RedirectRequest = RedirectRequest;
	class DidRedirectMessage {
	    constructor(pathname, state) {
	        this.pathname = pathname;
	        this.state = state;
	        this.type = DidRedirectMessage.DID_REDIRECT;
	    }
	}
	DidRedirectMessage.DID_REDIRECT = "didRedirect";
	exports.DidRedirectMessage = DidRedirectMessage;
	function createWorkspaceRedirectRequest(filePath) {
	    return new RedirectRequest(constants_1.EditorRouteNames.WORKSPACE, {}, { workspacePath: filePath });
	}
	exports.createWorkspaceRedirectRequest = createWorkspaceRedirectRequest;
	class SelectionChangeEvent extends messages_1.CoreEvent {
	    constructor(items = []) {
	        super(SelectionChangeEvent.SELECTION_CHANGE);
	        this.items = items;
	    }
	}
	SelectionChangeEvent.SELECTION_CHANGE = "selectionChange";
	exports.SelectionChangeEvent = SelectionChangeEvent;
	class SelectAllRequest extends messages_1.CoreEvent {
	    constructor() {
	        super(SelectAllRequest.SELECT_ALL);
	    }
	}
	SelectAllRequest.SELECT_ALL = "selectAll";
	exports.SelectAllRequest = SelectAllRequest;
	class ToggleSelectRequest extends SelectRequest {
	    constructor(items = undefined, keepPreviousSelection = false) {
	        super(items, keepPreviousSelection, true);
	    }
	}
	exports.ToggleSelectRequest = ToggleSelectRequest;
	class ZoomRequest extends messages_1.CoreEvent {
	    constructor(delta, ease = false, round = false) {
	        super(ZoomRequest.ZOOM);
	        this.delta = delta;
	        this.ease = ease;
	        this.round = round;
	    }
	}
	ZoomRequest.ZOOM = "zoom";
	exports.ZoomRequest = ZoomRequest;
	class ZoomInRequest extends messages_1.CoreEvent {
	    constructor() {
	        super(ZoomInRequest.ZOOM_IN);
	    }
	}
	ZoomInRequest.ZOOM_IN = "zoomIn";
	exports.ZoomInRequest = ZoomInRequest;
	class ToggleSettingRequest extends messages_1.CoreEvent {
	    constructor(settingName) {
	        super(ToggleSettingRequest.TOGGLE_SETTING);
	        this.settingName = settingName;
	    }
	}
	ToggleSettingRequest.TOGGLE_SETTING = "toggleSetting";
	exports.ToggleSettingRequest = ToggleSettingRequest;
	function createToggleSettingRequestClass(settingName) {
	    return class extends ToggleSettingRequest {
	        constructor() {
	            super(settingName);
	        }
	    }
	    ;
	}
	exports.createToggleSettingRequestClass = createToggleSettingRequestClass;
	class ToggleStageToolsRequest extends messages_1.CoreEvent {
	    constructor() {
	        super(ToggleStageToolsRequest.TOGGLE_STAGE_TOOLS);
	    }
	}
	ToggleStageToolsRequest.TOGGLE_STAGE_TOOLS = "toggleStageTools";
	exports.ToggleStageToolsRequest = ToggleStageToolsRequest;
	class ZoomOutRequest extends messages_1.CoreEvent {
	    constructor() {
	        super(ZoomOutRequest.ZOOM_OUT);
	    }
	}
	ZoomOutRequest.ZOOM_OUT = "zoomOut";
	exports.ZoomOutRequest = ZoomOutRequest;
	class SetZoomRequest extends messages_1.CoreEvent {
	    constructor(value, ease = false) {
	        super(SetZoomRequest.SET_ZOOM);
	        this.value = value;
	        this.ease = ease;
	    }
	}
	SetZoomRequest.SET_ZOOM = "setZoom";
	exports.SetZoomRequest = SetZoomRequest;
	class PasteRequest extends messages_1.CoreEvent {
	    constructor(item) {
	        super(PasteRequest.getRequestType(item));
	        this.item = item;
	    }
	    static getRequestType(item) {
	        return ["paste", typeof item === "string" ? item : item.type].join("/");
	    }
	}
	exports.PasteRequest = PasteRequest;
	class SetToolRequest extends messages_1.CoreEvent {
	    constructor(toolFactory) {
	        super(SetToolRequest.SET_TOOL);
	        this.toolFactory = toolFactory;
	    }
	}
	SetToolRequest.SET_TOOL = "setTool";
	exports.SetToolRequest = SetToolRequest;
	class AddSyntheticObjectRequest {
	    constructor(item) {
	        this.item = item;
	        this.type = AddSyntheticObjectRequest.ADD_SYNTHETIC_OBJECT;
	    }
	}
	AddSyntheticObjectRequest.ADD_SYNTHETIC_OBJECT = "addSyntheticObject";
	exports.AddSyntheticObjectRequest = AddSyntheticObjectRequest;
	class KeyCommandEvent extends messages_1.CoreEvent {
	    constructor(combo) {
	        super(KeyCommandEvent.KEY_COMMAND);
	        this.combo = combo;
	    }
	}
	KeyCommandEvent.KEY_COMMAND = "keyCommand";
	exports.KeyCommandEvent = KeyCommandEvent;
	class RemoveSelectionRequest extends messages_1.CoreEvent {
	    constructor() {
	        super(RemoveSelectionRequest.REMOVE_SELECTION);
	    }
	}
	RemoveSelectionRequest.REMOVE_SELECTION = "removeSelection";
	exports.RemoveSelectionRequest = RemoveSelectionRequest;
	__export(__webpack_require__(215));


/***/ },
/* 348 */
/***/ function(module, exports) {

	"use strict";
	exports.CANVAS_SIZE = 5000;
	exports.ZOOM_INCREMENT = 0.3;
	exports.POINTER_TOOL_KEY_CODE = "p";
	var SettingKeys;
	(function (SettingKeys) {
	    SettingKeys.HIDE_LEFT_SIDEBAR = "hideLeftSidebar";
	    SettingKeys.HIDE_RIGHT_SIDEBAR = "hideRightSidebar";
	})(SettingKeys = exports.SettingKeys || (exports.SettingKeys = {}));
	var MetadataKeys;
	(function (MetadataKeys) {
	    MetadataKeys.CANVAS_ROOT = "canvasRoot";
	    MetadataKeys.ENTITY_VISIBLE = "entityVisible";
	    MetadataKeys.LAYER_DEPENDENCY_NAME = "layerProviderName";
	    MetadataKeys.HOVERING = "hovering";
	    MetadataKeys.REVEAL = "reveal";
	    MetadataKeys.SELECTED = "selected";
	    MetadataKeys.HIDDEN = "hidden";
	    MetadataKeys.SELECTABLE = "selectable";
	    MetadataKeys.MOVING = "moving";
	    MetadataKeys.ZOOMING = "zooming";
	    MetadataKeys.EDIT_LAYER = "editLayer";
	    MetadataKeys.LAYER_EXPANDED = "layerExpanded";
	    MetadataKeys.CHILD_LAYER_PROPERTY = "childLayerProperty";
	})(MetadataKeys = exports.MetadataKeys || (exports.MetadataKeys = {}));
	var EditorRouteNames;
	(function (EditorRouteNames) {
	    EditorRouteNames.ROOT = "root";
	    EditorRouteNames.WORKSPACE = "workspace";
	})(EditorRouteNames = exports.EditorRouteNames || (exports.EditorRouteNames = {}));
	var ToolFamily;
	(function (ToolFamily) {
	    ToolFamily.INTERACT = "interact";
	})(ToolFamily = exports.ToolFamily || (exports.ToolFamily = {}));


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(350));


/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const index_1 = __webpack_require__(351);
	exports.createJavaScriptWorkerProviders = index_1.createJavaScriptSandboxProviders;


/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(352));


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const common_1 = __webpack_require__(46);
	const commonjs_evaluator_1 = __webpack_require__(353);
	const sandbox_1 = __webpack_require__(167);
	exports.createJavaScriptSandboxProviders = () => {
	    return [
	        new common_1.MimeTypeProvider("js", common_1.JS_MIME_TYPE),
	        new sandbox_1.SandboxModuleEvaluatorFactoryProvider(common_1.JS_MIME_TYPE, commonjs_evaluator_1.CommonJSSandboxEvaluator),
	    ];
	};
	__export(__webpack_require__(353));


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const sandbox_1 = __webpack_require__(167);
	class CommonJSSandboxEvaluator {
	    evaluate(module) {
	        const { source, sandbox } = module;
	        const { content, hash } = source;
	        const { global, vmContext } = sandbox;
	        const script = sandbox_1.compileModuleSandboxScript(module.filePath, hash, content);
	        const resolve = (relativePath) => {
	            return source.eagerGetDependency(relativePath);
	        };
	        const require = (relativePath) => {
	            const dep = resolve(relativePath);
	            // DEP may not exist, especially if loaded by a NULL loader.
	            return dep && sandbox.evaluate(dep);
	        };
	        require.resolve = resolve;
	        const context = source.graph.createModuleContext(module);
	        Object.assign(context, { global, require });
	        sandbox_1.runModuleSandboxScript(script, hash, sandbox, context);
	    }
	}
	exports.CommonJSSandboxEvaluator = CommonJSSandboxEvaluator;


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	exports.createSASSEditorServerProviders = () => {
	    return [];
	};
	__export(__webpack_require__(355));


/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const index_1 = __webpack_require__(356);
	exports.createSASSEditorWorkerProviders = () => {
	    return [
	        ...index_1.createSASSSandboxProviders()
	    ];
	};


/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(357));


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const scss_editor_1 = __webpack_require__(358);
	const constants_1 = __webpack_require__(360);
	const common_1 = __webpack_require__(46);
	const sandbox_1 = __webpack_require__(167);
	exports.createSASSSandboxProviders = () => {
	    return [
	        // deprecated for now since node-sass is an pain to get implemented with electron
	        new sandbox_1.ContentEditorFactoryProvider(constants_1.SASS_MIME_TYPE, scss_editor_1.SCSSEditor),
	        new common_1.MimeTypeProvider("scss", constants_1.SASS_MIME_TYPE)
	    ];
	};


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const postcss = __webpack_require__(267);
	const syntax = __webpack_require__(359);
	const common_1 = __webpack_require__(46);
	const synthetic_browser_1 = __webpack_require__(216);
	// TODO - follow scss variables to their original declaration
	class SCSSEditor extends synthetic_browser_1.CSSEditor {
	    [synthetic_browser_1.SyntheticCSSElementStyleRuleMutationTypes.SET_RULE_SELECTOR](node, { target, newValue }) {
	        const source = target.source;
	        // prefix here is necessary
	        const prefix = this.getRuleSelectorPrefix(node);
	        node.selector = (node.selector.indexOf("&") === 0 ? "&" : "") + newValue.replace(prefix, "");
	    }
	    findTargetASTNode(root, target) {
	        let found;
	        const walk = (node, index) => {
	            let offsetStart = {
	                line: target.source.start.line,
	                column: target.source.start.column
	            };
	            if (!node.source)
	                return;
	            const nodeStart = node.source.start;
	            // Bug fix (I need to report this): Source map column numbers shift +1 for each CSS rule. This fixes that.
	            const ruleCount = this.countRulesOnLineBefore(node);
	            if (ruleCount) {
	                offsetStart.column -= ruleCount;
	            }
	            if (node.type === target.source.kind && target.source && common_1.sourcePositionEquals(nodeStart, offsetStart)) {
	                // next find the actual node that the synthetic matches with -- the source position may not be
	                // entirely accurate for cases such as nested selectors.
	                found = this.findNestedASTNode(node, target);
	                return false;
	            }
	        };
	        if (walk(root, -1) !== false) {
	            root.walk(walk);
	        }
	        return found;
	    }
	    countRulesOnLineBefore(node) {
	        let count = 0;
	        let stopped = false;
	        if (this._rootASTNode === node)
	            return 0;
	        this._rootASTNode.walk((child) => {
	            if (child === node) {
	                stopped = true;
	            }
	            if (stopped)
	                return;
	            if (child.type === "rule" && child.source && child.source.start.line === node.source.start.line) {
	                count++;
	            }
	        });
	        return count;
	    }
	    findNestedASTNode(node, target) {
	        if (isRuleNode(node)) {
	            return this.findMatchingRuleNode(node, target);
	        }
	        else {
	            return node;
	        }
	    }
	    /**
	     *
	     *
	     * @private
	     * @param {postcss.Rule} node
	     * @param {SyntheticCSSElementStyleRule} synthetic
	     * @param {string} [prefix='']
	     * @returns {postcss.Rule}
	     */
	    findMatchingRuleNode(node, synthetic, prefix = '') {
	        let found;
	        const selector = prefix + (!prefix.length || node.selector.search(/^\&/) !== -1 ? node.selector.replace(/^\&/, "") : " " + node.selector);
	        if (selector === synthetic.selector)
	            return node;
	        node.each((child) => {
	            if (isRuleNode(child) && (found = this.findMatchingRuleNode(child, synthetic, selector))) {
	                return false;
	            }
	        });
	        return found;
	    }
	    /**
	     * for nested selectors
	     *
	     * @private
	     * @param {postcss.Rule} node
	     * @returns
	     */
	    getRuleSelectorPrefix(node) {
	        let prefix = "";
	        let current = node;
	        while (current = current.parent) {
	            if (!isRuleNode(current))
	                break;
	            prefix = current.selector.replace(/^&/, "") + prefix;
	        }
	        return prefix;
	    }
	    parseContent(content) {
	        return parseSCSS(content);
	    }
	    getFormattedContent(root) {
	        // try parsing again. This should throw an error if any edits are invalid.
	        parseSCSS(root.toString());
	        return root.toString();
	    }
	}
	exports.SCSSEditor = SCSSEditor;
	function parseSCSS(content) {
	    return postcss().process(content, {
	        syntax: syntax
	    }).root;
	}
	function isRuleNode(node) {
	    return node.type === "rule";
	}


/***/ },
/* 359 */
/***/ function(module, exports) {

	module.exports = require("postcss-scss");

/***/ },
/* 360 */
/***/ function(module, exports) {

	"use strict";
	exports.SASS_MIME_TYPE = "text/scss";


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	exports.createHTMLEditorServerProviders = () => {
	    return [];
	};
	__export(__webpack_require__(362));
	__export(__webpack_require__(377));


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const common_1 = __webpack_require__(46);
	const synthetic_browser_1 = __webpack_require__(216);
	const synthetic_1 = __webpack_require__(363);
	// key bindings
	const common_2 = __webpack_require__(46);
	function createHTMLCoreProviders() {
	    return [
	        ...synthetic_browser_1.HTML_TAG_NAMES.map((tagName) => new synthetic_browser_1.SyntheticDOMElementClassProvider(synthetic_browser_1.HTML_XMLNS, tagName, synthetic_browser_1.SyntheticHTMLElement)),
	        ...synthetic_browser_1.SVG_TAG_NAMES.map((tagName) => new synthetic_browser_1.SyntheticDOMElementClassProvider(synthetic_browser_1.SVG_XMLNS, tagName, synthetic_browser_1.SyntheticHTMLElement)),
	        // new SyntheticDOMElementClassProvider(HTML_XMLNS, "canvas", SyntheticHTMLCanvas),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(synthetic_browser_1.HTML_XMLNS, "link", synthetic_1.SyntheticHTMLLink),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(synthetic_browser_1.HTML_XMLNS, "a", synthetic_1.SyntheticAnchor),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(synthetic_browser_1.HTML_XMLNS, "script", synthetic_1.SyntheticHTMLScript),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(synthetic_browser_1.HTML_XMLNS, "style", synthetic_1.SyntheticHTMLStyle),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(synthetic_browser_1.HTML_XMLNS, "iframe", synthetic_1.SyntheticIframe),
	        // TODO - move these to htmlCoreProviders
	        // mime types
	        new common_2.MimeTypeProvider("css", common_1.CSS_MIME_TYPE),
	        new common_2.MimeTypeProvider("htm", common_1.HTML_MIME_TYPE),
	        new common_2.MimeTypeProvider("html", common_1.HTML_MIME_TYPE)
	    ];
	}
	exports.createHTMLCoreProviders = createHTMLCoreProviders;
	__export(__webpack_require__(370));
	__export(__webpack_require__(371));
	__export(__webpack_require__(363));
	__export(__webpack_require__(372));


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(364));


/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(365));
	__export(__webpack_require__(366));
	__export(__webpack_require__(367));
	__export(__webpack_require__(368));
	__export(__webpack_require__(369));


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const synthetic_browser_1 = __webpack_require__(216);
	const _cache = {};
	// refactor - all this stuff is janky, and hacked together just to get
	// something to work.
	class SyntheticHTMLLink extends synthetic_browser_1.SyntheticHTMLElement {
	    get href() {
	        return this.getAttribute("href");
	    }
	    set href(value) {
	        this.setAttribute("href", value);
	        this.reload();
	    }
	    createdCallback() {
	        const rel = this.getAttribute("rel") || "stylesheet";
	        const href = this.getAttribute("href");
	        if (href)
	            this.reload();
	    }
	    attachedCallback() {
	        this.attachStylesheet();
	    }
	    detachedCallback() {
	        this.detachStylesheet();
	    }
	    reload() {
	        const rel = (this.getAttribute("rel") || "stylesheet").toLowerCase();
	        const href = this.href;
	        const dep = this.module && this.module.source.eagerGetDependency(href);
	        let content, type;
	        if (dep) {
	            content = dep.content;
	        }
	        else {
	            const result = parseDataURI(href);
	            content = result && decodeURIComponent(result.content);
	        }
	        //  TODO - need to use fetch for this
	        if (rel === "stylesheet") {
	            this.stylesheet = this.stylesheet || new synthetic_browser_1.SyntheticCSSStyleSheet([]);
	            this.stylesheet.$ownerNode = this;
	            this.stylesheet.cssText = content || "";
	            this.attachStylesheet();
	        }
	        else if (rel === "import") {
	            this.attachShadow({ mode: "open" });
	        }
	    }
	    attachStylesheet() {
	        if (this._addedToDocument || !this.ownerDocument || !this._attached || !this.stylesheet)
	            return;
	        this._addedToDocument = true;
	        this.ownerDocument.styleSheets.push(this.stylesheet);
	    }
	    detachStylesheet() {
	        if (!this.ownerDocument || !this._attached || !this.stylesheet)
	            return;
	        this._addedToDocument = false;
	        const index = this.ownerDocument.styleSheets.indexOf(this.stylesheet);
	        if (index !== -1) {
	            this.ownerDocument.styleSheets.splice(index, 1);
	        }
	    }
	}
	exports.SyntheticHTMLLink = SyntheticHTMLLink;
	function parseDataURI(uri) {
	    const parts = uri.match(/data:(.*?),(.*)/);
	    return parts && { type: parts[1], content: parts[2] };
	}


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const synthetic_browser_1 = __webpack_require__(216);
	const sandbox_1 = __webpack_require__(167);
	class SyntheticHTMLScript extends synthetic_browser_1.SyntheticHTMLElement {
	    get src() {
	        return this.getAttribute("src");
	    }
	    get text() {
	        return this.textContent;
	    }
	    set text(value) {
	        this.textContent = value;
	        this.executeScript();
	    }
	    set src(value) {
	        this.setAttribute("src", value);
	    }
	    attachedCallback() {
	        this.executeScript();
	    }
	    get type() {
	        return this.getAttribute("type");
	    }
	    executeScript() {
	        if (this._executed || !this._attached)
	            return;
	        const src = this.getAttribute("src");
	        const type = this.getAttribute("type");
	        if (type && (type !== "text/javascript" && type !== "application/javascript"))
	            return;
	        const module = this.$module;
	        const sandox = this.ownerDocument.sandbox;
	        const window = this.ownerDocument.defaultView;
	        const source = this.$source;
	        const content = src ? module && module.source.eagerGetDependency(src).content : this.textContent;
	        if (!content)
	            return;
	        this._executed = true;
	        const filePath = src || source && source.filePath || window.location.toString();
	        // node that $module will only exist if the script is evaluated from an HTML file
	        // TODO - this doesn't work.. need 
	        const script = sandbox_1.compileGlobalSandboxScript(filePath, filePath, content);
	        sandbox_1.runGlobalSandboxScript(script, sandox);
	    }
	}
	exports.SyntheticHTMLScript = SyntheticHTMLScript;


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const synthetic_browser_1 = __webpack_require__(216);
	class SyntheticHTMLStyle extends synthetic_browser_1.SyntheticDOMElement {
	    attachedCallback() {
	        super.attachedCallback();
	        this.ownerDocument.styleSheets.push(this.getStyleSheet());
	    }
	    getStyleSheet() {
	        if (this._styleSheet)
	            return this._styleSheet;
	        this._styleSheet = new synthetic_browser_1.SyntheticCSSStyleSheet([]);
	        this._styleSheet.$ownerNode = this;
	        this._styleSheet.cssText = this.textContent;
	        return this._styleSheet;
	    }
	    detachedCallback() {
	        this.ownerDocument.styleSheets.splice(this.ownerDocument.styleSheets.indexOf(this._styleSheet), 1);
	    }
	    onChildAdded(child, index) {
	        super.onChildAdded(child, index);
	        if (this._styleSheet) {
	            this._styleSheet.cssText = this.textContent;
	        }
	    }
	    get styleSheet() {
	        return this._styleSheet;
	    }
	}
	exports.SyntheticHTMLStyle = SyntheticHTMLStyle;


/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const synthetic_browser_1 = __webpack_require__(216);
	class SyntheticIframe extends synthetic_browser_1.SyntheticHTMLElement {
	    createdCallback() {
	        super.createdCallback();
	        this._contentWindow = new synthetic_browser_1.SyntheticWindow();
	    }
	    get contentWindow() {
	        return this._contentWindow;
	    }
	}
	exports.SyntheticIframe = SyntheticIframe;


/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const Url = __webpack_require__(229);
	const synthetic_browser_1 = __webpack_require__(216);
	const common_1 = __webpack_require__(46);
	class SyntheticAnchor extends synthetic_browser_1.SyntheticHTMLElement {
	    constructor() {
	        super(...arguments);
	        this._rebuildHref = () => {
	            if (this._ignoreRebuild)
	                return;
	            this.href = this.protocol + "//" +
	                this.host +
	                this.pathname + this.search +
	                (this.hash && (this.hash.charAt(0) === "#" ? this.hash : "#" + this.hash));
	        };
	    }
	    get host() {
	        return this.hostname + (this.port && this.port.length ? ":" + this.port : "");
	    }
	    set host(value) {
	        const [hostname, port] = (value || ":").split(":");
	        this._ignoreRebuild = true;
	        this.hostname = hostname;
	        this._ignoreRebuild = false;
	        this.port = port;
	    }
	    get href() {
	        return this.getAttribute("href");
	    }
	    set href(value) {
	        this.setAttribute("href", value);
	    }
	    createdCallback() {
	        super.createdCallback();
	        ["hostname", "pathname", "port", "protocol", "hash", "query"].forEach((part) => {
	            new common_1.PropertyWatcher(this, part).connect(this._rebuildHref);
	        });
	    }
	    attributeChangedCallback(name, oldValue, newValue) {
	        super.attributeChangedCallback(name, oldValue, newValue);
	        if (name === "href") {
	            this._parseHref();
	        }
	    }
	    _parseHref() {
	        this._ignoreRebuild = true;
	        const href = this.href;
	        const parts = Url.parse(href);
	        for (const key in parts) {
	            if (key === "host")
	                continue;
	            this[key] = parts[key] || "";
	        }
	        this._ignoreRebuild = false;
	    }
	}
	__decorate([
	    common_1.bindable()
	], SyntheticAnchor.prototype, "hostname", void 0);
	__decorate([
	    common_1.bindable()
	], SyntheticAnchor.prototype, "pathname", void 0);
	__decorate([
	    common_1.bindable()
	], SyntheticAnchor.prototype, "port", void 0);
	__decorate([
	    common_1.bindable()
	], SyntheticAnchor.prototype, "protocol", void 0);
	__decorate([
	    common_1.bindable()
	], SyntheticAnchor.prototype, "hash", void 0);
	__decorate([
	    common_1.bindable()
	], SyntheticAnchor.prototype, "search", void 0);
	exports.SyntheticAnchor = SyntheticAnchor;


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const messages_1 = __webpack_require__(47);
	class PasteHTMLEntityAction extends messages_1.CoreEvent {
	    constructor(item) {
	        super(PasteHTMLEntityAction.PASTE_HTML_ENTITY);
	        this.item = item;
	    }
	}
	PasteHTMLEntityAction.PASTE_HTML_ENTITY = "pasteHTMLEntity";
	exports.PasteHTMLEntityAction = PasteHTMLEntityAction;


/***/ },
/* 371 */
/***/ function(module, exports) {

	"use strict";
	exports.TEXT_TOOL_KEY_CODE = "t";


/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const synthetic_browser_1 = __webpack_require__(216);
	const common_1 = __webpack_require__(46);
	const html_evaluator_1 = __webpack_require__(373);
	const css_evaluator_1 = __webpack_require__(374);
	const css_loader_1 = __webpack_require__(375);
	const html_loader_1 = __webpack_require__(376);
	__export(__webpack_require__(376));
	__export(__webpack_require__(373));
	__export(__webpack_require__(375));
	__export(__webpack_require__(374));
	const sandbox_1 = __webpack_require__(167);
	function createHTMLSandboxProviders() {
	    return [
	        // dependency graph loaders
	        new sandbox_1.DependencyLoaderFactoryProvider(common_1.HTML_MIME_TYPE, html_loader_1.HTMLDependencyLoader),
	        new sandbox_1.DependencyLoaderFactoryProvider(common_1.CSS_MIME_TYPE, css_loader_1.CSSDependencyLoader),
	        // sandbox evaluators
	        new sandbox_1.SandboxModuleEvaluatorFactoryProvider(common_1.HTML_MIME_TYPE, html_evaluator_1.HTMLASTEvaluator),
	        new sandbox_1.SandboxModuleEvaluatorFactoryProvider(common_1.CSS_MIME_TYPE, css_evaluator_1.CSSASTEvaluator),
	        // edit consumers
	        new sandbox_1.ContentEditorFactoryProvider(common_1.CSS_MIME_TYPE, synthetic_browser_1.CSSEditor),
	        new sandbox_1.ContentEditorFactoryProvider(common_1.HTML_MIME_TYPE, synthetic_browser_1.MarkupEditor),
	    ];
	}
	exports.createHTMLSandboxProviders = createHTMLSandboxProviders;


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const synthetic_browser_1 = __webpack_require__(216);
	class HTMLASTEvaluator {
	    evaluate(module) {
	        const window = module.sandbox.global;
	        window.document.removeAllChildren();
	        // documentElement must be this -- handled by browser instance. Also note
	        // that we're not manually setting document element here to ensure that HTMLASTEvaluator works for imported docs
	        // which is (slowly) being implemented in real browsers.
	        synthetic_browser_1.evaluateMarkup(synthetic_browser_1.parseMarkup(module.source.content), window.document, synthetic_browser_1.MarkupMimeTypeXMLNSProvider.lookup(module.source.filePath, window.browser.injector), module, window.document);
	    }
	}
	exports.HTMLASTEvaluator = HTMLASTEvaluator;


/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const synthetic_browser_1 = __webpack_require__(216);
	class CSSASTEvaluator {
	    evaluate(module) {
	        module.exports = synthetic_browser_1.evaluateCSS(synthetic_browser_1.parseCSS(module.source.content), module.source.map, module);
	    }
	}
	exports.CSSASTEvaluator = CSSASTEvaluator;


/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const sandbox_1 = __webpack_require__(167);
	const common_1 = __webpack_require__(46);
	const synthetic_browser_1 = __webpack_require__(216);
	class CSSDependencyLoader extends sandbox_1.BaseDependencyLoader {
	    load({ filePath }, { type, content, map }) {
	        return __awaiter(this, void 0, void 0, function* () {
	            /*const content = this.content.replace(/url\(['"]?(.*?)['"]?\)/g, (match, filePath) => {
	              return `url("http://${window.location.host}/asset/` + encodeURIComponent(path.join(path.dirname(this.filePath), filePath.split(/\?|#/).shift())) + '")';
	            });*/
	            return {
	                type: common_1.CSS_MIME_TYPE,
	                ast: synthetic_browser_1.parseCSS(content, map),
	                map: map,
	                content: content
	            };
	        });
	    }
	}
	exports.CSSDependencyLoader = CSSDependencyLoader;


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const path = __webpack_require__(6);
	const sm = __webpack_require__(263);
	const sandbox_1 = __webpack_require__(167);
	const common_1 = __webpack_require__(46);
	const synthetic_browser_1 = __webpack_require__(216);
	// TODO - need to add source maps here. Okay for now since line & column numbers stay
	// the same even when src & href attributes are manipulated. However, the editor *will* break
	// if there's a manipulated href / src attribute that shares the same line with another one.
	class HTMLDependencyLoader extends sandbox_1.BaseDependencyLoader {
	    load({ filePath, hash }, { type, content }) {
	        return __awaiter(this, void 0, void 0, function* () {
	            content = String(content);
	            const importedDependencyPaths = [];
	            const injector = this._injector;
	            const self = this;
	            const ast = synthetic_browser_1.parseMarkup(content);
	            const smg = new sm.SourceMapGenerator();
	            let replacements = [];
	            const addReplacement = (node, start, end, value) => {
	                replacements.push({ node, start, end, value });
	            };
	            const lines = content.split("\n");
	            function getPosition({ line, column }) {
	                const lineChunk = lines.slice(0, line);
	                lineChunk[lineChunk.length - 1] = lineChunk[lineChunk.length - 1].substr(0, column - 1);
	                return lineChunk.join("\n").length;
	                // const n = lines.slice(0, line - 1).join("").length + line + lines[line - 1].substr(0, column - 1).length;
	                // console.log(n, line, column, lines[line - 1].substr(0, column - 1));
	                // return n;
	            }
	            yield ast.accept({
	                visitAttribute: (attribute) => __awaiter(this, void 0, void 0, function* () {
	                    // ignore redirecting tag names
	                    if (/src|href/.test(attribute.name) && !/^a$/i.test(attribute.parent.nodeName)) {
	                        const absoluteFilePathOptions = yield this.strategy.resolve(attribute.value, path.dirname(filePath));
	                        addReplacement(attribute, getPosition(attribute.location.start) + attribute.name.length + 2, getPosition(attribute.location.end) - 1, absoluteFilePathOptions.filePath);
	                        importedDependencyPaths.push(attribute.value);
	                    }
	                }),
	                visitComment(comment) { },
	                visitText() { },
	                visitDocumentFragment(fragment) {
	                    return Promise.all(fragment.childNodes.map((childNodes) => __awaiter(this, void 0, void 0, function* () {
	                        return yield childNodes.accept(this);
	                    })));
	                },
	                visitElement(element) {
	                    return __awaiter(this, void 0, void 0, function* () {
	                        // todo later on
	                        // // normalize scripts here so that we just have text/javascript and text/css
	                        // // TODO - add source maps here.
	                        // if (/script|style/i.test(element.nodeName) && element.childNodes.length) {
	                        //   const textNode = element.childNodes[0] as MarkupTextExpression;
	                        //   const type     = element.getAttribute("type");
	                        //   if (type) {
	                        //     const result = await self.strategy.getLoader(null).load({ filePath, hash }, {
	                        //       type: type,
	                        //       content: textNode.nodeValue
	                        //     });
	                        //     textNode.nodeValue = result.content;
	                        //     element.setAttribute("type", result.type);
	                        //   }
	                        // }
	                        return Promise.all([...element.childNodes, ...element.attributes].map((child) => {
	                            return child.accept(this);
	                        }));
	                    });
	                }
	            });
	            replacements = replacements.sort((a, b) => a.start > b.start ? -1 : 1);
	            for (const { start, value, end } of replacements) {
	                content = content.substr(0, start) + value + content.substr(end);
	            }
	            return {
	                content: content,
	                type: common_1.HTML_MIME_TYPE,
	                importedDependencyPaths: importedDependencyPaths
	            };
	        });
	    }
	}
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], HTMLDependencyLoader.prototype, "_injector", void 0);
	exports.HTMLDependencyLoader = HTMLDependencyLoader;


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	// note unused imports - fixes --declaration issue with typescript
	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const common_1 = __webpack_require__(46);
	const index_1 = __webpack_require__(378);
	const providers_1 = __webpack_require__(312);
	exports.createHTMLEditorWorkerProviders = () => {
	    return [
	        ...index_1.createHTMLCoreProviders(),
	        ...index_1.createHTMLSandboxProviders(),
	        new providers_1.PreviewLoaderProvider("htmlPreview", (filePath, injector) => {
	            return common_1.MimeTypeProvider.lookup(filePath, injector) === common_1.HTML_MIME_TYPE;
	        }, providers_1.SelfPreviewLoader)
	    ];
	};
	__export(__webpack_require__(362));


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(362));


/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	const constants_1 = __webpack_require__(380);
	const sandbox_1 = __webpack_require__(381);
	const sandbox_2 = __webpack_require__(167);
	const worker_1 = __webpack_require__(311);
	exports.createCoreMarkdownExtensionProviders = () => {
	    return [
	        new common_1.MimeTypeProvider("md", constants_1.MARKDOWN_MIME_TYPE),
	        new sandbox_2.DependencyLoaderFactoryProvider(constants_1.MARKDOWN_MIME_TYPE, sandbox_1.MarkdownDependencyLoader),
	        new worker_1.PreviewLoaderProvider("markdown", (filePath, injector) => {
	            return common_1.MimeTypeProvider.lookup(filePath, injector) === constants_1.MARKDOWN_MIME_TYPE;
	        }, worker_1.SelfPreviewLoader)
	    ];
	};


/***/ },
/* 380 */
/***/ function(module, exports) {

	"use strict";
	exports.MARKDOWN_MIME_TYPE = "text/markdown";


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(382));


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const marked = __webpack_require__(383);
	const sandbox_1 = __webpack_require__(167);
	const common_1 = __webpack_require__(46);
	class MarkdownDependencyLoader extends sandbox_1.BaseDependencyLoader {
	    load({ filePath, hash }, { type, content }) {
	        return __awaiter(this, void 0, void 0, function* () {
	            return {
	                content: `
	        <style>
	          html, body {
	            font-family: Helvetica
	          }
	        </style>
	        ${marked(String(content))}
	      `,
	                type: common_1.HTML_MIME_TYPE,
	                importedDependencyPaths: []
	            };
	        });
	    }
	}
	exports.MarkdownDependencyLoader = MarkdownDependencyLoader;


/***/ },
/* 383 */
/***/ function(module, exports) {

	module.exports = require("marked");

/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const worker_1 = __webpack_require__(385);
	exports.createTDProjectEditorServerProviders = worker_1.createTDProjectEditorWorkerProviders;
	__export(__webpack_require__(386));
	__export(__webpack_require__(385));


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	const core_1 = __webpack_require__(386);
	const importers_1 = __webpack_require__(394);
	const worker_1 = __webpack_require__(311);
	exports.createTDProjectEditorWorkerProviders = () => {
	    return [
	        ...core_1.createTDProjectCoreProviders(),
	        new worker_1.FileImporterProvider("tdproject", (request) => request.targetObject && request.targetObject.nodeName === "tandem", importers_1.TDRootFileImporter)
	    ];
	};
	__export(__webpack_require__(386));


/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const sandbox_1 = __webpack_require__(167);
	const constants_1 = __webpack_require__(295);
	const common_1 = __webpack_require__(46);
	const synthetic_1 = __webpack_require__(387);
	const synthetic_browser_1 = __webpack_require__(216);
	const html_extension_1 = __webpack_require__(378);
	function createTDProjectCoreProviders() {
	    return [
	        // elements
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(constants_1.TDPROJECT_XMLNS, "template", synthetic_1.SyntheticTDTemplateElement),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(constants_1.TDPROJECT_XMLNS, "tandem", synthetic_1.SyntheticTDRootElement),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(constants_1.TDPROJECT_XMLNS, "ruler", synthetic_1.SyntheticTDRulerElement),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(constants_1.TDPROJECT_XMLNS, "ruler-line", synthetic_1.SyntheticTDRulerLineElement),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(constants_1.TDPROJECT_XMLNS, "artboard", synthetic_1.SyntheticTDArtboardElement),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(constants_1.TDPROJECT_XMLNS, "link", html_extension_1.SyntheticHTMLLink),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(constants_1.TDPROJECT_XMLNS, "default", synthetic_browser_1.SyntheticHTMLElement),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(constants_1.TDPROJECT_XMLNS, "script", html_extension_1.SyntheticHTMLScript),
	        new synthetic_browser_1.SyntheticDOMElementClassProvider(constants_1.TDPROJECT_XMLNS, "style", html_extension_1.SyntheticHTMLStyle),
	        // mime types
	        new common_1.MimeTypeAliasProvider(constants_1.TDPROJECT_MIME_TYPE, common_1.HTML_MIME_TYPE),
	        new common_1.MimeTypeProvider("tdm", constants_1.TDPROJECT_MIME_TYPE),
	        new common_1.MimeTypeProvider("tandem", constants_1.TDPROJECT_MIME_TYPE),
	        // xml namespaces
	        new synthetic_browser_1.MarkupMimeTypeXMLNSProvider(constants_1.TDPROJECT_MIME_TYPE, constants_1.TDPROJECT_XMLNS),
	        // editors
	        new sandbox_1.ContentEditorFactoryProvider(constants_1.TDPROJECT_MIME_TYPE, synthetic_browser_1.MarkupEditor, true),
	    ];
	}
	exports.createTDProjectCoreProviders = createTDProjectCoreProviders;


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(388));


/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(389));
	__export(__webpack_require__(390));
	__export(__webpack_require__(391));
	__export(__webpack_require__(392));
	__export(__webpack_require__(393));


/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const synthetic_browser_1 = __webpack_require__(216);
	const _cache = {};
	function getScript(source) {
	    if (_cache[source])
	        return _cache[source];
	    return _cache[source] = new Function(`element`, `attributes`, `
	    with(attributes) with(element) {
	      try {
	        return ${source}
	      } catch(e) {
	        return undefined;
	      }
	    }
	  `);
	}
	class SyntheticTDTemplateElement extends synthetic_browser_1.SyntheticHTMLElement {
	    createdCallback() {
	        if (this.hasAttribute("id")) {
	            const id = this.getAttribute("id");
	            this.registerTemplateElement(id);
	        }
	        else if (this.hasAttribute("is")) {
	            this.cast(this.getAttribute("is"));
	        }
	        else {
	            this.attach(this);
	        }
	    }
	    registerTemplateElement(tagName) {
	        const template = this;
	        this.ownerDocument.registerElementNS(this.namespaceURI, tagName, class SyntheticModuleElement extends synthetic_browser_1.SyntheticHTMLElement {
	            createdCallback() {
	                template.attach(this);
	            }
	        }
	        );
	    }
	    cast(tagName) {
	        const elementClass = this.ownerDocument.$getElementClassNS(this.namespaceURI, tagName);
	        const element = new elementClass(this.namespaceURI, tagName);
	        element.$setOwnerDocument(this.ownerDocument);
	        const shadow = this.attachShadow({ mode: "open" });
	        shadow.appendChild(element);
	        this.attach(element);
	        element.$createdCallback();
	    }
	    attach(element) {
	        const shadow = element.attachShadow({ mode: "open" });
	        const div = element.ownerDocument.createElementNS(this.namespaceURI, "div");
	        div.innerHTML = this.parseTemplate(element, this.innerHTML);
	        while (div.firstChild)
	            shadow.appendChild(div.firstChild);
	    }
	    parseTemplate(element, source) {
	        return source.replace(/{{.*?}}/g, (block, script) => {
	            const ret = this.evaluateBlock(block, element);
	            if (ret instanceof synthetic_browser_1.SyntheticDOMAttribute) {
	                return ret.value;
	            }
	            if (ret === element.childNodes) {
	                return element.innerHTML;
	            }
	            return ret;
	        });
	    }
	    evaluateBlock(block, element) {
	        if (!/{{.*?}}/.test(block))
	            return block;
	        const fn = getScript(block.substr(2, block.length - 4));
	        return fn(element, element.attributes);
	    }
	}
	exports.SyntheticTDTemplateElement = SyntheticTDTemplateElement;


/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const path = __webpack_require__(6);
	const mesh_1 = __webpack_require__(13);
	const lodash_1 = __webpack_require__(56);
	const common_1 = __webpack_require__(46);
	const synthetic_browser_1 = __webpack_require__(216);
	// TODO - watch src for any changes
	let SyntheticTDArtboardElement = class SyntheticTDArtboardElement extends synthetic_browser_1.SyntheticHTMLElement {
	    constructor() {
	        super(...arguments);
	        this.status = new common_1.Status(null);
	        this.loadBrowser = lodash_1.debounce(() => __awaiter(this, void 0, void 0, function* () {
	            if (!this._artboardBrowser)
	                return;
	            if (this.hasAttribute("src")) {
	                const src = this.getAttribute("src");
	                const window = this.ownerDocument.defaultView;
	                this._artboardBrowser.open({
	                    url: this.getAttribute("src"),
	                    injectScript: decodeURIComponent(this.getAttribute("inject-script")),
	                    dependencyGraphStrategyOptions: this.getAttribute("dependency-graph-strategy") && {
	                        name: this.getAttribute("dependency-graph-strategy"),
	                        config: this.getAttribute("dependency-graph-config") && path.resolve(this.source.filePath, this.getAttribute("strategy-config"))
	                    }
	                });
	            }
	        }), 0);
	    }
	    createdCallback() {
	        Object.assign(this.style, {
	            position: "absolute",
	            width: "1024px",
	            height: "1024px"
	        }, this.style.toObject());
	        this.innerHTML = `
	      <iframe data-td-selectable="false" style="border: none; width: 100%; height: 100%; position: absolute; left: 0px; top: 0px;" />
	    `;
	    }
	    get contentDocument() {
	        return this._contentDocument;
	    }
	    get title() {
	        return this.getAttribute("title");
	    }
	    set title(value) {
	        this.setAttribute("title", value);
	    }
	    attributeChangedCallback(key, oldValue, newValue) {
	        super.attributeChangedCallback(key, oldValue, newValue);
	        if (/src|strategy|inject/.test(key)) {
	            this.loadBrowser();
	        }
	    }
	    createBrowser() {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (this._artboardBrowser)
	                return;
	            const documentRenderer = new synthetic_browser_1.SyntheticDOMRenderer();
	            this._artboardBrowser = new synthetic_browser_1.RemoteSyntheticBrowser(this.ownerDocument.defaultView.browser.injector, new SyntheticArtboardRenderer(this, documentRenderer), this.browser);
	            common_1.bindProperty(this._artboardBrowser, "status", this, "status").trigger();
	            this._contentDocumentObserver = new mesh_1.CallbackDispatcher(this.onContentDocumentEvent.bind(this));
	            common_1.watchProperty(this._artboardBrowser, "window", this.onBrowserWindowChange.bind(this));
	            yield this.loadBrowser();
	        });
	    }
	    computeCapabilities() {
	        return new synthetic_browser_1.VisibleDOMNodeCapabilities(true, true);
	    }
	    attachNative(node) {
	        if (this._native === node)
	            return;
	        super.attachNative(node);
	        this.createBrowser();
	        const iframe = this._iframe = node.querySelector("iframe");
	        common_1.bubbleHTMLIframeEvents(iframe);
	        const onload = () => __awaiter(this, void 0, void 0, function* () {
	            iframe.contentDocument.body.appendChild(this._artboardBrowser.renderer.element);
	            this._artboardBrowser.renderer.start();
	        });
	        iframe.onload = onload;
	        if (iframe.contentDocument)
	            onload();
	    }
	    get inheritCSS() {
	        return this.hasAttribute("inherit-css");
	    }
	    injectCSS() {
	        const document = this._artboardBrowser.document;
	        if (!this.inheritCSS || !document)
	            return;
	        if (this._combinedStyleSheet) {
	            const index = document.styleSheets.indexOf(this._combinedStyleSheet);
	            if (index !== -1) {
	                document.styleSheets.splice(index, 1);
	            }
	        }
	        // combine the style sheets together to make it easier to replace when
	        // the parent document changes.
	        this._combinedStyleSheet = new synthetic_browser_1.SyntheticCSSStyleSheet([]);
	        this.browser.document.styleSheets.forEach((styleSheet) => {
	            this._combinedStyleSheet.rules.push(...styleSheet.rules);
	        });
	        document.styleSheets.push(this._combinedStyleSheet);
	    }
	    visitWalker(walker) {
	        super.visitWalker(walker);
	        if (this.contentDocument) {
	            walker.accept(this.contentDocument);
	        }
	    }
	    onBrowserWindowChange() {
	        if (this._contentDocument) {
	            this._contentDocument.unobserve(this._contentDocumentObserver);
	        }
	        this._contentDocument = this._artboardBrowser.window.document;
	        this._contentDocument.$ownerNode = this;
	        this._contentDocument.observe(this._contentDocumentObserver);
	        this.injectCSS();
	        // bubble loaded notification here
	        this.notify(new synthetic_browser_1.DOMNodeEvent(synthetic_browser_1.DOMNodeEvent.DOM_NODE_LOADED));
	    }
	    onContentDocumentEvent(event) {
	        this.notify(event);
	    }
	};
	__decorate([
	    common_1.bindable(true)
	], SyntheticTDArtboardElement.prototype, "status", void 0);
	SyntheticTDArtboardElement = __decorate([
	    common_1.serializable()
	], SyntheticTDArtboardElement);
	exports.SyntheticTDArtboardElement = SyntheticTDArtboardElement;
	class SyntheticArtboardRenderer extends synthetic_browser_1.BaseDecoratorRenderer {
	    constructor(_artboard, _renderer) {
	        super(_renderer);
	        this._artboard = _artboard;
	    }
	    getBoundingRect(uid) {
	        const rect = this._renderer.getBoundingRect(uid);
	        const offset = this._artboard.getBoundingClientRect();
	        return rect.move({ left: offset.left, top: offset.top });
	    }
	}
	exports.SyntheticArtboardRenderer = SyntheticArtboardRenderer;


/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const synthetic_browser_1 = __webpack_require__(216);
	class SyntheticTDRulerLineElement extends synthetic_browser_1.SyntheticDOMElement {
	    get type() {
	        return this.getAttribute("type");
	    }
	    set type(value) {
	        this.setAttribute("type", value);
	    }
	    get value() {
	        return Number(this.getAttribute("value") || 0);
	    }
	    set value(value) {
	        this.setAttribute("value", String(value));
	    }
	}
	exports.SyntheticTDRulerLineElement = SyntheticTDRulerLineElement;


/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const synthetic_browser_1 = __webpack_require__(216);
	class SyntheticTDRulerElement extends synthetic_browser_1.SyntheticDOMElement {
	    get disabled() {
	        return this.hasAttribute("disabled");
	    }
	    set disabled(value) {
	        if (value) {
	            this.setAttribute("disabled", String(true));
	        }
	        else {
	            this.removeAttribute("disabled");
	        }
	    }
	}
	exports.SyntheticTDRulerElement = SyntheticTDRulerElement;


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const synthetic_browser_1 = __webpack_require__(216);
	class SyntheticTDRootElement extends synthetic_browser_1.SyntheticHTMLElement {
	    createdCallback() {
	        super.createdCallback();
	        this.setAttribute("data-td-hide-layer", "true");
	    }
	}
	exports.SyntheticTDRootElement = SyntheticTDRootElement;


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const path = __webpack_require__(6);
	const synthetic_browser_1 = __webpack_require__(216);
	const sandbox_1 = __webpack_require__(167);
	const worker_1 = __webpack_require__(311);
	const common_1 = __webpack_require__(46);
	// TODO - open new workspace if dnd file is .tdm mime type
	class TDRootFileImporter {
	    importFile({ filePath, targetObject, bounds }) {
	        return __awaiter(this, arguments, void 0, function* () {
	            // TODO: temporary fix for DNDd files
	            filePath = filePath.replace(/^file:\/\//g, "");
	            const content = String(yield this._fileSystem.readFile(filePath));
	            const element = targetObject;
	            if (content.indexOf("createBodyElement") !== -1) {
	                return this.importPreview(filePath, element, bounds);
	            }
	            const previewLoader = worker_1.PreviewLoaderProvider.find(filePath, this._injector);
	            if (!previewLoader) {
	                throw new Error(`Cannot create preview file`);
	            }
	            const preview = yield previewLoader.loadFilePreview(arguments[0]);
	            if (!(yield this._fileSystem.fileExists(preview.filePath))) {
	                yield this._fileSystem.writeFile(preview.filePath, preview.content);
	                yield this._bus.dispatch(new worker_1.OpenFileRequest(preview.filePath));
	            }
	            return this.importPreview(preview.filePath, element, bounds);
	        });
	    }
	    importPreview(filePath, element, bounds) {
	        return __awaiter(this, void 0, void 0, function* () {
	            if (!bounds)
	                bounds = new common_1.BoundingRect(0, 0, 1024, 768);
	            const { document } = new synthetic_browser_1.SyntheticWindow();
	            const artboard = document.createElement("artboard");
	            artboard.setAttribute("title", path.relative(process.cwd(), filePath));
	            ;
	            artboard.setAttribute("src", filePath);
	            artboard.setAttribute("style", `left:${bounds.left}px;top:${bounds.top}px;width:${bounds.width || 1024}px;height:${bounds.height || 768}px;`);
	            const edit = element.createEdit();
	            edit.appendChild(artboard);
	            this._bus.dispatch(new sandbox_1.ApplyFileEditRequest(edit.mutations, true));
	        });
	    }
	}
	__decorate([
	    common_1.inject(common_1.InjectorProvider.ID)
	], TDRootFileImporter.prototype, "_injector", void 0);
	__decorate([
	    common_1.inject(sandbox_1.FileSystemProvider.ID)
	], TDRootFileImporter.prototype, "_fileSystem", void 0);
	__decorate([
	    common_1.inject(common_1.PrivateBusProvider.ID)
	], TDRootFileImporter.prototype, "_bus", void 0);
	exports.TDRootFileImporter = TDRootFileImporter;


/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(396));


/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const sandbox_1 = __webpack_require__(397);
	const constants_1 = __webpack_require__(400);
	const common_1 = __webpack_require__(46);
	const sandbox_2 = __webpack_require__(167);
	exports.createTypescriptEditorWorkerProviders = () => {
	    return [
	        new common_1.MimeTypeProvider("ts", constants_1.TS_MIME_TYPE),
	        new common_1.MimeTypeProvider("tsx", constants_1.TS_MIME_TYPE),
	        new sandbox_2.ContentEditorFactoryProvider(constants_1.TS_MIME_TYPE, sandbox_1.TSEditor)
	    ];
	};


/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(398));


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const ts = __webpack_require__(399);
	const sandbox_1 = __webpack_require__(167);
	const synthetic_browser_1 = __webpack_require__(216);
	class TSEditor extends sandbox_1.BaseContentEditor {
	    constructor() {
	        super(...arguments);
	        this._replacements = [];
	    }
	    [synthetic_browser_1.SyntheticDOMContainerMutationTypes.MOVE_CHILD_NODE_EDIT](target, action) {
	        const child = this.findTargetASTNode(target, action.child);
	        this._replacements.push({
	            start: child.getStart(),
	            end: child.getEnd(),
	            value: ""
	        });
	        const beforeChild = target.children[action.index];
	        this._replacements.push({
	            start: beforeChild.getStart(),
	            end: beforeChild.getStart(),
	            value: child.getText()
	        });
	    }
	    [synthetic_browser_1.SyntheticDOMContainerMutationTypes.REMOVE_CHILD_NODE_EDIT](target, change) {
	        const child = this.findTargetASTNode(target, change.child);
	        this._replacements.push({
	            start: child.getStart(),
	            end: child.getEnd(),
	            value: ""
	        });
	    }
	    [synthetic_browser_1.SyntheticDOMContainerMutationTypes.INSERT_CHILD_NODE_EDIT](target, change) {
	        if (target.kind === ts.SyntaxKind.JsxSelfClosingElement) {
	            const jsxElement = target;
	            this._replacements.push({
	                start: jsxElement.getEnd() - 2,
	                end: jsxElement.getEnd(),
	                value: `>${change.child.toString()}</${jsxElement.tagName.getText()}>`
	            });
	        }
	        else {
	            const jsxElement = target;
	            const index = change.index;
	            let pos;
	            if (jsxElement.children.length) {
	                pos = jsxElement.children[index >= jsxElement.children.length ? jsxElement.children.length - 1 : index].getEnd();
	            }
	            else {
	                pos = jsxElement.openingElement.getEnd();
	            }
	            this._replacements.push({
	                start: pos,
	                end: pos,
	                value: change.child.toString()
	            });
	        }
	    }
	    [synthetic_browser_1.SyntheticDOMElementMutationTypes.SET_ELEMENT_ATTRIBUTE_EDIT](target, change) {
	        function alternativeName(name) {
	            return {
	                class: "className"
	            }[name];
	        }
	        const modify = (target) => {
	            let found;
	            for (const attribute of target.attributes) {
	                // TODO - need to consider spreads
	                const attr = attribute;
	                if (attr.name.text === change.name || attr.name.text === alternativeName(change.name)) {
	                    found = true;
	                    // if the attribute value is undefined, then remove it
	                    if (change.newValue == null) {
	                        this._replacements.push({
	                            // remove whitespace with -1
	                            start: attr.getStart(),
	                            end: attr.getEnd(),
	                            value: ``
	                        });
	                    }
	                    else {
	                        this._replacements.push({
	                            start: attr.initializer.getStart(),
	                            end: attr.initializer.getEnd(),
	                            value: `"${change.newValue}"`
	                        });
	                    }
	                }
	            }
	            if (!found) {
	                this._replacements.push({
	                    start: target.tagName.getEnd(),
	                    end: target.tagName.getEnd(),
	                    value: ` ${change.name}="${change.newValue}"`
	                });
	            }
	        };
	        if (target.kind === ts.SyntaxKind.JsxSelfClosingElement) {
	            modify(target);
	        }
	        else if (target.kind === ts.SyntaxKind.JsxElement) {
	            modify(target.openingElement);
	        }
	    }
	    parseContent(content) {
	        return ts.createSourceFile(this.fileName, content, ts.ScriptTarget.ES6, true);
	        ;
	    }
	    findTargetASTNode(root, target) {
	        let found;
	        const content = root.getSourceFile().getText();
	        const find = (node) => {
	            const pos = ts.getLineAndCharacterOfPosition(root.getSourceFile(), node.getFullStart());
	            const tstart = target.$source.start;
	            if (target.nodeType === synthetic_browser_1.DOMNodeType.ELEMENT) {
	                // look for the tag name Identifier
	                if (node.kind === ts.SyntaxKind.Identifier && pos.line + 1 === tstart.line && pos.character - 1 === tstart.column) {
	                    found = node.parent;
	                    if (found.kind === ts.SyntaxKind.JsxOpeningElement) {
	                        found = found.parent;
	                    }
	                }
	            }
	            if (!found)
	                ts.forEachChild(node, find);
	        };
	        ts.forEachChild(root, find);
	        return found;
	    }
	    getFormattedContent(root) {
	        let text = this.content;
	        const replacements = this._replacements.sort((a, b) => {
	            return a.start > b.start ? -1 : 1;
	        });
	        for (const { start, end, value } of replacements) {
	            text = text.substr(0, start) + value + text.substr(end);
	        }
	        return text;
	    }
	}
	exports.TSEditor = TSEditor;


/***/ },
/* 399 */
/***/ function(module, exports) {

	module.exports = require("typescript");

/***/ },
/* 400 */
/***/ function(module, exports) {

	"use strict";
	exports.TS_MIME_TYPE = "text/typescript";


/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(402));
	__export(__webpack_require__(404));
	__export(__webpack_require__(405));
	__export(__webpack_require__(406));


/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const base_1 = __webpack_require__(403);
	const common_1 = __webpack_require__(46);
	const sandbox_1 = __webpack_require__(167);
	class ApplyFileEditCommand extends base_1.BaseStudioWorkerCommand {
	    execute(request) {
	        this._fileEditor.applyMutations(request.mutations);
	    }
	}
	__decorate([
	    common_1.inject(sandbox_1.FileEditorProvider.ID)
	], ApplyFileEditCommand.prototype, "_fileEditor", void 0);
	exports.ApplyFileEditCommand = ApplyFileEditCommand;


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	const common_1 = __webpack_require__(46);
	class BaseStudioWorkerCommand extends common_1.BaseCommand {
	}
	exports.BaseStudioWorkerCommand = BaseStudioWorkerCommand;


/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	const base_1 = __webpack_require__(403);
	const common_1 = __webpack_require__(46);
	const sandbox_1 = __webpack_require__(167);
	class SyncFileCacheCommand extends base_1.BaseStudioWorkerCommand {
	    execute() {
	        this._fileCache.syncWithLocalFiles();
	    }
	}
	__decorate([
	    common_1.inject(sandbox_1.FileCacheProvider.ID)
	], SyncFileCacheCommand.prototype, "_fileCache", void 0);
	exports.SyncFileCacheCommand = SyncFileCacheCommand;


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
	    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	    return c > 3 && r && Object.defineProperty(target, key, r), r;
	};
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const common_1 = __webpack_require__(46);
	const common_2 = __webpack_require__(46);
	const sandbox_1 = __webpack_require__(167);
	const worker_1 = __webpack_require__(311);
	let ImportFileCommand = class ImportFileCommand {
	    execute(request) {
	        return __awaiter(this, void 0, void 0, function* () {
	            this.logger.info(`Importing ${request.filePath}`);
	            const importerProvider = worker_1.FileImporterProvider.findByDropTarget(request, this._injector);
	            if (!importerProvider) {
	                throw new Error(`File type supported.`);
	            }
	            const importer = importerProvider.create();
	            yield importer.importFile(request);
	        });
	    }
	};
	__decorate([
	    common_1.inject(sandbox_1.FileSystemProvider.ID)
	], ImportFileCommand.prototype, "_fileSystem", void 0);
	__decorate([
	    common_1.inject(common_2.InjectorProvider.ID)
	], ImportFileCommand.prototype, "_injector", void 0);
	ImportFileCommand = __decorate([
	    common_1.loggable()
	], ImportFileCommand);
	exports.ImportFileCommand = ImportFileCommand;


/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
	    return new (P || (P = Promise))(function (resolve, reject) {
	        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
	        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	        step((generator = generator.apply(thisArg, _arguments)).next());
	    });
	};
	const common_1 = __webpack_require__(46);
	const mesh_1 = __webpack_require__(13);
	const messages_1 = __webpack_require__(304);
	const PING_TIMEOUT = 1000 * 10;
	/**
	 * ensures that the worker doesn't turn into a zombie after master closes.
	 */
	class StartMasterPingCommand extends common_1.BaseCommand {
	    execute() {
	        const ping = () => __awaiter(this, void 0, void 0, function* () {
	            this.logger.debug("Pinging master");
	            const value = (yield mesh_1.readOneChunk(this.bus.dispatch(new messages_1.PingRequest()))).value;
	            if (value !== true) {
	                this.logger.warn(`Master didn't return a ping -- closing server`);
	                process.exit(1);
	            }
	            setTimeout(ping, PING_TIMEOUT);
	        });
	        ping();
	    }
	}
	exports.StartMasterPingCommand = StartMasterPingCommand;


/***/ }
/******/ ]);