{

const {
  HTMLFragmentExpression,
  HTMLTextExpression,
  HTMLScriptExpression,
  HTMLCommentExpression,
  HTMLElementExpression,
  HTMLAttributeExpression
} = require('tandem-html-extension/ast');

const {
  PCBlockNodeExpression,
  PCBlockAttributeExpression,
} = require('./expressions');

function position() {
  return {
    start:peg$savedPos,
    end:peg$currPos
  };
}

}

Start
  = Fragment

Fragment
  = nodes:Node* {
    return new HTMLFragmentExpression(nodes, position());
  }

Node
  = _ node:(Comment/VoidElement/Element/BlockNode/TextNode) _ { return node; }

Comment
  = '<!--' characters:CommentCharacter* '-->' { return new HTMLCommentExpression(characters.join(''), position()); }

CommentCharacter
  = !'-->' character:. { return character; }

VoidElement
  = "<" nodeName:("area"/"base"/"br"/"col"/"command"/"embed"/"hr"/"img"/"input"/"keygen"/"link"/"meta"/"param"/"source"/"track"/"wbr") attributes:ElementAttributes (">"/"/>")? endTag:EndVoidTag? {

    if (endTag && nodeName != endTag.name) {
      expected("</" + nodeName + ">");
    }

    return new HTMLElementExpression(nodeName, attributes, [], position());
  }

EndVoidTag
  = _ "</" name:("area"/"base"/"br"/"col"/"command"/"embed"/"hr"/"img"/"input"/"keygen"/"link"/"meta"/"param"/"source"/"track"/"wbr") ">" {
    return {
      name: name
    };
  }

Element
  = ElementWithoutChildNodes
  / ElementWithChildNodes

ElementWithoutChildNodes
  = startTag:ElementStart attributes:ElementAttributes '/>' {
    return new HTMLElementExpression(startTag, attributes, [], position());
  }

ElementWithChildNodes
  = startTag:ElementStart attributes:ElementAttributes '>' _ childNodes:Node* _ '</' endTag:Name '>' {
    if (startTag != endTag) {
      expected('</' + startTag + '>');
    }
    return new HTMLElementExpression(startTag, attributes, childNodes, position());
  }

ElementStart
  = '<' name:Name { return name; }

ElementAttributes
  = _ attributes:ElementAttribute* _ {
    return attributes;
  }

ElementAttribute
  = _ key:Name '=' value:AttributeValue _ {
    return new HTMLAttributeExpression(key, value, position());
  }
  / _ key:Name _ {
    return new HTMLAttributeExpression(key, "");
  }

AttributeValue
  = AttributeBlock/String

AttributeBlock
  = value: Block {
    return new PCBlockAttributeExpression("attributeBlockValue", value, position());
  }

String
  = '"' characters:DoubleStringCharacter* '"' { return characters.join(''); }
  / "'" characters:SingleStringCharacter* "'" { return characters.join(''); }

DoubleStringCharacter
  = !('"' / "\\") . { return text(); }
  / '\\"'

SingleStringCharacter
  = !("'" / "\\") . { return text(); }
  / "\\'"

TextNode
  = TextNodeCharacter+ {
    return new HTMLTextExpression(text(), position());
  }

TextNodeCharacter
  = !("<"/"${") . {
    return text();
  }

Name
  = [a-z0-9$-.]+ { return text(); }
_
  = [ \n\r\t]*

BlockNode
  = value: Block {
    return new PCBlockNodeExpression(value, position());
  }

Block
  = "${" script: BlockInner* "}" {
    return script.join("");
  }

BlockInner
  = "{" BlockInner "}" { return text(); }
  / [^}{]+ { return text(); }